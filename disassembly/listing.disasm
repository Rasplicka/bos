Disassembly Listing for test_nos
Generated From:
D:/bos/bos/dist/default/debug/bos.debug.elf
7.2.2018 11:02:51

---  d:/bos/bos/usb_device_mm.c  ------------------------------------------------------------------------
1:                   #include <xc.h>
2:                   #include "def.h"
3:                   #include "usb_device_mm.h"
4:                   
5:                   // <editor-fold defaultstate="collapsed" desc="file description">
6:                   /*
7:                    * Autor JR
8:                    * verze 1.0
9:                    * driver pro USB device
10:                   * pouze procesor PIC32MM0256 (je-li definovano PIC32MM0256 - 0064 nema USB)
11:                   * http://www.keil.com/forum/12679/
12:                   */
13:                  // </editor-fold>
14:                  
15:                  // <editor-fold defaultstate="collapsed" desc="Examples">
16:                  /*
17:                  //odeslani bufferu 
18:                  char buffer[64];
19:                  char ep=1;
20:                  while(USB_isTxProgress(ep)) { doEvents(); }
21:                  usbDevice_txData(ep, buffer, 64);
22:                   * 
23:                    
24:                   //reakce na pozadavek z hosta
25:                   char buffer_cmd[4];                                //buffer pro prijem command z hosta (command size = 4 Bytes)
26:                   char data_out[64]                                  //buffer pro data do hosta
27:                   char ep=1;
28:                   usbDevice_rxData(ep, buffer_cmd, 4)                
29:                   while(usbDevice_isRxProgress(ep)) { doEvents(); }  //ceka na data z hosta (host vzdy zacina komunikaci)
30:                   
31:                   //prisel pozadavek z hosta, dekoduj ho 
32:                   if(buffer_cmd[0]==1) 
33:                   {
34:                      fillBufferA(data_out);              //command==1, napln buffer daty A
35:                   }
36:                   else
37:                   {
38:                      fillBufferB(data_out);              //command!=1, napln buffer daty B
39:                   } 
40:                   while(USB_isTxProgress(ep)) { doEvents(); } 
41:                   usbDevice_txData(ep, data_out, 64);    //osedlani dat
42:                   */
43:                  // </editor-fold>
44:                  
45:                  
46:                  #if (defined PIC32MM0256 && defined USB_DEVICE_INIT)
47:                  
48:                  
49:                  /*
50:                  Cteni dat z PIC
51:                  1.PC odesle OUT TOKEN s informaci, jaka data pozaduje
52:                  2.PIC pripravi data v IN bufferu a vola PrepareTransmitData(len)
53:                    ktera pripravi USB modul na IN TOKEN (preda rizeni SIO)
54:                  3.PC odesle IN TOKEN a SIO automaticky odesila obsah buferu
55:                   *
56:                   * SIO stridave odesila EVEN a ODD buffer (adresa v BD EVEN a BD ODD)
57:                   * ale EVEN i ODD pouzivaji jeden buffer
58:                   * takze data sw uklada vzdy do jednoho bufferu
59:                   * PrepareTransmitData(len) pripravi k odeslani EVEN i ODD
60:                   *
61:                   * priklad: (odeslat 3 bytes)
62:                   * FillInBuffer(0, x);
63:                   * FillInBuffer(1, y);
64:                   * FillInBuffer(2, z);
65:                   * PrepareTransmitData(3);
66:                   * //nasledujici IN TOKEN odesle tyto 3 bytes
67:                   *
68:                   *  priklad 2 (odeslat 4 bytes)
69:                   * PrepareTransmitData4(a, b, c, d)
70:                   * //nasledujici IN TOKEN odesle tyto 4 bytes
71:                   *
72:                   * Max. delka (velikost bufferu) 64 bytes
73:                  */
74:                  
75:                  typedef struct
76:                  {
77:                      char data;
78:                      char :8;
79:                      short size;
80:                      int ptr;
81:                  }BD_ITEM;
82:                  
83:                  typedef struct
84:                  {
85:                      struct
86:                      {
87:                          char Recipient:5;
88:                          char Type:2;
89:                          char Direction:1;
90:                      }bmRequestType;  
91:                      
92:                      char bRequest;
93:                      char bValueL;
94:                      char bValueH;
95:                      short wIndex;
96:                      short wLenght;
97:                      
98:                  }SETUP_TOKEN;
99:                  
100:                 
101:                 //max. pocet EP je 15, resp. max. velikost conf. descriptoru je 128B
102:                 //conf descriptor obsahuje conf. desc. (9B) + iface (9B) + EP descriptory (7B), celkem max. 128B
103:                 //EP jsou defaultne nastaveny v modu interrupt/100ms
104:                 
105:                 
106:                 #define     EP_COUNT        4       //pocet EP, bez EP0_OUT a EP0_IN (ty jsou povinne)
107:                 #define     EP1_OUT         64      //definuje pouzity EndPoint a velikost bufferu
108:                 #define     EP1_IN          64      //definuje pouzity EndPoint a velikost bufferu
109:                 #define     EP2_OUT         64      //definuje pouzity EndPoint a velikost bufferu
110:                 #define     EP2_IN          64      //definuje pouzity EndPoint a velikost bufferu
111:                 //#define     EP3_OUT         64      //definuje pouzity EndPoint a velikost bufferu
112:                 //#define     EP3_IN          64      //definuje pouzity EndPoint a velikost bufferu
113:                 //#define     EP4_OUT         64      //definuje pouzity EndPoint a velikost bufferu
114:                 //#define     EP4_IN          64      //definuje pouzity EndPoint a velikost bufferu
115:                 
116:                 #define     USBBUS_CURRENT  20      //spotreba na VBus +5V [mA]
117:                 
118:                 // <editor-fold defaultstate="collapsed" desc="EP0 a BD Table">
119:                 #define     DESC_SIZE       8       //velikost descriptoru (kazdy EP ma 4 descriptory)
120:                 
121:                 //musi byt na adrese delitelne 512 (b0-b8 = 0)
122:                 char bd_table[DESC_SIZE * 4 * (EP_COUNT + 2)] __attribute__((aligned(512)));
123:                 char bufferOut0[8];                 //setup paket ma 8 bytes
124:                 //IN data (descriptory) jsou ve flash
125:                 
126:                 SETUP_TOKEN* setup_token=(SETUP_TOKEN*)bufferOut0;      //prekryva OUT buffer EP0, pro snazsi pristup k datum
127:                 BD_ITEM* bd_ep0_in_even;                                //prekryva BD, pro snazsi pristup k datum
128:                 //BD_ITEM* bd_ep0_in_odd;             //prekryva BD, pro snazsi pristup k datum
129:                 
130:                 // </editor-fold>
131:                 
132:                 // <editor-fold defaultstate="collapsed" desc="USB consts">
133:                 #define     EP_MODE_ISO             1
134:                 #define     EP_MODE_BULK            2
135:                 #define     EP_MODE_INT             3
136:                 
137:                 #define     DIRECTION_OUT           0
138:                 #define     DIRECTION_IN            1
139:                 #define     PPBI_EVEN               0
140:                 #define     PPBI_ODD                1
141:                 #define     OUT_TOKEN               1
142:                 #define     IN_TOKEN                9
143:                 #define     SETUP_TOKEN             13
144:                 
145:                 //Standard Request
146:                 #define     GET_STATUS              0x00
147:                 #define     CLEAR_FEATURE           0x01
148:                 #define     SET_FEATURE             0x03
149:                 #define     SET_ADDRESS             0x05
150:                 #define     GET_DESCRIPTOR          0x06
151:                 #define     SET_DESCRIPTOR          0x07
152:                 #define     GET_CONFIGURATION       0x08
153:                 #define     SET_CONFIGURATION       0x09
154:                 #define     GET_INTERFACE           0x0A
155:                 #define     SET_INTERFACE           0x0B
156:                 #define     SYNCH_FRAME             0x0C
157:                 #define     SET_IDLE                0x0A
158:                 #define     DTYPE_DEVICE            0x01
159:                 #define     DTYPE_CONFIGURATION     0x02
160:                 #define     DTYPE_STRING            0x03
161:                 #define     DTYPE_QUALIFIER         0x06
162:                 #define     DTYPE_OTHER             0x07
163:                 #define     DTYPE_REPORT            0x22
164:                 //Recipient
165:                 #define     DEVICE                  0x0
166:                 #define     INTERFACE               0x1
167:                 #define     ENDPOINT                0x2
168:                 #define     OTHER                   0x3
169:                 
170:                 // </editor-fold>
171:                 
172:                 // <editor-fold defaultstate="collapsed" desc="vars">
173:                 char address        = 0;
174:                 char isize          = 0;
175:                 int ibuff           = 0;
176:                 char is_connected   = 0;
177:                 char datain         = 0;
178:                 // </editor-fold>
179:                 
180:                 // <editor-fold defaultstate="collapsed" desc="MACRO">
181:                 #define     VA_TO_PA(a)         (int)a & 0x7FFFFFFF     //nuluje b31, plati pro RAM i FLASH
182:                 //#define     FLASHVA_TO_PA(a)    (int)a & 0x00FFFFFF | 0x1D000000   
183:                 
184:                 // </editor-fold>
185:                 
186:                 // <editor-fold defaultstate="collapsed" desc="Descriptor, String">
187:                 const char cd[] ={
188:                     //configuration desc. + iface + ep descriptor
189:                     9,                      //delka conf.
190:                     0x02,                   //Conf. Descriptor
191:                     18 + (EP_COUNT * 7),    //total size L (+ iface, ep...)
192:                     0,                      //total size H
193:                     0x01,                   //iface count
194:                     0x01,                   //number conf.
195:                     0x00,                   //string index
196:                     0b10000000,             //attrib. self power, no wake-up 1110 0000
197:                     USBBUS_CURRENT / 2,     //spending mA (1 unit = 2mA) 200 units = 100mA
198:                                             
199:                     //iface
200:                     0x09,                   //iface lenght
201:                     0x04,                   //iface descriptor
202:                     0x00,                   //index iface
203:                     0x00,                   //index alt.
204:                     EP_COUNT,
205:                     0x00,                   //class code HID
206:                     0x00,                   //subclass code
207:                     0x00,                   //protocol 02
208:                     0x00,                   //string index
209:                 
210:                     //EP1 IN
211:                     0x07,                   //lenght
212:                     0x05,                   //EP descriptor
213:                     0b10000001,             //EP1 - in
214:                     EP_MODE_BULK,            //interrupt ...11, izo ...01
215:                     EP1_IN,                 //velikost bufferu L
216:                     0x00,                   //velikost bufferu H
217:                     100,                    //interrupt interval ms, izo = 1
218:                 
219:                     //EP1 OUT
220:                     0x07,                   //lenght
221:                     0x05,                   //EP descriptor
222:                     0b00000001,             //EP1 - out
223:                     EP_MODE_BULK,            //interrupt ...11, izo ...01
224:                     EP1_OUT,                //velikost bufferu L
225:                     0x00,                   //velikost bufferu H
226:                     100,                    //interrupt interval ms, izo = 1
227:                 
228:                 #ifdef EP2_IN    
229:                     //EP2 IN
230:                     0x07,                   //lenght
231:                     0x05,                   //EP descriptor
232:                     0b10000010,             //EP2 - in
233:                     EP_MODE_INT,            //interrupt ...11, izo ...01
234:                     EP2_IN,                 //velikost bufferu L
235:                     0x00,                   //velikost bufferu H
236:                     100,                    //interrupt interval ms, izo = 1
237:                 #endif    
238:                 
239:                 #ifdef EP2_OUT     
240:                     //EP2 OUT
241:                     0x07,                   //lenght
242:                     0x05,                   //EP descriptor
243:                     0b00000010,             //EP2 - out
244:                     EP_MODE_INT,            //interrupt ...11, izo ...01
245:                     EP2_OUT,                //velikost bufferu L
246:                     0x00,                   //velikost bufferu H
247:                     100,                    //interrupt interval ms, izo = 1
248:                 #endif     
249:                 
250:                 #ifdef EP3_IN     
251:                     //EP3 IN
252:                     0x07,                   //lenght
253:                     0x05,                   //EP descriptor
254:                     0b10000011,             //EP3 - in
255:                     EP_MODE_INT,            //interrupt ...11, izo ...01
256:                     EP3_IN,                 //velikost bufferu L
257:                     0x00,                   //velikost bufferu H
258:                     100,                    //interrupt interval ms, izo = 1
259:                 #endif     
260:                 
261:                 #ifdef EP3_OUT     
262:                     //EP3 OUT
263:                     0x07,                   //lenght
264:                     0x05,                   //EP descriptor
265:                     0b00000011,             //EP3 - out
266:                     EP_MODE_INT,            //interrupt ...11, izo ...01
267:                     EP3_OUT,                //velikost bufferu L
268:                     0x00,                   //velikost bufferu H
269:                     100,                    //interrupt interval ms, izo = 1
270:                 #endif     
271:                     
272:                 #ifdef EP4_IN     
273:                     //EP4 IN
274:                     0x07,                   //lenght
275:                     0x05,                   //EP descriptor
276:                     0b10000100,             //EP4 - in
277:                     EP_MODE_INT,            //interrupt ...11, izo ...01
278:                     EP4_IN,                 //velikost bufferu L
279:                     0x00,                   //velikost bufferu H
280:                     100,                    //interrupt interval ms, izo = 1
281:                 #endif     
282:                 
283:                 #ifdef EP4_OUT     
284:                     //EP4 OUT
285:                     0x07,                   //lenght
286:                     0x05,                   //EP descriptor
287:                     0b00000100,             //EP4 - out
288:                     EP_MODE_INT,            //interrupt ...11, izo ...01
289:                     EP4_OUT,                //velikost bufferu L
290:                     0x00,                   //velikost bufferu H
291:                     100                     //interrupt interval ms, izo = 1    
292:                 #endif 
293:                             
294:                 };
295:                 
296:                 const char dd[] ={
297:                     //device descriptor
298:                     18,             //delka
299:                     0x01,           //Device Descriptor
300:                     0x00,           //verze 2.0 - full speed
301:                     0x02,           //verze 2.0 - full speed
302:                     0x00,           //class
303:                     0x00,           //sub class
304:                     0x00,           //protocol
305:                     64,             //buffer size
306:                 
307:                     0x05,           //vendor id
308:                     0x00,           //vendor id
309:                     0x07,           //product id 05
310:                     0x00,           //product id
311:                     0x40,           //device release 04
312:                     0x07,           //device release 03
313:                     0x01,           //Manufact. string index
314:                     0x02,           //Product string index
315:                     0x00,           //serial Num. string index
316:                     0x01            //Number of configurations
317:                 };
318:                 
319:                 const short sd = 0x0000;            //b0=1-self powered, b1=1-remote wakeup                            
320:                                                     //rozhodujici je hodnota Maximum Power Consumption v conf. descriptoru
321:                 
322:                 const char strManufacturer[] = {
323:                     16, DTYPE_STRING, //celkova delka, string
324:                     'J', 0,
325:                     'R', 0,
326:                     ' ', 0,
327:                     'S', 0,
328:                     'o', 0,
329:                     'f', 0,
330:                     't', 0
331:                 };
332:                 
333:                 const char strProduct[] = {
334:                     16, DTYPE_STRING, //celkova delka, string
335:                     'U', 0,
336:                     'S', 0,
337:                     'B', 0,
338:                     ' ', 0,
339:                     'P', 0,
340:                     'I', 0,
341:                     'C', 0
342:                 };
343:                 
344:                 const char strZero[] = {
345:                     5, DTYPE_STRING,
346:                     0x9, 0x4, 0x0
347:                 }; 
348:                 
349:                 // </editor-fold>
350:                 
351:                 //global fce
352:                 void usbDevice_init()       //inicializace modulu
353:                 {
9D00F474      4FF1   ADDIU SP, SP, -32
9D00F476      CBE7   SW RA, 28(SP)
9D00F478      CBC6   SW S8, 24(SP)
9D00F47A      0FDD   MOVE S8, SP
354:                     U1PWRCbits.USBPWR=1;            //module ON
9D00F47C  41A3BF81   LUI V1, 0xBF81
9D00F47E  BF811443   LDC1 F28, 5187(AT)
9D00F480  14438480   LBU V0, -31616(V1)
9D00F482      8480   MOVEP A1, A3, ZERO, ZERO
9D00F484      EE01   LI A0, 1
9D00F486  0044000C   INS V0, A0, 0, 1
9D00F48A  18438480   SB V0, -31616(V1)
9D00F48C      8480   MOVEP A1, A3, ZERO, ZERO
355:                     
356:                     //adresa DB Table
357:                     //U1BDTP1=0x10;                  //BDT.8  - BDT.15
358:                     //U1BDTP2=0x00;                 //BDT.16 - BDT.23
359:                     //U1BDTP3=0x00;                 //BDT.24 - BDT.31
360:                     int phy_adr=((int)&bd_table) & 0x0FFFFFFF;
9D00F48E  41A28000   LUI V0, 0x8000
9D00F492  30420600   ADDIU V0, V0, 1536
9D00F494      0600   ADDU A0, S0, S0
9D00F496  0042D82C   EXT V0, V0, 0, 28
9D00F49A  F85E0010   SW V0, 16(S8)
361:                     U1BDTP1 = phy_adr >> 8;
9D00F49E  FC5E0010   LW V0, 16(S8)
9D00F4A2  00424080   SRA V0, V0, 8
9D00F4A4  40800C62   BLEZ ZERO, 0x9D010D6C
9D00F4A6      0C62   MOVE V1, V0
9D00F4A8  41A2BF81   LUI V0, 0xBF81
9D00F4AA  BF81F862   LDC1 F28, -1950(AT)
9D00F4AC  F8628670   SW V1, -31120(V0)
9D00F4AE      8670   MOVEP A0, S6, ZERO, S4
362:                     U1BDTP2 = phy_adr >> 16;
9D00F4B0  FC5E0010   LW V0, 16(S8)
9D00F4B4  00428080   SRA V0, V0, 16
9D00F4B8      0C62   MOVE V1, V0
9D00F4BA  41A2BF81   LUI V0, 0xBF81
9D00F4BC  BF81F862   LDC1 F28, -1950(AT)
9D00F4BE  F86286C0   SW V1, -31040(V0)
9D00F4C0      86C0   MOVEP A0, A1, ZERO, S0
363:                     U1BDTP3 = phy_adr >> 24;    //Phys. adresa, nikoliv Virt.
9D00F4C2  FC5E0010   LW V0, 16(S8)
9D00F4C6  0042C080   SRA V0, V0, 24
9D00F4CA      0C62   MOVE V1, V0
9D00F4CC  41A2BF81   LUI V0, 0xBF81
9D00F4CE  BF81F862   LDC1 F28, -1950(AT)
9D00F4D0  F86286D0   SW V1, -31024(V0)
9D00F4D2      86D0   MOVEP A0, A1, ZERO, S2
364:                 
365:                     // <editor-fold defaultstate="collapsed" desc="U1EPx">
366:                     U1EP0 = 0b00001101;             //povolit Tx, Rx, SETUP 
9D00F4D4  41A2BF81   LUI V0, 0xBF81
9D00F4D6  BF81ED8D   LDC1 F28, -4723(AT)
9D00F4D8      ED8D   LI V1, 13
9D00F4DA  F8628700   SW V1, -30976(V0)
9D00F4DC      8700   MOVEP A0, A2, ZERO, ZERO
367:                 
368:                 #ifdef EP1_OUT    
369:                     U1EP1 = 0b00001101; //povolit Tx, Tx, zakazat SETUP
9D00F4DE  41A2BF81   LUI V0, 0xBF81
9D00F4E0  BF81ED8D   LDC1 F28, -4723(AT)
9D00F4E2      ED8D   LI V1, 13
9D00F4E4  F8628710   SW V1, -30960(V0)
9D00F4E6      8710   MOVEP A0, A2, ZERO, S1
370:                 #endif
371:                 #ifdef EP1_IN
372:                     U1EP1 = 0b00001101; //povolit Tx, Tx, zakazat SETUP
9D00F4E8  41A2BF81   LUI V0, 0xBF81
9D00F4EA  BF81ED8D   LDC1 F28, -4723(AT)
9D00F4EC      ED8D   LI V1, 13
9D00F4EE  F8628710   SW V1, -30960(V0)
9D00F4F0      8710   MOVEP A0, A2, ZERO, S1
373:                 #endif    
374:                 
375:                 #ifdef EP2_OUT    
376:                     U1EP2 = 0b00011101; //povolit Tx, Tx, zakazat SETUP
9D00F4F2  41A2BF81   LUI V0, 0xBF81
9D00F4F4  BF81ED9D   LDC1 F28, -4707(AT)
9D00F4F6      ED9D   LI V1, 29
9D00F4F8  F8628720   SW V1, -30944(V0)
9D00F4FA      8720   MOVEP A0, A2, ZERO, V0
377:                 #endif
378:                 #ifdef EP2_IN
379:                     U1EP2 = 0b00011101; //povolit Tx, Tx, zakazat SETUP
9D00F4FC  41A2BF81   LUI V0, 0xBF81
9D00F4FE  BF81ED9D   LDC1 F28, -4707(AT)
9D00F500      ED9D   LI V1, 29
9D00F502  F8628720   SW V1, -30944(V0)
9D00F504      8720   MOVEP A0, A2, ZERO, V0
380:                 #endif   
381:                 
382:                 #ifdef EP3_OUT    
383:                     U1EP3 = 0b00011101; //povolit Tx, Tx, zakazat SETUP
384:                 #endif
385:                 #ifdef EP3_IN
386:                     U1EP3 = 0b00011101; //povolit Tx, Tx, zakazat SETUP
387:                 #endif  
388:                     
389:                     // </editor-fold>
390:                      
391:                     U1CNFG1=0x0;
9D00F506  41A2BF81   LUI V0, 0xBF81
9D00F508  BF81F802   LDC1 F28, -2046(AT)
9D00F50A  F80286E0   SW ZERO, -31008(V0)
9D00F50C      86E0   MOVEP A0, A1, ZERO, S3
392:                     //U1SOF=0b01001010;
393:                     
394:                     U1IRbits.URSTIF=1;
9D00F50E  41A3BF81   LUI V1, 0xBF81
9D00F510  BF811443   LDC1 F28, 5187(AT)
9D00F512  14438600   LBU V0, -31232(V1)
9D00F514      8600   MOVEP A0, S6, ZERO, ZERO
9D00F516      EE01   LI A0, 1
9D00F518  0044000C   INS V0, A0, 0, 1
9D00F51C  18438600   SB V0, -31232(V1)
9D00F51E      8600   MOVEP A0, S6, ZERO, ZERO
395:                     U1IRbits.TRNIF=1;
9D00F520  41A3BF81   LUI V1, 0xBF81
9D00F522  BF811443   LDC1 F28, 5187(AT)
9D00F524  14438600   LBU V0, -31232(V1)
9D00F526      8600   MOVEP A0, S6, ZERO, ZERO
9D00F528      EE01   LI A0, 1
9D00F52A  004418CC   INS V0, A0, 3, 1
9D00F52C  18CC1843   SB A2, 6211(T4)
9D00F52E  18438600   SB V0, -31232(V1)
9D00F530      8600   MOVEP A0, S6, ZERO, ZERO
396:                     U1IEbits.URSTIE=1;          //povolit preruseni RESET
9D00F532  41A3BF81   LUI V1, 0xBF81
9D00F534  BF811443   LDC1 F28, 5187(AT)
9D00F536  14438610   LBU V0, -31216(V1)
9D00F538      8610   MOVEP A0, S6, ZERO, S1
9D00F53A      EE01   LI A0, 1
9D00F53C  0044000C   INS V0, A0, 0, 1
9D00F540  18438610   SB V0, -31216(V1)
9D00F542      8610   MOVEP A0, S6, ZERO, S1
397:                     U1IEbits.TRNIE=1;           //povolit preruseni trn completed
9D00F544  41A3BF81   LUI V1, 0xBF81
9D00F546  BF811443   LDC1 F28, 5187(AT)
9D00F548  14438610   LBU V0, -31216(V1)
9D00F54A      8610   MOVEP A0, S6, ZERO, S1
9D00F54C      EE01   LI A0, 1
9D00F54E  004418CC   INS V0, A0, 3, 1
9D00F550  18CC1843   SB A2, 6211(T4)
9D00F552  18438610   SB V0, -31216(V1)
9D00F554      8610   MOVEP A0, S6, ZERO, S1
398:                 
399:                     U1CONbits.PKTDIS=0;         //povolit prijem paketu
9D00F556  41A3BF81   LUI V1, 0xBF81
9D00F558  BF811443   LDC1 F28, 5187(AT)
9D00F55A  14438650   LBU V0, -31152(V1)
9D00F55C      8650   MOVEP A0, S6, ZERO, S2
9D00F55E  0040294C   INS V0, ZERO, 5, 1
9D00F560      294C   LHU V0, 24(A0)
9D00F562  18438650   SB V0, -31152(V1)
9D00F564      8650   MOVEP A0, S6, ZERO, S2
400:                     
401:                     U1CONbits.USBEN=1;
9D00F566  41A3BF81   LUI V1, 0xBF81
9D00F568  BF811443   LDC1 F28, 5187(AT)
9D00F56A  14438650   LBU V0, -31152(V1)
9D00F56C      8650   MOVEP A0, S6, ZERO, S2
9D00F56E      EE01   LI A0, 1
9D00F570  0044000C   INS V0, A0, 0, 1
9D00F574  18438650   SB V0, -31152(V1)
9D00F576      8650   MOVEP A0, S6, ZERO, S2
402:                     while(U1CONbits.USBEN==0){U1CONbits.USBEN = 1;}
9D00F578      CC0A   B 0x9D00F58E
9D00F57A      0C00   NOP
9D00F57C  41A3BF81   LUI V1, 0xBF81
9D00F57E  BF811443   LDC1 F28, 5187(AT)
9D00F580  14438650   LBU V0, -31152(V1)
9D00F582      8650   MOVEP A0, S6, ZERO, S2
9D00F584      EE01   LI A0, 1
9D00F586  0044000C   INS V0, A0, 0, 1
9D00F58A  18438650   SB V0, -31152(V1)
9D00F58C      8650   MOVEP A0, S6, ZERO, S2
9D00F58E  41A2BF81   LUI V0, 0xBF81
9D00F590  BF81FC42   LDC1 F28, -958(AT)
9D00F592  FC428650   LW V0, -31152(V0)
9D00F594      8650   MOVEP A0, S6, ZERO, S2
9D00F596      2D21   ANDI V0, V0, 0x1
9D00F598  40E2FFF0   BEQZC V0, 0x9D00F57C
9D00F59A  FFF041A3   LW RA, 16803(S0)
403:                 
404:                     U1CONbits.PPBRST=1;
9D00F59C  41A3BF81   LUI V1, 0xBF81
9D00F59E  BF811443   LDC1 F28, 5187(AT)
9D00F5A0  14438650   LBU V0, -31152(V1)
9D00F5A2      8650   MOVEP A0, S6, ZERO, S2
9D00F5A4      EE01   LI A0, 1
9D00F5A6  0044084C   INS V0, A0, 1, 1
9D00F5A8      084C   LBU S0, 12(A0)
9D00F5AA  18438650   SB V0, -31152(V1)
9D00F5AC      8650   MOVEP A0, S6, ZERO, S2
405:                     USB_reset();
9D00F5AE  76807D3C   JALS USB_reset
9D00F5B2      0C00   NOP
406:                 
407:                     // <editor-fold defaultstate="collapsed" desc="interrupt">
408:                     IPC7bits.USBIP = 2;
9D00F5B4  41A3BF81   LUI V1, 0xBF81
9D00F5B6  BF813443   LDC1 F28, 13379(AT)
9D00F5B8  3443F1B0   LHU V0, -3664(V1)
9D00F5BA  F1B0EE02   JALX 0x9EC3B808
9D00F5BC      EE02   LI A0, 2
9D00F5BE  0044628C   INS V0, A0, 10, 3
9D00F5C0  628C3843   LL S4, -1981(T4)
9D00F5C2  3843F1B0   SH V0, -3664(V1)
9D00F5C4  F1B041A3   JALX 0x9EC1068C
409:                     IPC7bits.USBIS = 3;
9D00F5C6  41A3BF81   LUI V1, 0xBF81
9D00F5C8  BF813443   LDC1 F28, 13379(AT)
9D00F5CA  3443F1B0   LHU V0, -3664(V1)
9D00F5CC  F1B0EE03   JALX 0x9EC3B80C
9D00F5CE      EE03   LI A0, 3
9D00F5D0  00444A0C   INS V0, A0, 8, 2
9D00F5D2      4A0C   LW S0, 48(SP)
9D00F5D4  3843F1B0   SH V0, -3664(V1)
9D00F5D6  F1B041A3   JALX 0x9EC1068C
410:                     IFS0bits.USBIF = 0;
9D00F5D8  41A3BF81   LUI V1, 0xBF81
9D00F5DA  BF81FC43   LDC1 F28, -957(AT)
9D00F5DC  FC43F040   LW V0, -4032(V1)
9D00F5DE  F0400040   JALX 0x99000100
9D00F5E0  0040EF4C   INS V0, ZERO, 29, 1
9D00F5E2      EF4C   LI A2, 76
9D00F5E4  F843F040   SW V0, -4032(V1)
9D00F5E6  F04041A3   JALX 0x9901068C
411:                     IEC0bits.USBIE = 1; 
9D00F5E8  41A3BF81   LUI V1, 0xBF81
9D00F5EA  BF81FC43   LDC1 F28, -957(AT)
9D00F5EC  FC43F0C0   LW V0, -3904(V1)
9D00F5EE  F0C0EE01   JALX 0x9B03B804
9D00F5F0      EE01   LI A0, 1
9D00F5F2  0044EF4C   INS V0, A0, 29, 1
9D00F5F4      EF4C   LI A2, 76
9D00F5F6  F843F0C0   SW V0, -3904(V1)
9D00F5F8  F0C00FBE   JALX 0x9B003EF8
412:                     // </editor-fold>
413:                 }
9D00F5FA      0FBE   MOVE SP, S8
9D00F5FC      4BE7   LW RA, 28(SP)
9D00F5FE      4BC6   LW S8, 24(SP)
9D00F600      4C11   ADDIU SP, SP, 32
9D00F602      45BF   JRC RA
414:                 
415:                 int usbDevice_isConnected()
416:                 {
9D00F604      4FB0   ADDIU SP, SP, -8
9D00F606      CBC1   SW S8, 4(SP)
9D00F608      0FDD   MOVE S8, SP
417:                     if(U1ADDR==0 || U1OTGSTATbits.VBUSVD==0 || is_connected==0)
9D00F60A  41A2BF81   LUI V0, 0xBF81
9D00F60C  BF81FC42   LDC1 F28, -958(AT)
9D00F60E  FC428660   LW V0, -31136(V0)
9D00F610      8660   MOVEP A0, S6, ZERO, S3
9D00F612  40E2000B   BEQZC V0, 0x9D00F62C
9D00F616  41A2BF81   LUI V0, 0xBF81
9D00F618  BF81FC42   LDC1 F28, -958(AT)
9D00F61A  FC428460   LW V0, -31648(V0)
9D00F61C      8460   MOVEP A1, A2, ZERO, S3
9D00F61E      2D21   ANDI V0, V0, 0x1
9D00F620  40E20004   BEQZC V0, 0x9D00F62C
9D00F624  145C8064   LBU V0, -32668(GP)
9D00F628  40A20003   BNEZC V0, 0x9D00F632
9D00F62A  00030C40   SRL ZERO, V1, 1
418:                     {
419:                         //nebyla pridelena adresa, nebo VBUS=0, neni pripojeno USB
420:                         return 0;
9D00F62C      0C40   MOVE V0, ZERO
9D00F62E      CC02   B 0x9D00F634
9D00F630      0C00   NOP
421:                     }
422:                     else
423:                     {
424:                         //je pripojeno USB (probehla enumerace)
425:                         return 1;
9D00F632      ED01   LI V0, 1
426:                     }
427:                 }
9D00F634      0FBE   MOVE SP, S8
9D00F636      4BC1   LW S8, 4(SP)
9D00F638      4C05   ADDIU SP, SP, 8
9D00F63A      45BF   JRC RA
428:                 
429:                 void usbDevice_txData(char ep, char* buffer, short int len)
430:                 {
9D00F63C      4FF1   ADDIU SP, SP, -32
9D00F63E      CBE7   SW RA, 28(SP)
9D00F640      CBC6   SW S8, 24(SP)
9D00F642      0FDD   MOVE S8, SP
9D00F644      0C64   MOVE V1, A0
9D00F646  F8BE0024   SW A1, 36(S8)
9D00F64A      0C46   MOVE V0, A2
9D00F64C  187E0020   SB V1, 32(S8)
9D00F650  385E0028   SH V0, 40(S8)
431:                     //odeslani dat (IN token, host cte data)
432:                     //data jsou v bufferu, ktery alokuje volajici fce (muze mit vice bufferu)
433:                     //ppbi vypnuto, pouzije EVEN BD
434:                 
435:                     //char* bd=USB_getBDAddress(ep, DIRECTION_IN, PPBI_EVEN);
436:                     //U1CONbits.PPBRST=1;
437:                     BD_ITEM* p=(BD_ITEM*)USB_getBDAddress(ep, DIRECTION_IN, PPBI_EVEN);
9D00F654  145E0020   LBU V0, 32(S8)
9D00F658      0C82   MOVE A0, V0
9D00F65A      EE81   LI A1, 1
9D00F65C      0CC0   MOVE A2, ZERO
9D00F65E  76807D6A   JALS USB_getBDAddress
9D00F662      0C00   NOP
9D00F664  F85E0010   SW V0, 16(S8)
438:                     p->size=len;
9D00F668  FC5E0010   LW V0, 16(S8)
9D00F66C  347E0028   LHU V1, 40(S8)
9D00F670      A9A1   SH V1, 2(V0)
439:                     p->ptr=VA_TO_PA(buffer);  //(int)buffer & 0x0FFFFFFF;
9D00F672  FC5E0024   LW V0, 36(S8)
9D00F676  0062F02C   EXT V1, V0, 0, 31
9D00F678  F02CFC5E   JALX 0x98B3F178
9D00F67A  FC5E0010   LW V0, 16(S8)
9D00F67E      E9A1   SW V1, 4(V0)
440:                     p->data=0x80 | datain << 6;
9D00F680  145C8065   LBU V0, -32667(GP)
9D00F684      252C   SLL V0, V0, 6
9D00F686  00622B3C   SEB V1, V0
9D00F688      2B3C   LHU A2, 24(V1)
9D00F68A  3040FF80   ADDIU V0, ZERO, -128
9D00F68C  FF8044D3   LW GP, 17619(ZERO)
9D00F68E      44D3   OR16 V0, V1
9D00F690  00422B3C   SEB V0, V0
9D00F692      2B3C   LHU A2, 24(V1)
9D00F694      2DAD   ANDI V1, V0, 0xFF
9D00F696  FC5E0010   LW V0, 16(S8)
9D00F698  001089A0   SUB S1, S0, ZERO
9D00F69A      89A0   SB V1, 0(V0)
441:                     datain++;
9D00F69C  145C8065   LBU V0, -32667(GP)
9D00F6A0      6D20   ADDIU V0, V0, 1
9D00F6A2      2D2D   ANDI V0, V0, 0xFF
9D00F6A4  185C8065   SB V0, -32667(GP)
442:                     
443:                     /*
444:                     short int* bd16=(short int*)bd;
445:                     bd16[1]=len;
446:                     
447:                     //adresa bufferu (physical addr)
448:                     int* bd32=(int*)bd;
449:                     bd32[1]=(int)buffer & 0x0FFFFFFF;    
450:                     
451:                     //b7=1 (UOWN=1 - SIE vlastni buffer), b6=1 DATA0/1 
452:                     bd[0]=0x90;
453:                     */
454:                 }
9D00F6A8      0FBE   MOVE SP, S8
9D00F6AA      4BE7   LW RA, 28(SP)
9D00F6AC      4BC6   LW S8, 24(SP)
9D00F6AE      4C11   ADDIU SP, SP, 32
9D00F6B0      45BF   JRC RA
9D00F6B2      0C00   NOP
455:                 
456:                 int usbDevice_isTxProgress(char ep)
457:                 {
9D00F6B4      4FF1   ADDIU SP, SP, -32
9D00F6B6      CBE7   SW RA, 28(SP)
9D00F6B8      CBC6   SW S8, 24(SP)
9D00F6BA      0FDD   MOVE S8, SP
9D00F6BC      0C44   MOVE V0, A0
9D00F6BE  185E0020   SB V0, 32(S8)
458:                     //vraci 1, pokud probiha vysilani (jeste nebyl odvysilany paket)
459:                     //bd[0].b7=1 SIE pracuje, 0=dokonceno CPU vlastni buffer
460:                     
461:                     BD_ITEM* p=(BD_ITEM*)USB_getBDAddress(ep, DIRECTION_IN, PPBI_EVEN);
9D00F6C2  145E0020   LBU V0, 32(S8)
9D00F6C6      0C82   MOVE A0, V0
9D00F6C8      EE81   LI A1, 1
9D00F6CA      0CC0   MOVE A2, ZERO
9D00F6CC  76807D6A   JALS USB_getBDAddress
9D00F6D0      0C00   NOP
9D00F6D2  F85E0010   SW V0, 16(S8)
462:                     return p->data>>7;
9D00F6D6  FC5E0010   LW V0, 16(S8)
9D00F6D8  00100920   ADD AT, S0, ZERO
9D00F6DA      0920   LBU V0, 0(V0)
9D00F6DC      252F   SRL V0, V0, 7
9D00F6DE      2D2D   ANDI V0, V0, 0xFF
463:                     
464:                     //char* bd=USB_getBDAddress(ep, DIRECTION_IN, PPBI_EVEN);
465:                     //return bd[0]>>7;
466:                 }
9D00F6E0      0FBE   MOVE SP, S8
9D00F6E2      4BE7   LW RA, 28(SP)
9D00F6E4      4BC6   LW S8, 24(SP)
9D00F6E6      4C11   ADDIU SP, SP, 32
9D00F6E8      45BF   JRC RA
9D00F6EA      0C00   NOP
467:                 
468:                 void usbDevice_rxData(char ep, char* buffer, short int len)
469:                 {
9D00F6EC      4FF1   ADDIU SP, SP, -32
9D00F6EE      CBE7   SW RA, 28(SP)
9D00F6F0      CBC6   SW S8, 24(SP)
9D00F6F2      0FDD   MOVE S8, SP
9D00F6F4      0C64   MOVE V1, A0
9D00F6F6  F8BE0024   SW A1, 36(S8)
9D00F6FA      0C46   MOVE V0, A2
9D00F6FC  187E0020   SB V1, 32(S8)
9D00F700  385E0028   SH V0, 40(S8)
470:                     //prijem dat (OUT token, host posila data)
471:                     //data jsou v bufferu, ktery alokuje volajici fce (muze mit vice bufferu)
472:                     //ppbi vypnuto, pouzije EVEN BD
473:                     
474:                     //U1CONbits.PPBRST=1;
475:                     BD_ITEM* p=(BD_ITEM*)USB_getBDAddress(ep, DIRECTION_OUT, PPBI_EVEN);
9D00F704  145E0020   LBU V0, 32(S8)
9D00F708      0C82   MOVE A0, V0
9D00F70A      0CA0   MOVE A1, ZERO
9D00F70C      0CC0   MOVE A2, ZERO
9D00F70E  76807D6A   JALS USB_getBDAddress
9D00F712      0C00   NOP
9D00F714  F85E0010   SW V0, 16(S8)
476:                     p->size=len;
9D00F718  FC5E0010   LW V0, 16(S8)
9D00F71C  347E0028   LHU V1, 40(S8)
9D00F720      A9A1   SH V1, 2(V0)
477:                     p->ptr=VA_TO_PA(buffer);  //(int)buffer & 0x0FFFFFFF;
9D00F722  FC5E0024   LW V0, 36(S8)
9D00F726  0062F02C   EXT V1, V0, 0, 31
9D00F728  F02CFC5E   JALX 0x98B3F178
9D00F72A  FC5E0010   LW V0, 16(S8)
9D00F72E      E9A1   SW V1, 4(V0)
478:                     p->data=0x80;
9D00F730  FC5E0010   LW V0, 16(S8)
9D00F734  3060FF80   ADDIU V1, ZERO, -128
9D00F736  FF8089A0   LW GP, -30304(ZERO)
9D00F738      89A0   SB V1, 0(V0)
479:                     
480:                     //p=(BD_ITEM*)USB_getBDAddress(ep, DIRECTION_OUT, PPBI_ODD);
481:                     //p->size=len;
482:                     //p->ptr=VA_TO_PA(buffer);  //(int)buffer & 0x0FFFFFFF;
483:                     //p->data=0x80;
484:                     
485:                     /*
486:                     char* bd=USB_getBDAddress(ep, DIRECTION_OUT, PPBI_EVEN);    
487:                     
488:                     short int* bd16=(short int*)bd;
489:                     bd16[1]=len;
490:                 
491:                     //adresa bufferu (physical addr)
492:                     int* bd32=(int*)bd;
493:                     bd32[1]=(int)buffer & 0x0FFFFFFF;  
494:                     
495:                     //b7=1 (UOWN=1 - SIE vlastni buffer), b6=0 DATA0/1 
496:                     bd[0]=0x80;   
497:                     */
498:                 }
9D00F73A      0FBE   MOVE SP, S8
9D00F73C      4BE7   LW RA, 28(SP)
9D00F73E      4BC6   LW S8, 24(SP)
9D00F740      4C11   ADDIU SP, SP, 32
9D00F742      45BF   JRC RA
499:                 
500:                 int usbDevice_isRxProgress(char ep)
501:                 {
9D00F744      4FF1   ADDIU SP, SP, -32
9D00F746      CBE7   SW RA, 28(SP)
9D00F748      CBC6   SW S8, 24(SP)
9D00F74A      0FDD   MOVE S8, SP
9D00F74C      0C44   MOVE V0, A0
9D00F74E  185E0020   SB V0, 32(S8)
502:                     //vraci 1, pokud probiha cteni (jeste nebyl prijat paket)
503:                     //bd[0].b7=1 SIE pracuje, 0=dokonceno CPU vlastni buffer
504:                     
505:                     BD_ITEM* p=(BD_ITEM*)USB_getBDAddress(ep, DIRECTION_OUT, PPBI_EVEN);
9D00F752  145E0020   LBU V0, 32(S8)
9D00F756      0C82   MOVE A0, V0
9D00F758      0CA0   MOVE A1, ZERO
9D00F75A      0CC0   MOVE A2, ZERO
9D00F75C  76807D6A   JALS USB_getBDAddress
9D00F760      0C00   NOP
9D00F762  F85E0010   SW V0, 16(S8)
506:                     return p->data>>7;
9D00F766  FC5E0010   LW V0, 16(S8)
9D00F768  00100920   ADD AT, S0, ZERO
9D00F76A      0920   LBU V0, 0(V0)
9D00F76C      252F   SRL V0, V0, 7
9D00F76E      2D2D   ANDI V0, V0, 0xFF
507:                     
508:                     //char* bd=USB_getBDAddress(ep, DIRECTION_OUT, PPBI_EVEN);
509:                     //return bd[0]>>7;
510:                 }
9D00F770      0FBE   MOVE SP, S8
9D00F772      4BE7   LW RA, 28(SP)
9D00F774      4BC6   LW S8, 24(SP)
9D00F776      4C11   ADDIU SP, SP, 32
9D00F778      45BF   JRC RA
9D00F77A      0C00   NOP
511:                 
512:                 void usbDevice_interrupt()
513:                 {
9D00F77C      4FED   ADDIU SP, SP, -40
9D00F77E      CBE9   SW RA, 36(SP)
9D00F780      CBC8   SW S8, 32(SP)
9D00F782      0FDD   MOVE S8, SP
514:                     //Po prijeti SETUP paketu nastavi SIE PKTDIS=1 - zakaz prijimani dalsich paketu
515:                     U1CONbits.PKTDIS=0;
9D00F784  41A3BF81   LUI V1, 0xBF81
9D00F786  BF811443   LDC1 F28, 5187(AT)
9D00F788  14438650   LBU V0, -31152(V1)
9D00F78A      8650   MOVEP A0, S6, ZERO, S2
9D00F78C  0040294C   INS V0, ZERO, 5, 1
9D00F78E      294C   LHU V0, 24(A0)
9D00F790  18438650   SB V0, -31152(V1)
9D00F792      8650   MOVEP A0, S6, ZERO, S2
516:                     
517:                     if(U1IRbits.URSTIF==1)
9D00F794  41A2BF81   LUI V0, 0xBF81
9D00F796  BF81FC42   LDC1 F28, -958(AT)
9D00F798  FC428600   LW V0, -31232(V0)
9D00F79A      8600   MOVEP A0, S6, ZERO, ZERO
9D00F79C      2D21   ANDI V0, V0, 0x1
9D00F79E  40E2000C   BEQZC V0, 0x9D00F7BA
9D00F7A0  000C7680   OR T6, T4, ZERO
518:                     {
519:                         //reset
520:                         USB_reset();
9D00F7A2  76807D3C   JALS USB_reset
9D00F7A6      0C00   NOP
521:                         U1IRbits.URSTIF=1;
9D00F7A8  41A3BF81   LUI V1, 0xBF81
9D00F7AA  BF811443   LDC1 F28, 5187(AT)
9D00F7AC  14438600   LBU V0, -31232(V1)
9D00F7AE      8600   MOVEP A0, S6, ZERO, ZERO
9D00F7B0      EE01   LI A0, 1
9D00F7B2  0044000C   INS V0, A0, 0, 1
9D00F7B6  18438600   SB V0, -31232(V1)
9D00F7B8      8600   MOVEP A0, S6, ZERO, ZERO
522:                     }
523:                     
524:                     if(U1IRbits.TRNIF==1)
9D00F7BA  41A2BF81   LUI V0, 0xBF81
9D00F7BC  BF81FC42   LDC1 F28, -958(AT)
9D00F7BE  FC428600   LW V0, -31232(V0)
9D00F7C0      8600   MOVEP A0, S6, ZERO, ZERO
9D00F7C2      2D26   ANDI V0, V0, 0x8
9D00F7C4  40E2014A   BEQZC V0, 0x9D00FA5C
525:                     {
526:                         //transaction
527:                         
528:                         //EP
529:                         char ep=U1STATbits.ENDPT;
9D00F7C8  41A2BF81   LUI V0, 0xBF81
9D00F7CA  BF81FC42   LDC1 F28, -958(AT)
9D00F7CC  FC428640   LW V0, -31168(V0)
9D00F7CE      8640   MOVEP A0, S6, ZERO, S0
9D00F7D0  0042192C   EXT V0, V0, 4, 4
9D00F7D2  192C2D2D   SB T1, 11565(T4)
9D00F7D4      2D2D   ANDI V0, V0, 0xFF
9D00F7D6  185E0010   SB V0, 16(S8)
530:                         //PID IN, OUT, SETUP, BDitem.b2-b5
531:                         BD_ITEM* x =(BD_ITEM*)USB_getBDAddress(ep, U1STATbits.DIR, U1STATbits.PPBI); 
9D00F7DA  41A2BF81   LUI V0, 0xBF81
9D00F7DC  BF81FC42   LDC1 F28, -958(AT)
9D00F7DE  FC428640   LW V0, -31168(V0)
9D00F7E0      8640   MOVEP A0, S6, ZERO, S0
9D00F7E2  004200EC   EXT V0, V0, 3, 1
9D00F7E4  00EC2D2D   PRECRQ_RS.PH.W A1, T4, A3
9D00F7E6      2D2D   ANDI V0, V0, 0xFF
9D00F7E8      0C62   MOVE V1, V0
9D00F7EA  41A2BF81   LUI V0, 0xBF81
9D00F7EC  BF81FC42   LDC1 F28, -958(AT)
9D00F7EE  FC428640   LW V0, -31168(V0)
9D00F7F0      8640   MOVEP A0, S6, ZERO, S0
9D00F7F2  004200AC   EXT V0, V0, 2, 1
9D00F7F4  00AC2D2D   PRECRQ_RS.PH.W A1, T4, A1
9D00F7F6      2D2D   ANDI V0, V0, 0xFF
9D00F7F8  149E0010   LBU A0, 16(S8)
9D00F7FC      0CA3   MOVE A1, V1
9D00F7FE      0CC2   MOVE A2, V0
9D00F800  76807D6A   JALS USB_getBDAddress
9D00F804      0C00   NOP
9D00F806  F85E0014   SW V0, 20(S8)
532:                         char pid = x->data >> 2 & 0b1111;
9D00F80A  FC5E0014   LW V0, 20(S8)
9D00F80C  00140920   ADD AT, S4, ZERO
9D00F80E      0920   LBU V0, 0(V0)
9D00F810      2525   SRL V0, V0, 2
9D00F812      2D2D   ANDI V0, V0, 0xFF
9D00F814      2D27   ANDI V0, V0, 0xF
9D00F816  185E0018   SB V0, 24(S8)
533:                         
534:                         U1IRbits.TRNIF=1;
9D00F81A  41A3BF81   LUI V1, 0xBF81
9D00F81C  BF811443   LDC1 F28, 5187(AT)
9D00F81E  14438600   LBU V0, -31232(V1)
9D00F820      8600   MOVEP A0, S6, ZERO, ZERO
9D00F822      EE01   LI A0, 1
9D00F824  004418CC   INS V0, A0, 3, 1
9D00F826  18CC1843   SB A2, 6211(T4)
9D00F828  18438600   SB V0, -31232(V1)
9D00F82A      8600   MOVEP A0, S6, ZERO, ZERO
535:                         
536:                         if(ep==0 && pid==SETUP_TOKEN)
9D00F82C  145E0010   LBU V0, 16(S8)
9D00F830  40A200C7   BNEZC V0, 0x9D00F9C2
9D00F834  147E0018   LBU V1, 24(S8)
9D00F836  0018ED0D   ADDU_S.PH SP, T8, ZERO
9D00F838      ED0D   LI V0, 13
9D00F83A  B44300C2   BNE V1, V0, 0x9D00F9C2
9D00F83C  00C20C00   SLL A2, V0, 1
9D00F83E      0C00   NOP
537:                         {
538:                             
539:                             //prijata data SETUP na EP0
540:                             if(setup_token->bRequest == GET_DESCRIPTOR) //bRequest
9D00F840  FC5C8020   LW V0, -32736(GP)
9D00F844      09A1   LBU V1, 1(V0)
9D00F846      ED06   LI V0, 6
9D00F848  B4430072   BNE V1, V0, 0x9D00F930
9D00F84A  00720C00   SLL V1, S2, 1
9D00F84C      0C00   NOP
541:                             {
542:                                 if(setup_token->bmRequestType.Recipient == DEVICE && setup_token->bValueH == DTYPE_DEVICE) //bmRequestType.Recipient
9D00F84E  FC5C8020   LW V0, -32736(GP)
9D00F852      2920   LHU V0, 0(V0)
9D00F854      2D29   ANDI V0, V0, 0x1F
9D00F856      2D2F   ANDI V0, V0, 0xFFFF
9D00F858  40A20011   BNEZC V0, 0x9D00F87E
9D00F85C  FC5C8020   LW V0, -32736(GP)
9D00F860      09A3   LBU V1, 3(V0)
9D00F862      ED01   LI V0, 1
9D00F864  B443000B   BNE V1, V0, 0x9D00F87E
9D00F866  000B0C00   SLL ZERO, T3, 1
9D00F868      0C00   NOP
543:                                 {
544:                                     //pozaduje device descriptor
545:                                     USB_sendDeviceDescriptor(setup_token->wLenght);
9D00F86A  FC5C8020   LW V0, -32736(GP)
9D00F86E  3C420006   LH V0, 6(V0)
9D00F872      0C82   MOVE A0, V0
9D00F874  76807E12   JALS USB_sendDeviceDescriptor
9D00F878      0C00   NOP
9D00F87A      CC58   B 0x9D00F92C
9D00F87C      0C00   NOP
546:                                 }
547:                 
548:                                 else if(setup_token->bmRequestType.Recipient == DEVICE && setup_token->bValueH == DTYPE_CONFIGURATION)
9D00F87E  FC5C8020   LW V0, -32736(GP)
9D00F882      2920   LHU V0, 0(V0)
9D00F884      2D29   ANDI V0, V0, 0x1F
9D00F886      2D2F   ANDI V0, V0, 0xFFFF
9D00F888  40A20011   BNEZC V0, 0x9D00F8AE
9D00F88C  FC5C8020   LW V0, -32736(GP)
9D00F890      09A3   LBU V1, 3(V0)
9D00F892      ED02   LI V0, 2
9D00F894  B443000B   BNE V1, V0, 0x9D00F8AE
9D00F896  000B0C00   SLL ZERO, T3, 1
9D00F898      0C00   NOP
549:                                 {
550:                                     //pozaduje device configuration
551:                                     USB_sendDeviceConfiguration(setup_token->wLenght);
9D00F89A  FC5C8020   LW V0, -32736(GP)
9D00F89E  3C420006   LH V0, 6(V0)
9D00F8A2      0C82   MOVE A0, V0
9D00F8A4  76807E38   JALS USB_sendDeviceConfiguration
9D00F8A8      0C00   NOP
9D00F8AA      CC40   B 0x9D00F92C
9D00F8AC      0C00   NOP
552:                                 }
553:                 
554:                                 else if(setup_token->bmRequestType.Recipient == DEVICE && setup_token->bValueH == DTYPE_QUALIFIER)
9D00F8AE  FC5C8020   LW V0, -32736(GP)
9D00F8B2      2920   LHU V0, 0(V0)
9D00F8B4      2D29   ANDI V0, V0, 0x1F
9D00F8B6      2D2F   ANDI V0, V0, 0xFFFF
9D00F8B8  40A2000C   BNEZC V0, 0x9D00F8D4
9D00F8BC  FC5C8020   LW V0, -32736(GP)
9D00F8C0      09A3   LBU V1, 3(V0)
9D00F8C2      ED06   LI V0, 6
9D00F8C4  B4430006   BNE V1, V0, 0x9D00F8D4
9D00F8C6  00060C00   SLL ZERO, A2, 1
9D00F8C8      0C00   NOP
555:                                 {
556:                                     //pozaduje device qualifier (pro jinou rychlost)
557:                                     USB_sendSetupNull();
9D00F8CA  76807E98   JALS USB_sendSetupNull
9D00F8CE      0C00   NOP
9D00F8D0      CC2D   B 0x9D00F92C
9D00F8D2      0C00   NOP
558:                                 }
559:                 
560:                                 else if(setup_token->bmRequestType.Recipient == INTERFACE && setup_token->bValueH == DTYPE_REPORT)
9D00F8D4  FC5C8020   LW V0, -32736(GP)
9D00F8D8      2920   LHU V0, 0(V0)
9D00F8DA      2D29   ANDI V0, V0, 0x1F
9D00F8DC      2DAF   ANDI V1, V0, 0xFFFF
9D00F8DE      ED01   LI V0, 1
9D00F8E0  B443000D   BNE V1, V0, 0x9D00F8FE
9D00F8E2  000D0C00   SLL ZERO, T5, 1
9D00F8E4      0C00   NOP
9D00F8E6  FC5C8020   LW V0, -32736(GP)
9D00F8EA      09A3   LBU V1, 3(V0)
9D00F8EC      ED22   LI V0, 34
9D00F8EE  B4430006   BNE V1, V0, 0x9D00F8FE
9D00F8F0  00060C00   SLL ZERO, A2, 1
9D00F8F2      0C00   NOP
561:                                 {
562:                                     //report
563:                                     USB_sendSetupNull();
9D00F8F4  76807E98   JALS USB_sendSetupNull
9D00F8F8      0C00   NOP
9D00F8FA      CC18   B 0x9D00F92C
9D00F8FC      0C00   NOP
564:                                 }
565:                 
566:                                 else if(setup_token->bmRequestType.Recipient == DEVICE && setup_token->bValueH == DTYPE_STRING)
9D00F8FE  FC5C8020   LW V0, -32736(GP)
9D00F902      2920   LHU V0, 0(V0)
9D00F904      2D29   ANDI V0, V0, 0x1F
9D00F906      2D2F   ANDI V0, V0, 0xFFFF
9D00F908  40A20052   BNEZC V0, 0x9D00F9B0
9D00F90C  FC5C8020   LW V0, -32736(GP)
9D00F910      09A3   LBU V1, 3(V0)
9D00F912      ED03   LI V0, 3
9D00F914  B443004C   BNE V1, V0, 0x9D00F9B0
9D00F916  004C0C00   SLL V0, T4, 1
9D00F918      0C00   NOP
567:                                 {
568:                                     //string
569:                                     USB_sendString(setup_token->bValueL);
9D00F91A  FC5C8020   LW V0, -32736(GP)
9D00F91E      0922   LBU V0, 2(V0)
9D00F920      0C82   MOVE A0, V0
9D00F922  76807EA8   JALS USB_sendString
9D00F926      0C00   NOP
9D00F928      CC43   B 0x9D00F9B0
9D00F92A      0C00   NOP
9D00F92C      CC41   B 0x9D00F9B0
9D00F92E      0C00   NOP
570:                                 }
571:                             }
572:                 
573:                             else if(setup_token->bRequest == SET_ADDRESS)
9D00F930  FC5C8020   LW V0, -32736(GP)
9D00F934      09A1   LBU V1, 1(V0)
9D00F936      ED05   LI V0, 5
9D00F938  B443000B   BNE V1, V0, 0x9D00F952
9D00F93A  000B0C00   SLL ZERO, T3, 1
9D00F93C      0C00   NOP
574:                             {
575:                                 //set address, odeslat potvrzeni, null paket
576:                                 address=setup_token->bValueL; // bufferOut0[2];
9D00F93E  FC5C8020   LW V0, -32736(GP)
9D00F942      0922   LBU V0, 2(V0)
9D00F944  185C805C   SB V0, -32676(GP)
577:                                 USB_sendSetupNull();
9D00F948  76807E98   JALS USB_sendSetupNull
9D00F94C      0C00   NOP
9D00F94E      CC30   B 0x9D00F9B0
9D00F950      0C00   NOP
578:                             }
579:                 
580:                             else if(setup_token->bRequest == SET_CONFIGURATION)
9D00F952  FC5C8020   LW V0, -32736(GP)
9D00F956      09A1   LBU V1, 1(V0)
9D00F958      ED09   LI V0, 9
9D00F95A  B4430006   BNE V1, V0, 0x9D00F96A
9D00F95C  00060C00   SLL ZERO, A2, 1
9D00F95E      0C00   NOP
581:                             {
582:                                 USB_sendSetupNull();
9D00F960  76807E98   JALS USB_sendSetupNull
9D00F964      0C00   NOP
9D00F966      CC24   B 0x9D00F9B0
9D00F968      0C00   NOP
583:                             }
584:                 
585:                             else if(setup_token->bRequest == GET_CONFIGURATION)
9D00F96A  FC5C8020   LW V0, -32736(GP)
9D00F96E      09A1   LBU V1, 1(V0)
9D00F970      ED08   LI V0, 8
9D00F972  B4430006   BNE V1, V0, 0x9D00F982
9D00F974  00060C00   SLL ZERO, A2, 1
9D00F976      0C00   NOP
586:                             {
587:                                 USB_sendSetupNull();
9D00F978  76807E98   JALS USB_sendSetupNull
9D00F97C      0C00   NOP
9D00F97E      CC18   B 0x9D00F9B0
9D00F980      0C00   NOP
588:                             }
589:                 
590:                             else if(setup_token->bRequest == SET_IDLE)
9D00F982  FC5C8020   LW V0, -32736(GP)
9D00F986      09A1   LBU V1, 1(V0)
9D00F988      ED0A   LI V0, 10
9D00F98A  B4430006   BNE V1, V0, 0x9D00F99A
9D00F98C  00060C00   SLL ZERO, A2, 1
9D00F98E      0C00   NOP
591:                             {
592:                                 USB_sendSetupNull();
9D00F990  76807E98   JALS USB_sendSetupNull
9D00F994      0C00   NOP
9D00F996      CC0C   B 0x9D00F9B0
9D00F998      0C00   NOP
593:                             }
594:                 
595:                             else if(setup_token->bRequest == GET_STATUS)
9D00F99A  FC5C8020   LW V0, -32736(GP)
9D00F99E      0921   LBU V0, 1(V0)
9D00F9A0  40A20006   BNEZC V0, 0x9D00F9B0
9D00F9A2  00067680   OR T6, A2, ZERO
596:                             {
597:                                 //GET_STATUS
598:                                 USB_sendDeviceStatus();
9D00F9A4  76807E82   JALS USB_sendDeviceStatus
9D00F9A8      0C00   NOP
599:                                 is_connected=1;
9D00F9AA      ED01   LI V0, 1
9D00F9AC  185C8064   SB V0, -32668(GP)
600:                             }
601:                             
602:                             else 
603:                             {
604:                 
605:                             }
606:                 
607:                             //pripravit na dalsi data na EP0
608:                             //U1CONbits.PPBRST=1;
609:                             USB_prepareBDForOut(0, 0, 0, 8);
9D00F9B0      0C80   MOVE A0, ZERO
9D00F9B2      0CA0   MOVE A1, ZERO
9D00F9B4      0CC0   MOVE A2, ZERO
9D00F9B6      EF88   LI A3, 8
9D00F9B8  76807DDE   JALS USB_prepareBDForOut
9D00F9BC      0C00   NOP
9D00F9BE      CC4E   B 0x9D00FA5C
9D00F9C0      0C00   NOP
610:                 
611:                         } //END SETUP  
612:                         
613:                         //OUT TOKEN na EP0
614:                         else if(ep==0 && pid==OUT_TOKEN)
9D00F9C2  145E0010   LBU V0, 16(S8)
9D00F9C6  40A2000F   BNEZC V0, 0x9D00F9E8
9D00F9CA  147E0018   LBU V1, 24(S8)
9D00F9CE      ED01   LI V0, 1
9D00F9D0  B443000A   BNE V1, V0, 0x9D00F9E8
9D00F9D2  000A0C00   SLL ZERO, T2, 1
9D00F9D4      0C00   NOP
615:                         {
616:                             //out data na EP0, napr. potvrzeni prijeti dat - (NULL) paket, pripravit na dalsi data na EP0
617:                             //U1CONbits.PPBRST=1;
618:                             USB_prepareBDForOut(0, 0, 0, 8);
9D00F9D6      0C80   MOVE A0, ZERO
9D00F9D8      0CA0   MOVE A1, ZERO
9D00F9DA      0CC0   MOVE A2, ZERO
9D00F9DC      EF88   LI A3, 8
9D00F9DE  76807DDE   JALS USB_prepareBDForOut
9D00F9E2      0C00   NOP
9D00F9E4      CC3B   B 0x9D00FA5C
9D00F9E6      0C00   NOP
619:                         }
620:                 
621:                         //IN TOKEN na EP0
622:                         else if(ep==0 && pid==IN_TOKEN)
9D00F9E8  145E0010   LBU V0, 16(S8)
9D00F9EC  40A20030   BNEZC V0, 0x9D00FA50
9D00F9F0  147E0018   LBU V1, 24(S8)
9D00F9F4      ED09   LI V0, 9
9D00F9F6  B443002B   BNE V1, V0, 0x9D00FA50
9D00F9F8  002B0C00   SLL AT, T3, 1
9D00F9FA      0C00   NOP
623:                         {
624:                             if(isize>0)
9D00F9FC  145C805D   LBU V0, -32675(GP)
9D00FA00  40E20015   BEQZC V0, 0x9D00FA2E
9D00FA48      CC09   B 0x9D00FA5C
9D00FA4A      0C00   NOP
9D00FA4C      CC07   B 0x9D00FA5C
9D00FA4E      0C00   NOP
625:                             {
626:                                 //druhy paket predchoziho vysilani
627:                                 //U1CONbits.PPBRST=1;                             //nastav EVEN BD
628:                                 bd_ep0_in_even->ptr=ibuff;
9D00FA04  FC5C80A0   LW V0, -32608(GP)
9D00FA08  FC7C8060   LW V1, -32672(GP)
9D00FA0C      E9A1   SW V1, 4(V0)
629:                                 bd_ep0_in_even->size=isize;
9D00FA0E  FC5C80A0   LW V0, -32608(GP)
9D00FA12  147C805D   LBU V1, -32675(GP)
9D00FA16  00633B3C   SEH V1, V1
9D00FA18  3B3CA9A1   SH T9, -22111(GP)
9D00FA1A      A9A1   SH V1, 2(V0)
630:                                 bd_ep0_in_even->data =  0b10000000;             //SIE, DATA0
9D00FA1C  FC5C80A0   LW V0, -32608(GP)
9D00FA20  3060FF80   ADDIU V1, ZERO, -128
9D00FA22  FF8089A0   LW GP, -30304(ZERO)
9D00FA24      89A0   SB V1, 0(V0)
631:                                 
632:                                 isize=0;                                        //neni dalsi paket
9D00FA26  181C805D   SB ZERO, -32675(GP)
9D00FA2A      CC10   B 0x9D00FA4C
9D00FA2C      0C00   NOP
633:                             }
634:                             else
635:                             {
636:                                 if(address!=0)
9D00FA2E  145C805C   LBU V0, -32676(GP)
9D00FA32  40E2000B   BEQZC V0, 0x9D00FA4C
637:                                 {
638:                                     //bylo odeslano potvrzeni (NULL) - prijeti adresy
639:                                     //nyni zacne probihat kom. na pridelene adrese
640:                                     U1ADDR = address;
9D00FA36  145C805C   LBU V0, -32676(GP)
9D00FA3A      0C62   MOVE V1, V0
9D00FA3C  41A2BF81   LUI V0, 0xBF81
9D00FA3E  BF81F862   LDC1 F28, -1950(AT)
9D00FA40  F8628660   SW V1, -31136(V0)
9D00FA42      8660   MOVEP A0, S6, ZERO, S3
641:                                     address = 0;
9D00FA44  181C805C   SB ZERO, -32676(GP)
642:                                 }
643:                             }
644:                         }
645:                         
646:                         else if(ep != 0)
9D00FA50  145E0010   LBU V0, 16(S8)
9D00FA54  40E20002   BEQZC V0, 0x9D00FA5C
647:                         {
648:                             int a=0;
9D00FA58  F81E001C   SW ZERO, 28(S8)
649:                         }
650:                     }
651:                     
652:                     IFS0bits.USBIF = 0;         //USBIF
9D00FA5C  41A3BF81   LUI V1, 0xBF81
9D00FA5E  BF81FC43   LDC1 F28, -957(AT)
9D00FA60  FC43F040   LW V0, -4032(V1)
9D00FA62  F0400040   JALX 0x99000100
9D00FA64  0040EF4C   INS V0, ZERO, 29, 1
9D00FA66      EF4C   LI A2, 76
9D00FA68  F843F040   SW V0, -4032(V1)
9D00FA6A  F0400FBE   JALX 0x99003EF8
653:                 }
9D00FA6C      0FBE   MOVE SP, S8
9D00FA6E      4BE9   LW RA, 36(SP)
9D00FA70      4BC8   LW S8, 32(SP)
9D00FA72      4C15   ADDIU SP, SP, 40
9D00FA74      45BF   JRC RA
9D00FA76      0C00   NOP
654:                 
655:                 //local fce
656:                 static void USB_reset()
657:                 {
9D00FA78      4FF1   ADDIU SP, SP, -32
9D00FA7A      CBE7   SW RA, 28(SP)
9D00FA7C      CBC6   SW S8, 24(SP)
9D00FA7E      0FDD   MOVE S8, SP
658:                     U1ADDR = 0;
9D00FA80  41A2BF81   LUI V0, 0xBF81
9D00FA82  BF81F802   LDC1 F28, -2046(AT)
9D00FA84  F8028660   SW ZERO, -31136(V0)
9D00FA86      8660   MOVEP A0, S6, ZERO, S3
659:                     address=0;
9D00FA88  181C805C   SB ZERO, -32676(GP)
660:                     
661:                     //IN BD EVEN, ODD
662:                     bd_ep0_in_even=(BD_ITEM*)USB_getBDAddress(0, DIRECTION_IN, PPBI_EVEN);
9D00FA8C      0C80   MOVE A0, ZERO
9D00FA8E      EE81   LI A1, 1
9D00FA90      0CC0   MOVE A2, ZERO
9D00FA92  76807D6A   JALS USB_getBDAddress
9D00FA96      0C00   NOP
9D00FA98  F85C80A0   SW V0, -32608(GP)
663:                     //bd_ep0_in_odd=(BD_ITEM*)USB_getBDAddress(0, DIRECTION_IN, PPBI_ODD);
664:                     
665:                     //OUT BD EVEN
666:                     BD_ITEM* x =(BD_ITEM*)USB_getBDAddress(0, DIRECTION_OUT, PPBI_EVEN);
9D00FA9C      0C80   MOVE A0, ZERO
9D00FA9E      0CA0   MOVE A1, ZERO
9D00FAA0      0CC0   MOVE A2, ZERO
9D00FAA2  76807D6A   JALS USB_getBDAddress
9D00FAA6      0C00   NOP
9D00FAA8  F85E0010   SW V0, 16(S8)
667:                     x->ptr=VA_TO_PA(bufferOut0);
9D00FAAC  305C80A4   ADDIU V0, GP, -32604
9D00FAB0  0062F02C   EXT V1, V0, 0, 31
9D00FAB2  F02CFC5E   JALX 0x98B3F178
9D00FAB4  FC5E0010   LW V0, 16(S8)
9D00FAB8      E9A1   SW V1, 4(V0)
668:                     
669:                     //OUT BD ODD (pouziva pouze EVEN buffer)
670:                     //x =(BD_ITEM*)USB_getBDAddress(0, DIRECTION_OUT, PPBI_ODD);
671:                     //x->ptr=VA_TO_PA(bufferOut0);  
672:                    
673:                     //pripravit na data EP0
674:                     //U1CONbits.PPBRST=1;
675:                     USB_prepareBDForOut(0, 0, 0, 8);
9D00FABA      0C80   MOVE A0, ZERO
9D00FABC      0CA0   MOVE A1, ZERO
9D00FABE      0CC0   MOVE A2, ZERO
9D00FAC0      EF88   LI A3, 8
9D00FAC2  76807DDE   JALS USB_prepareBDForOut
9D00FAC6      0C00   NOP
676:                 }
9D00FAC8      0FBE   MOVE SP, S8
9D00FACA      4BE7   LW RA, 28(SP)
9D00FACC      4BC6   LW S8, 24(SP)
9D00FACE      4C11   ADDIU SP, SP, 32
9D00FAD0      45BF   JRC RA
9D00FAD2      0C00   NOP
677:                 
678:                 static char* USB_getBDAddress(char ep, char dir, char ppbi)
679:                 {
9D00FAD4      4FF9   ADDIU SP, SP, -16
9D00FAD6      CBC3   SW S8, 12(SP)
9D00FAD8      0FDD   MOVE S8, SP
9D00FADA      0C65   MOVE V1, A1
9D00FADC      0C46   MOVE V0, A2
9D00FADE  189E0010   SB A0, 16(S8)
9D00FAE2  187E0014   SB V1, 20(S8)
9D00FAE6  185E0018   SB V0, 24(S8)
680:                     //dir  1=OUT/SETUP, 0=IN
681:                     //ppbi 0=data0/EVEN, 1=data1/ODD
682:                     
683:                     int x=(int)bd_table;
9D00FAEA  41A28000   LUI V0, 0x8000
9D00FAEE  30420600   ADDIU V0, V0, 1536
9D00FAF0      0600   ADDU A0, S0, S0
9D00FAF2  F85E0000   SW V0, 0(S8)
684:                     return (char*)(x | ep<<5 | dir<<4 | ppbi<<3);
9D00FAF6  145E0010   LBU V0, 16(S8)
9D00FAFA      25AA   SLL V1, V0, 5
9D00FAFC  FC5E0000   LW V0, 0(S8)
9D00FB00      44DA   OR16 V1, V0
9D00FB02  145E0014   LBU V0, 20(S8)
9D00FB04  00142528   LWXS A0, ZERO(S4)
9D00FB06      2528   SLL V0, V0, 4
9D00FB08      44DA   OR16 V1, V0
9D00FB0A  145E0018   LBU V0, 24(S8)
9D00FB0E      2526   SLL V0, V0, 3
9D00FB10      44D3   OR16 V0, V1
685:                 }
9D00FB12      0FBE   MOVE SP, S8
9D00FB14      4BC3   LW S8, 12(SP)
9D00FB16      4C09   ADDIU SP, SP, 16
9D00FB18      45BF   JRC RA
9D00FB1A      0C00   NOP
686:                 
687:                 static char* USB_getBuffer(char ep, char dir, char ppbi)
688:                 {
9D00FB1C      4FF1   ADDIU SP, SP, -32
9D00FB1E      CBE7   SW RA, 28(SP)
9D00FB20      CBC6   SW S8, 24(SP)
9D00FB22      0FDD   MOVE S8, SP
9D00FB24      0C65   MOVE V1, A1
9D00FB26      0C46   MOVE V0, A2
9D00FB28  189E0020   SB A0, 32(S8)
9D00FB2C  187E0024   SB V1, 36(S8)
9D00FB30  185E0028   SB V0, 40(S8)
689:                     //vraci fyzickou adresu bufferu z BufferDescriptoru
690:                     //BD word[1]=adresa bufferu
691:                     int* bd_item=(int*)USB_getBDAddress(ep, dir, ppbi);
9D00FB34  149E0020   LBU A0, 32(S8)
9D00FB38  147E0024   LBU V1, 36(S8)
9D00FB3C  145E0028   LBU V0, 40(S8)
9D00FB40      0CA3   MOVE A1, V1
9D00FB42      0CC2   MOVE A2, V0
9D00FB44  76807D6A   JALS USB_getBDAddress
9D00FB48      0C00   NOP
9D00FB4A  F85E0010   SW V0, 16(S8)
692:                     return (char*)bd_item[1];                  //prevod phys. na virt.
9D00FB4E  FC5E0010   LW V0, 16(S8)
9D00FB52      6D22   ADDIU V0, V0, 4
9D00FB54      6920   LW V0, 0(V0)
693:                     
694:                 }
9D00FB56      0FBE   MOVE SP, S8
9D00FB58      4BE7   LW RA, 28(SP)
9D00FB5A      4BC6   LW S8, 24(SP)
9D00FB5C      4C11   ADDIU SP, SP, 32
9D00FB5E      45BF   JRC RA
695:                 
696:                 static void USB_setBD(char* bd, char b0, int size, char* buffer_addr)
697:                 {
9D00FB60      4FF9   ADDIU SP, SP, -16
9D00FB62      CBC3   SW S8, 12(SP)
9D00FB64      0FDD   MOVE S8, SP
9D00FB66  F89E0010   SW A0, 16(S8)
9D00FB68  00100C45   CMP.LT.PH S0, ZERO
9D00FB6A      0C45   MOVE V0, A1
9D00FB6C  F8DE0018   SW A2, 24(S8)
9D00FB70  F8FE001C   SW A3, 28(S8)
9D00FB74  185E0014   SB V0, 20(S8)
698:                     //BD 8 bytes
699:                     //B0=b0
700:                     //B2-3 = size
701:                     //B4-7 = buffer adresa
702:                     
703:                     bd[0]=b0;
9D00FB78  FC5E0010   LW V0, 16(S8)
9D00FB7C  147E0014   LBU V1, 20(S8)
9D00FB7E  001489A0   SUB S1, S4, ZERO
9D00FB80      89A0   SB V1, 0(V0)
704:                     
705:                     short int* bd16=(short int*)bd;
9D00FB82  FC5E0010   LW V0, 16(S8)
9D00FB86  F85E0000   SW V0, 0(S8)
706:                     bd16[1]=size;
9D00FB8A  FC5E0000   LW V0, 0(S8)
9D00FB8E      4C44   ADDIU V0, V0, 2
9D00FB90  FC7E0018   LW V1, 24(S8)
9D00FB94  00633B3C   SEH V1, V1
9D00FB96  3B3CA9A0   SH T9, -22112(GP)
9D00FB98      A9A0   SH V1, 0(V0)
707:                     
708:                     int* bd32=(int*)bd;
9D00FB9A  FC5E0010   LW V0, 16(S8)
9D00FB9E  F85E0004   SW V0, 4(S8)
709:                     bd32[1]=(int)buffer_addr & 0x0FFFFFFF;
9D00FBA2  FC5E0004   LW V0, 4(S8)
9D00FBA6      6D22   ADDIU V0, V0, 4
9D00FBA8  FC7E001C   LW V1, 28(S8)
9D00FBAC  0063D82C   EXT V1, V1, 0, 28
9D00FBB0      E9A0   SW V1, 0(V0)
710:                 }
9D00FBB2      0FBE   MOVE SP, S8
9D00FBB4      4BC3   LW S8, 12(SP)
9D00FBB6      4C09   ADDIU SP, SP, 16
9D00FBB8      45BF   JRC RA
9D00FBBA      0C00   NOP
711:                 
712:                 static void USB_prepareBDForOut(char ep, char ppbi, char data01, short int len)
713:                 {
9D00FBBC      4FF1   ADDIU SP, SP, -32
9D00FBBE      CBE7   SW RA, 28(SP)
9D00FBC0      CBC6   SW S8, 24(SP)
9D00FBC2      0FDD   MOVE S8, SP
9D00FBC4      0D04   MOVE T0, A0
9D00FBC6      0C85   MOVE A0, A1
9D00FBC8      0C66   MOVE V1, A2
9D00FBCA      0C47   MOVE V0, A3
9D00FBCC  191E0020   SB T0, 32(S8)
9D00FBD0  189E0024   SB A0, 36(S8)
9D00FBD4  187E0028   SB V1, 40(S8)
9D00FBD8  385E002C   SH V0, 44(S8)
714:                     //pripravi BD item pro prijem dat
715:                     //BDT item =
716:                     //8 bitu data,
717:                     //8 bitu nic,
718:                     //8 bitu len,
719:                     //8 bitu len(2bity),
720:                     //32 bitu adresa bufferu
721:                 
722:                     //ppbi=0;
723:                     
724:                     /*
725:                     char* bd=USB_getBDAddress(ep, DIRECTION_OUT, ppbi);  //DIRECTION_IN
726:                     short int* bd16=(short int*)bd;
727:                     bd16[1]=len;
728:                 
729:                     //b7=1 (UOWN=SIE), b6=toggle
730:                     bd[0]=0x80 | (data01 << 6);
731:                     */
732:                     
733:                     BD_ITEM* x =(BD_ITEM*)USB_getBDAddress(ep, DIRECTION_OUT, ppbi);
9D00FBDC  147E0020   LBU V1, 32(S8)
9D00FBE0  145E0024   LBU V0, 36(S8)
9D00FBE4      0C83   MOVE A0, V1
9D00FBE6      0CA0   MOVE A1, ZERO
9D00FBE8      0CC2   MOVE A2, V0
9D00FBEA  76807D6A   JALS USB_getBDAddress
9D00FBEE      0C00   NOP
9D00FBF0  F85E0010   SW V0, 16(S8)
734:                     x->size=len;
9D00FBF4  FC5E0010   LW V0, 16(S8)
9D00FBF8  347E002C   LHU V1, 44(S8)
9D00FBFC      A9A1   SH V1, 2(V0)
735:                     x->data=0x80 | (data01 << 6);
9D00FBFE  145E0028   LBU V0, 40(S8)
9D00FC00  0028252C   EXT AT, T0, 20, 5
9D00FC02      252C   SLL V0, V0, 6
9D00FC04  00622B3C   SEB V1, V0
9D00FC06      2B3C   LHU A2, 24(V1)
9D00FC08  3040FF80   ADDIU V0, ZERO, -128
9D00FC0A  FF8044D3   LW GP, 17619(ZERO)
9D00FC0C      44D3   OR16 V0, V1
9D00FC0E  00422B3C   SEB V0, V0
9D00FC10      2B3C   LHU A2, 24(V1)
9D00FC12      2DAD   ANDI V1, V0, 0xFF
9D00FC14  FC5E0010   LW V0, 16(S8)
9D00FC16  001089A0   SUB S1, S0, ZERO
9D00FC18      89A0   SB V1, 0(V0)
736:                     
737:                 }
9D00FC1A      0FBE   MOVE SP, S8
9D00FC1C      4BE7   LW RA, 28(SP)
9D00FC1E      4BC6   LW S8, 24(SP)
9D00FC20      4C11   ADDIU SP, SP, 32
9D00FC22      45BF   JRC RA
738:                 
739:                 static void USB_sendDeviceDescriptor(short int len)
740:                 {
9D00FC24      4FB0   ADDIU SP, SP, -8
9D00FC26      CBC1   SW S8, 4(SP)
9D00FC28      0FDD   MOVE S8, SP
9D00FC2A      0C44   MOVE V0, A0
9D00FC2C  385E0008   SH V0, 8(S8)
741:                     if(len>18){len=18;}
9D00FC30  3C5E0008   LH V0, 8(S8)
9D00FC34  90420013   SLTI V0, V0, 19
9D00FC38  40A20003   BNEZC V0, 0x9D00FC42
9D00FC3C      ED12   LI V0, 18
9D00FC3E  385E0008   SH V0, 8(S8)
742:                     //U1CONbits.PPBRST=1;
743:                     
744:                     bd_ep0_in_even->ptr=VA_TO_PA(dd);
9D00FC42  FC5C80A0   LW V0, -32608(GP)
9D00FC46  41A39D00   LUI V1, 0x9D00
9D00FC48  9D003063   LWC1 F8, 12387(ZERO)
9D00FC4A  306301BC   ADDIU V1, V1, 444
9D00FC4E  0063F02C   EXT V1, V1, 0, 31
9D00FC50  F02CE9A1   JALX 0x98B3A684
9D00FC52      E9A1   SW V1, 4(V0)
745:                     bd_ep0_in_even->size=len;
9D00FC54  FC5C80A0   LW V0, -32608(GP)
9D00FC58  347E0008   LHU V1, 8(S8)
9D00FC5C      A9A1   SH V1, 2(V0)
746:                     bd_ep0_in_even->data=0b11000000;
9D00FC5E  FC5C80A0   LW V0, -32608(GP)
9D00FC62  3060FFC0   ADDIU V1, ZERO, -64
9D00FC64  FFC089A0   LW S8, -30304(ZERO)
9D00FC66      89A0   SB V1, 0(V0)
747:                     
748:                     /*
749:                     char* bd0=USB_getBDAddress(0, DIRECTION_IN, 0);  //DIRECTION_IN
750:                     short int* bd016=(short int*)bd0;
751:                     int* bd032=(int*)bd0;
752:                     
753:                     int b0=(int)dd & 0x00FFFFFF | 0x1D000000;
754:                     bd032[1]=b0; 
755:                     
756:                     U1CONbits.PPBRST=1;
757:                     if(len>18){len=18;}
758:                     
759:                     bd016[1]= len;
760:                     bd0[0]=0b11000000;
761:                     */
762:                     
763:                     /*
764:                     bufferIn0[0] = 18;      //delka
765:                     bufferIn0[1] = 0x01;	//Device Descriptor
766:                     bufferIn0[2] = 0x00;    //verze 2.0
767:                     bufferIn0[3] = 0x02;	//verze 2.0
768:                     bufferIn0[4] = 0x00;	//class
769:                     bufferIn0[5] = 0x00;	//sub class
770:                     bufferIn0[6] = 0x00;	//protocol
771:                     bufferIn0[7] = 64;      //buffer size
772:                     
773:                     if(len > 8)    
774:                     {
775:                         bufferIn0[8] = 0x05;	//vendor id
776:                         bufferIn0[9] = 0x00;	//vendor id
777:                         bufferIn0[10] = 0x07;	//product id 05
778:                         bufferIn0[11] = 0x00;   //product id
779:                         bufferIn0[12] = 0x40;	//device release 04
780:                         bufferIn0[13] = 0x07;	//device release 03
781:                         bufferIn0[14] = 0x01;	//Manufact. string index
782:                         bufferIn0[15] = 0x02;	//Product string index
783:                         bufferIn0[16] = 0x00;	//serial Num. string index
784:                         bufferIn0[17] = 0x01;	//Number of configurations
785:                         len=18;
786:                     }
787:                 
788:                     //oba BD ukazuji na bufferIn0
789:                     U1CONbits.PPBRST=1;
790:                     //USB_prepareBDForIn(0, 0, 1, len);   //EVEN
791:                     USB_prepareBDForIn(0, 1, 1, len);   //ODD
792:                     */
793:                 
794:                 }
9D00FC68      0FBE   MOVE SP, S8
9D00FC6A      4BC1   LW S8, 4(SP)
9D00FC6C      4C05   ADDIU SP, SP, 8
9D00FC6E      45BF   JRC RA
795:                 
796:                 static void USB_sendDeviceConfiguration(unsigned int len)
797:                 {
9D00FC70      4FB0   ADDIU SP, SP, -8
9D00FC72      CBC1   SW S8, 4(SP)
9D00FC74      0FDD   MOVE S8, SP
9D00FC76  F89E0008   SW A0, 8(S8)
798:                     //len = pozadovana velikost (odesila tento pocet, nebo mensi)
799:                     //char slen=0;        //skutecna velikost
800:                     
801:                     if(len==0xFF){len=9;}
9D00FC7A  FC7E0008   LW V1, 8(S8)
9D00FC7C  00083040   SRL ZERO, T0, 6
9D00FC7E  304000FF   ADDIU V0, ZERO, 255
9D00FC82  B4430004   BNE V1, V0, 0x9D00FC8E
9D00FC84  00040C00   SLL ZERO, A0, 1
9D00FC86      0C00   NOP
9D00FC88      ED09   LI V0, 9
9D00FC8A  F85E0008   SW V0, 8(S8)
802:                     
803:                     //U1CONbits.PPBRST=1;                         //nastav EVEN BD
804:                     bd_ep0_in_even->ptr=VA_TO_PA(cd);
9D00FC8E  FC5C80A0   LW V0, -32608(GP)
9D00FC92  41A39D00   LUI V1, 0x9D00
9D00FC94  9D003063   LWC1 F8, 12387(ZERO)
9D00FC96  3063018C   ADDIU V1, V1, 396
9D00FC9A  0063F02C   EXT V1, V1, 0, 31
9D00FC9C  F02CE9A1   JALX 0x98B3A684
9D00FC9E      E9A1   SW V1, 4(V0)
805:                     
806:                     if(len>64)
9D00FCA0  FC5E0008   LW V0, 8(S8)
9D00FCA4  B0420041   SLTIU V0, V0, 65
9D00FCA8  40A2001A   BNEZC V0, 0x9D00FCE0
807:                     {
808:                         bd_ep0_in_even->size=64;
9D00FCAC  FC5C80A0   LW V0, -32608(GP)
9D00FCB0      EDC0   LI V1, 64
9D00FCB2      A9A1   SH V1, 2(V0)
809:                         bd_ep0_in_even->data =  0b11000000;     //SIE, DATA1
9D00FCB4  FC5C80A0   LW V0, -32608(GP)
9D00FCB8  3060FFC0   ADDIU V1, ZERO, -64
9D00FCBA  FFC089A0   LW S8, -30304(ZERO)
9D00FCBC      89A0   SB V1, 0(V0)
810:                 
811:                         //priprava pro dalsi paket
812:                         isize=len-64;
9D00FCBE  FC5E0008   LW V0, 8(S8)
9D00FCC0  00082D2D   PRECRQ_RS.PH.W A1, T0, ZERO
9D00FCC2      2D2D   ANDI V0, V0, 0xFF
9D00FCC4  3042FFC0   ADDIU V0, V0, -64
9D00FCC6  FFC02D2D   LW S8, 11565(ZERO)
9D00FCC8      2D2D   ANDI V0, V0, 0xFF
9D00FCCA  185C805D   SB V0, -32675(GP)
813:                         ibuff=bd_ep0_in_even->ptr+64;
9D00FCCE  FC5C80A0   LW V0, -32608(GP)
9D00FCD2      6921   LW V0, 4(V0)
9D00FCD4  30420040   ADDIU V0, V0, 64
9D00FCD8  F85C8060   SW V0, -32672(GP)
9D00FCDC      CC0F   B 0x9D00FCFC
9D00FCDE      0C00   NOP
814:                     }
815:                     else
816:                     {
817:                         bd_ep0_in_even->size = len;
9D00FCE0  FC5C80A0   LW V0, -32608(GP)
9D00FCE4  FC7E0008   LW V1, 8(S8)
9D00FCE8  00633B3C   SEH V1, V1
9D00FCEA  3B3CA9A1   SH T9, -22111(GP)
9D00FCEC      A9A1   SH V1, 2(V0)
818:                         bd_ep0_in_even->data =  0b11000000;     //SIE, DATA1
9D00FCEE  FC5C80A0   LW V0, -32608(GP)
9D00FCF2  3060FFC0   ADDIU V1, ZERO, -64
9D00FCF4  FFC089A0   LW S8, -30304(ZERO)
9D00FCF6      89A0   SB V1, 0(V0)
819:                         isize=0;                                //neni dalsi paket
9D00FCF8  181C805D   SB ZERO, -32675(GP)
820:                     }
821:                 }
9D00FCFC      0FBE   MOVE SP, S8
9D00FCFE      4BC1   LW S8, 4(SP)
9D00FD00      4C05   ADDIU SP, SP, 8
9D00FD02      45BF   JRC RA
822:                 
823:                 static void USB_sendDeviceStatus()
824:                 {
9D00FD04      4FB0   ADDIU SP, SP, -8
9D00FD06      CBC1   SW S8, 4(SP)
9D00FD08      0FDD   MOVE S8, SP
825:                     bd_ep0_in_even->ptr=VA_TO_PA(sd);
9D00FD0A  FC5C80A0   LW V0, -32608(GP)
9D00FD0E      0C60   MOVE V1, ZERO
9D00FD10  0063F02C   EXT V1, V1, 0, 31
9D00FD12  F02CE9A1   JALX 0x98B3A684
9D00FD14      E9A1   SW V1, 4(V0)
826:                     bd_ep0_in_even->size=2;
9D00FD16  FC5C80A0   LW V0, -32608(GP)
9D00FD1A      ED82   LI V1, 2
9D00FD1C      A9A1   SH V1, 2(V0)
827:                     bd_ep0_in_even->data=0b11000000;    
9D00FD1E  FC5C80A0   LW V0, -32608(GP)
9D00FD22  3060FFC0   ADDIU V1, ZERO, -64
9D00FD24  FFC089A0   LW S8, -30304(ZERO)
9D00FD26      89A0   SB V1, 0(V0)
828:                 }
9D00FD28      0FBE   MOVE SP, S8
9D00FD2A      4BC1   LW S8, 4(SP)
9D00FD2C      4C05   ADDIU SP, SP, 8
9D00FD2E      45BF   JRC RA
829:                 
830:                 static void USB_sendSetupNull()
831:                 {
9D00FD30      4FB0   ADDIU SP, SP, -8
9D00FD32      CBC1   SW S8, 4(SP)
9D00FD34      0FDD   MOVE S8, SP
832:                     //odeslani NULL na EP0, EVEN, data1
833:                     //U1CONbits.PPBRST=1;
834:                     bd_ep0_in_even->size=0;
9D00FD36  FC5C80A0   LW V0, -32608(GP)
9D00FD3A      A821   SH S0, 2(V0)
835:                     bd_ep0_in_even->data=0b11000000;
9D00FD3C  FC5C80A0   LW V0, -32608(GP)
9D00FD40  3060FFC0   ADDIU V1, ZERO, -64
9D00FD42  FFC089A0   LW S8, -30304(ZERO)
9D00FD44      89A0   SB V1, 0(V0)
836:                 }
9D00FD46      0FBE   MOVE SP, S8
9D00FD48      4BC1   LW S8, 4(SP)
9D00FD4A      4C05   ADDIU SP, SP, 8
9D00FD4C      45BF   JRC RA
9D00FD4E      0C00   NOP
837:                 
838:                 static void USB_sendString(const unsigned char index)
839:                 {
9D00FD50      4FB0   ADDIU SP, SP, -8
9D00FD52      CBC1   SW S8, 4(SP)
9D00FD54      0FDD   MOVE S8, SP
9D00FD56      0C44   MOVE V0, A0
9D00FD58  185E0008   SB V0, 8(S8)
840:                     //U1CONbits.PPBRST=1;
841:                     
842:                 	if(index==0)
9D00FD5C  145E0008   LBU V0, 8(S8)
9D00FD60  40A20016   BNEZC V0, 0x9D00FD90
843:                 	{
844:                 		//USB_fillString((char*)&strZero);
845:                         bd_ep0_in_even->ptr=VA_TO_PA(strZero);
9D00FD64  FC5C80A0   LW V0, -32608(GP)
9D00FD68  41A39D00   LUI V1, 0x9D00
9D00FD6A  9D003063   LWC1 F8, 12387(ZERO)
9D00FD6C  306301F0   ADDIU V1, V1, 496
9D00FD70  0063F02C   EXT V1, V1, 0, 31
9D00FD72  F02CE9A1   JALX 0x98B3A684
9D00FD74      E9A1   SW V1, 4(V0)
846:                         bd_ep0_in_even->size=strZero[0];
9D00FD76  FC5C80A0   LW V0, -32608(GP)
9D00FD7A      ED85   LI V1, 5
9D00FD7C  00633B3C   SEH V1, V1
9D00FD7E  3B3CA9A1   SH T9, -22111(GP)
9D00FD80      A9A1   SH V1, 2(V0)
847:                         bd_ep0_in_even->data=0b11000000;
9D00FD82  FC5C80A0   LW V0, -32608(GP)
9D00FD86  3060FFC0   ADDIU V1, ZERO, -64
9D00FD88  FFC089A0   LW S8, -30304(ZERO)
9D00FD8A      89A0   SB V1, 0(V0)
9D00FD8C      CC37   B 0x9D00FDFC
9D00FD8E      0C00   NOP
848:                 	}
849:                 	else if (index==1)
9D00FD90  147E0008   LBU V1, 8(S8)
9D00FD94      ED01   LI V0, 1
9D00FD96  B4430017   BNE V1, V0, 0x9D00FDC8
9D00FD98  00170C00   SLL ZERO, S7, 1
9D00FD9A      0C00   NOP
850:                 	{
851:                 		//USB_fillString((char*)&strManufacturer);
852:                         bd_ep0_in_even->ptr=VA_TO_PA(strManufacturer);
9D00FD9C  FC5C80A0   LW V0, -32608(GP)
9D00FDA0  41A39D00   LUI V1, 0x9D00
9D00FDA2  9D003063   LWC1 F8, 12387(ZERO)
9D00FDA4  306301D0   ADDIU V1, V1, 464
9D00FDA8  0063F02C   EXT V1, V1, 0, 31
9D00FDAA  F02CE9A1   JALX 0x98B3A684
9D00FDAC      E9A1   SW V1, 4(V0)
853:                         bd_ep0_in_even->size=strManufacturer[0];
9D00FDAE  FC5C80A0   LW V0, -32608(GP)
9D00FDB2      ED90   LI V1, 16
9D00FDB4  00633B3C   SEH V1, V1
9D00FDB6  3B3CA9A1   SH T9, -22111(GP)
9D00FDB8      A9A1   SH V1, 2(V0)
854:                         bd_ep0_in_even->data=0b11000000;
9D00FDBA  FC5C80A0   LW V0, -32608(GP)
9D00FDBE  3060FFC0   ADDIU V1, ZERO, -64
9D00FDC0  FFC089A0   LW S8, -30304(ZERO)
9D00FDC2      89A0   SB V1, 0(V0)
9D00FDC4      CC1B   B 0x9D00FDFC
9D00FDC6      0C00   NOP
855:                         
856:                 	}
857:                 	else if(index==2)
9D00FDC8  147E0008   LBU V1, 8(S8)
9D00FDCC      ED02   LI V0, 2
9D00FDCE  B4430015   BNE V1, V0, 0x9D00FDFC
9D00FDD0  00150C00   SLL ZERO, S5, 1
9D00FDD2      0C00   NOP
858:                 	{
859:                 		//USB_fillString((char*)&strProduct);
860:                         bd_ep0_in_even->ptr=VA_TO_PA(strProduct);
9D00FDD4  FC5C80A0   LW V0, -32608(GP)
9D00FDD8  41A39D00   LUI V1, 0x9D00
9D00FDDA  9D003063   LWC1 F8, 12387(ZERO)
9D00FDDC  306301E0   ADDIU V1, V1, 480
9D00FDE0  0063F02C   EXT V1, V1, 0, 31
9D00FDE2  F02CE9A1   JALX 0x98B3A684
9D00FDE4      E9A1   SW V1, 4(V0)
861:                         bd_ep0_in_even->size=strProduct[0];
9D00FDE6  FC5C80A0   LW V0, -32608(GP)
9D00FDEA      ED90   LI V1, 16
9D00FDEC  00633B3C   SEH V1, V1
9D00FDEE  3B3CA9A1   SH T9, -22111(GP)
9D00FDF0      A9A1   SH V1, 2(V0)
862:                         bd_ep0_in_even->data=0b11000000;        
9D00FDF2  FC5C80A0   LW V0, -32608(GP)
9D00FDF6  3060FFC0   ADDIU V1, ZERO, -64
9D00FDF8  FFC089A0   LW S8, -30304(ZERO)
9D00FDFA      89A0   SB V1, 0(V0)
863:                 	}
864:                 }
9D00FDFC      0FBE   MOVE SP, S8
865:                 
866:                 
867:                 #endif
---  d:/bos/bos/touchxpt2046.c  -------------------------------------------------------------------------
1:                   #include <xc.h>
2:                   #include <stdio.h>
3:                   #include <stdlib.h>
4:                   #include "globals.h"
5:                   #include "graphics.h"
6:                   
7:                   /*
8:                    * autor JR
9:                    * verze 1.0
10:                   * modul pro skenovani dotykove plochy XPT2046, SPI
11:                   */
12:                  //privatni struct pro dany displej, pri pouziti vice displeju se nastavi pri kazdem volani setGraphics
13:                  //static PORT_INFO portInfo; 
14:                  
15:                  #ifdef TOUCHPAD_XPT2046_INIT 
16:                  
17:                  //definuje hodnoty krajnich bodu (plati pro 8-bit, Vcc=3.3V)
18:                  #define     MINX            10
19:                  #define     MAXX            110
20:                  #define     MINY            5
21:                  #define     MAXY            120
22:                  
23:                  #define     PENIRQ_PIN      BIT4
24:                  #define     PENIRQ_PORT     PORTA           //peniqr=RA4
25:                  #define     MODE8BIT                        //XPT2046 vraci data 8-bit, jinak 12-bit
26:                  
27:                  #define     EVENT_CAPA      8               //max. pocet polozek events tabulky (zde jsou adresy fci, ktere se volaji pro event)
28:                  static int events[EVENT_CAPA];
29:                  
30:                  //b7=1 start, b6,5,4 = 001Y, 101X, b3 1=8bit, 0=12bit, b2=0 interni ref, b1,0 = 00
31:                  #ifdef MODE8BIT
32:                      //XPT2046 vraci data 8-bit
33:                      static char mx_out=0b11011000; 
34:                      static char my_out=0b10011000;
35:                  #else
36:                      //XPT2046 vraci data 12-bit
37:                      static char mx_out=0b11010000; 
38:                      static char my_out=0b10010000;
39:                  #endif
40:                  
41:                  //local fn    
42:                  static void onEvent();
43:                  static void setResult(short x, short y);
44:                  static void getPort();
45:                  static void freePort();
46:                  static void setCSPin(char value);
47:                  static char getPenIrq();
48:                  
49:                  //local vars
50:                  static short x_data, y_data, prew_x_data=-1, prew_y_data=-1;
51:                  //static PORT_INFO* portInfo=NULL;
52:                  //static PORT_INFO portInfo;
53:                  
54:                  static char buffer[2];
55:                  void (*_event)(short, short);
56:                  static short screenX=0, screenY=0;
57:                  
58:                  extern DISPLAY dispSys;
59:                  extern PORT_INFO pInfo_touchSys;
60:                  
61:                  static char res[32];
62:                  static char val[16];
63:                  extern GRAPHICS graphics;
64:                  extern IMAGE_SRC f_dlg18;
65:                  static char Orientation=3;
66:                  
67:                  void touchXpt2046_start()
68:                  {
9D00D5F0      4FF5   ADDIU SP, SP, -24
9D00D5F2      CBE5   SW RA, 20(SP)
9D00D5F4      CBC4   SW S8, 16(SP)
9D00D5F6      0FDD   MOVE S8, SP
69:                      //CS=RA3, pin 8
70:                      //portInfo.cs_portBase = PORTA_BASE;                 //CS
71:                      //portInfo.cs_pin = BIT3;
72:                      //portInfo.busMode = BUS_MODE._8bit;
73:                      //portWriter_init(&portInfo, PERIPH_TYPE.spi, 1);        //pinfo obsahuje fce pro vysilani dat na pozadovany port SPI, PMP, ...
74:                      
75:                      pauseEvent(2000);               //ceka na init displeje
9D00D5F8  308007D0   ADDIU A0, ZERO, 2000
9D00D5FA      07D0   ADDU A3, S0, A1
9D00D5FC  76808168   JALS pauseEvent
9D00D600      0C00   NOP
76:                      
77:                      //char x1=1;
78:                      while(1)
79:                      {
80:                          //x1=PORTAbits.RA4;
81:                          //vstup PENIRQ je aktivni v 0
82:                          if(getPenIrq()==0) 
9D00D602  76807036   JALS getPenIrq
9D00D604  70360C00   XORI AT, S6, 3072
9D00D606      0C00   NOP
9D00D608  40A200BC   BNEZC V0, 0x9D00D784
9D00D60A  00BC7680   OR T6, GP, A1
83:                          {
84:                              //nastal dotek (penirq=0)
85:                              getPort();
9D00D60C  76806FDC   JALS getPort
9D00D60E      6FDC   ADDIU A3, A1, 24
9D00D610      0C00   NOP
86:                              spi_setSpeed(pInfo_touchSys.portIndex, 0x8);
9D00D612  41A28000   LUI V0, 0x8000
9D00D616  30420774   ADDIU V0, V0, 1908
9D00D618      0774   ADDU A2, V0, A3
9D00D61A  1442003C   LBU V0, 60(V0)
9D00D61E      0C82   MOVE A0, V0
9D00D620      EE88   LI A1, 8
9D00D622  768073F6   JALS spi_setSpeed
9D00D624  73F60C00   XORI RA, S6, 3072
9D00D626      0C00   NOP
87:                          
88:                              //write command: read x
89:                              buffer[0]=mx_out;
9D00D628  145C8024   LBU V0, -32732(GP)
9D00D62C  185C806C   SB V0, -32660(GP)
90:                              pInfo_touchSys.writeBuffer(&pInfo_touchSys, buffer, 1);
9D00D630  41A28000   LUI V0, 0x8000
9D00D634  FC420774   LW V0, 1908(V0)
9D00D636      0774   ADDU A2, V0, A3
9D00D638  41A38000   LUI V1, 0x8000
9D00D63C  30830774   ADDIU A0, V1, 1908
9D00D63E      0774   ADDU A2, V0, A3
9D00D640  30BC806C   ADDIU A1, GP, -32660
9D00D644      EF01   LI A2, 1
9D00D646      45E2   JALRS16 V0
9D00D648      0C00   NOP
91:                      
92:                              pauseEvent(10);
9D00D64A      EE0A   LI A0, 10
9D00D64C  76808168   JALS pauseEvent
9D00D650      0C00   NOP
93:                          
94:                              //read data (x)
95:                              buffer[0]=0; buffer[1]=0;
9D00D652  181C806C   SB ZERO, -32660(GP)
9D00D656  181C806D   SB ZERO, -32659(GP)
96:                              pInfo_touchSys.exchangeBuffer(&pInfo_touchSys, buffer, buffer, 2);
9D00D65A  41A28000   LUI V0, 0x8000
9D00D65E  30420774   ADDIU V0, V0, 1908
9D00D660      0774   ADDU A2, V0, A3
9D00D662      6922   LW V0, 8(V0)
9D00D664  41A38000   LUI V1, 0x8000
9D00D668  30830774   ADDIU A0, V1, 1908
9D00D66A      0774   ADDU A2, V0, A3
9D00D66C  30BC806C   ADDIU A1, GP, -32660
9D00D670  30DC806C   ADDIU A2, GP, -32660
9D00D674      EF82   LI A3, 2
9D00D676      45E2   JALRS16 V0
9D00D678      0C00   NOP
97:                  #ifdef MODE8BIT   
98:                              x_data=buffer[0];
9D00D67A  145C806C   LBU V0, -32660(GP)
9D00D67E  00423B3C   SEH V0, V0
9D00D680  3B3C385C   SH T9, 14428(GP)
9D00D682  385C8068   SH V0, -32664(GP)
99:                              
100:                 #else
101:                             x_data = ((short)buffer[0]) << 4;
102:                             x_data |= (((short)buffer[1]) >> 4);
103:                 #endif            
104:                     
105:                             pauseEvent(10);
9D00D686      EE0A   LI A0, 10
9D00D688  76808168   JALS pauseEvent
9D00D68C      0C00   NOP
106:                         
107:                             //write command: read y
108:                             buffer[0]=my_out;
9D00D68E  145C8025   LBU V0, -32731(GP)
9D00D692  185C806C   SB V0, -32660(GP)
109:                             pInfo_touchSys.writeBuffer(&pInfo_touchSys, buffer, 1);
9D00D696  41A28000   LUI V0, 0x8000
9D00D69A  FC420774   LW V0, 1908(V0)
9D00D69C      0774   ADDU A2, V0, A3
9D00D69E  41A38000   LUI V1, 0x8000
9D00D6A2  30830774   ADDIU A0, V1, 1908
9D00D6A4      0774   ADDU A2, V0, A3
9D00D6A6  30BC806C   ADDIU A1, GP, -32660
9D00D6AA      EF01   LI A2, 1
9D00D6AC      45E2   JALRS16 V0
9D00D6AE      0C00   NOP
110:                         
111:                             pauseEvent(10);
9D00D6B0      EE0A   LI A0, 10
9D00D6B2  76808168   JALS pauseEvent
9D00D6B6      0C00   NOP
112:                             
113:                             //read data (y)
114:                             buffer[0]=0; buffer[1]=0;
9D00D6B8  181C806C   SB ZERO, -32660(GP)
9D00D6BC  181C806D   SB ZERO, -32659(GP)
115:                             pInfo_touchSys.exchangeBuffer(&pInfo_touchSys, buffer, buffer, 2);
9D00D6C0  41A28000   LUI V0, 0x8000
9D00D6C4  30420774   ADDIU V0, V0, 1908
9D00D6C6      0774   ADDU A2, V0, A3
9D00D6C8      6922   LW V0, 8(V0)
9D00D6CA  41A38000   LUI V1, 0x8000
9D00D6CE  30830774   ADDIU A0, V1, 1908
9D00D6D0      0774   ADDU A2, V0, A3
9D00D6D2  30BC806C   ADDIU A1, GP, -32660
9D00D6D6  30DC806C   ADDIU A2, GP, -32660
9D00D6DA      EF82   LI A3, 2
9D00D6DC      45E2   JALRS16 V0
9D00D6DE      0C00   NOP
116:                 #ifdef MODE8BIT   
117:                             y_data=buffer[0];
9D00D6E0  145C806C   LBU V0, -32660(GP)
9D00D6E4  00423B3C   SEH V0, V0
9D00D6E6  3B3C385C   SH T9, 14428(GP)
9D00D6E8  385C806A   SH V0, -32662(GP)
118:                             
119:                 #else
120:                             y_data = ((short)buffer[0]) << 4;
121:                             y_data |= (((short)buffer[1]) >> 4);
122:                 #endif               
123:                        
124:                             freePort();
9D00D6EC  76806FF4   JALS freePort
9D00D6EE      6FF4   ADDIU A3, A3, 8
9D00D6F0      0C00   NOP
125:                             spi_setSpeed(pInfo_touchSys.portIndex, 0x0);
9D00D6F2  41A28000   LUI V0, 0x8000
9D00D6F6  30420774   ADDIU V0, V0, 1908
9D00D6F8      0774   ADDU A2, V0, A3
9D00D6FA  1442003C   LBU V0, 60(V0)
9D00D6FE      0C82   MOVE A0, V0
9D00D700      0CA0   MOVE A1, ZERO
9D00D702  768073F6   JALS spi_setSpeed
9D00D704  73F60C00   XORI RA, S6, 3072
9D00D706      0C00   NOP
126:                         
127:                             if( (x_data >= prew_x_data-5) && (x_data <= prew_x_data+5) )
9D00D708  3C5C8068   LH V0, -32664(GP)
9D00D70C      0C62   MOVE V1, V0
9D00D70E  3C5C8026   LH V0, -32730(GP)
9D00D712      4C56   ADDIU V0, V0, -5
9D00D714  00431350   SLT V0, V1, V0
9D00D716  135040A2   ADDI K0, S0, 16546
9D00D718  40A2002A   BNEZC V0, 0x9D00D770
9D00D71C  3C5C8068   LH V0, -32664(GP)
9D00D720      0C62   MOVE V1, V0
9D00D722  3C5C8026   LH V0, -32730(GP)
9D00D726      4C4A   ADDIU V0, V0, 5
9D00D728  00621350   SLT V0, V0, V1
9D00D72A  135040A2   ADDI K0, S0, 16546
9D00D72C  40A20020   BNEZC V0, 0x9D00D770
128:                             {
129:                                 if( (y_data >= prew_y_data-5) && (y_data <= prew_y_data+5) )
9D00D730  3C5C806A   LH V0, -32662(GP)
9D00D734      0C62   MOVE V1, V0
9D00D736  3C5C8028   LH V0, -32728(GP)
9D00D73A      4C56   ADDIU V0, V0, -5
9D00D73C  00431350   SLT V0, V1, V0
9D00D73E  135040A2   ADDI K0, S0, 16546
9D00D740  40A20016   BNEZC V0, 0x9D00D770
9D00D744  3C5C806A   LH V0, -32662(GP)
9D00D748      0C62   MOVE V1, V0
9D00D74A  3C5C8028   LH V0, -32728(GP)
9D00D74E      4C4A   ADDIU V0, V0, 5
9D00D750  00621350   SLT V0, V0, V1
9D00D752  135040A2   ADDI K0, S0, 16546
9D00D754  40A2000C   BNEZC V0, 0x9D00D770
130:                                 {
131:                                     setResult(x_data, y_data);
9D00D758  3C7C8068   LH V1, -32664(GP)
9D00D75C  3C5C806A   LH V0, -32662(GP)
9D00D760      0C83   MOVE A0, V1
9D00D762      0CA2   MOVE A1, V0
9D00D764  76806C78   JALS setResult
9D00D766      6C78   ADDIU S0, A3, 16
9D00D768      0C00   NOP
132:                                     onEvent();
9D00D76A  76806C3C   JALS onEvent
9D00D76C      6C3C   ADDIU S0, V1, 24
9D00D76E      0C00   NOP
133:                                 }
134:                             }
135:                             prew_x_data=x_data;
9D00D770  3C5C8068   LH V0, -32664(GP)
9D00D774  385C8026   SH V0, -32730(GP)
136:                             prew_y_data=y_data;
9D00D778  3C5C806A   LH V0, -32662(GP)
9D00D77C  385C8028   SH V0, -32728(GP)
9D00D780      CC07   B 0x9D00D790
9D00D782      0C00   NOP
137:                             
138:                             
139:                             //setResult(x_data, y_data);
140:                             //pauseEvent(200);
141:                         }
142:                         else
143:                         {
144:                             prew_x_data=-1;
9D00D784      ED7F   LI V0, -1
9D00D786  385C8026   SH V0, -32730(GP)
145:                             prew_y_data=-1;
9D00D78A      ED7F   LI V0, -1
9D00D78C  385C8028   SH V0, -32728(GP)
146:                         }
147:                         
148:                         doEvents();
9D00D790  76807F8E   JALS doEvents
9D00D794      0C00   NOP
149:                     }
9D00D796      CF35   B 0x9D00D602
9D00D798      0C00   NOP
9D00D79A      0C00   NOP
150:                     
151:                 }
152:                 int touchXpt2046_regEvent(void* fn)
153:                 {
9D00D79C      4FF9   ADDIU SP, SP, -16
9D00D79E      CBC3   SW S8, 12(SP)
9D00D7A0      0FDD   MOVE S8, SP
9D00D7A2  F89E0010   SW A0, 16(S8)
154:                     int a;
155:                     for(a=0; a<EVENT_CAPA; a++)
9D00D7A6  F81E0000   SW ZERO, 0(S8)
9D00D7AA      CC1F   B 0x9D00D7EA
9D00D7AC      0C00   NOP
9D00D7E0  FC5E0000   LW V0, 0(S8)
9D00D7E2  00006D20   ADD T5, ZERO, ZERO
9D00D7E4      6D20   ADDIU V0, V0, 1
9D00D7E6  F85E0000   SW V0, 0(S8)
9D00D7EA  FC5E0000   LW V0, 0(S8)
9D00D7EE  90420008   SLTI V0, V0, 8
9D00D7F2  40A2FFDC   BNEZC V0, 0x9D00D7AE
9D00D7F4  FFDC0C40   LW S8, 3136(GP)
156:                     {
157:                         if(events[a]==0x0)
9D00D7AE  41A28000   LUI V0, 0x8000
9D00D7B2  FC7E0000   LW V1, 0(S8)
9D00D7B6      25B4   SLL V1, V1, 2
9D00D7B8  30420AE4   ADDIU V0, V0, 2788
9D00D7BA      0AE4   LBU A1, 4(A2)
9D00D7BC      0526   ADDU V0, V1, V0
9D00D7BE      6920   LW V0, 0(V0)
9D00D7C0  40A2000E   BNEZC V0, 0x9D00D7E0
158:                         {
159:                             events[a]=(int)fn;
9D00D7C4  FC7E0010   LW V1, 16(S8)
9D00D7C8  41A28000   LUI V0, 0x8000
9D00D7CC  FC9E0000   LW A0, 0(S8)
9D00D7D0      2644   SLL A0, A0, 2
9D00D7D2  30420AE4   ADDIU V0, V0, 2788
9D00D7D4      0AE4   LBU A1, 4(A2)
9D00D7D6      0528   ADDU V0, A0, V0
9D00D7D8      E9A0   SW V1, 0(V0)
160:                             return 1;
9D00D7DA      ED01   LI V0, 1
9D00D7DC      CC0D   B 0x9D00D7F8
9D00D7DE      0C00   NOP
161:                         }
162:                     }
163:                     
164:                     return 0;
9D00D7F6      0C40   MOVE V0, ZERO
165:                 }
9D00D7F8      0FBE   MOVE SP, S8
9D00D7FA      4BC3   LW S8, 12(SP)
9D00D7FC      4C09   ADDIU SP, SP, 16
9D00D7FE      45BF   JRC RA
166:                 void touchXpt2046_unregEvent(void* fn)
167:                 {
9D00D800      4FF1   ADDIU SP, SP, -32
9D00D802      CBE7   SW RA, 28(SP)
9D00D804      CBC6   SW S8, 24(SP)
9D00D806      0FDD   MOVE S8, SP
9D00D808  F89E0020   SW A0, 32(S8)
168:                     int a;
169:                     for(a=0; a<EVENT_CAPA; a++)
9D00D80C  F81E0010   SW ZERO, 16(S8)
9D00D80E  0010CC28   MOVN T9, S0, ZERO
9D00D810      CC28   B 0x9D00D862
9D00D812      0C00   NOP
9D00D858  FC5E0010   LW V0, 16(S8)
9D00D85A  00106D20   ADD T5, S0, ZERO
9D00D85C      6D20   ADDIU V0, V0, 1
9D00D85E  F85E0010   SW V0, 16(S8)
9D00D862  FC5E0010   LW V0, 16(S8)
9D00D866  90420008   SLTI V0, V0, 8
9D00D86A  40A2FFD3   BNEZC V0, 0x9D00D814
9D00D86C  FFD30FBE   LW S8, 4030(S3)
170:                     {
171:                         if(events[a]==(int)fn)
9D00D814  41A28000   LUI V0, 0x8000
9D00D818  FC7E0010   LW V1, 16(S8)
9D00D81C      25B4   SLL V1, V1, 2
9D00D81E  30420AE4   ADDIU V0, V0, 2788
9D00D820      0AE4   LBU A1, 4(A2)
9D00D822      0526   ADDU V0, V1, V0
9D00D824      69A0   LW V1, 0(V0)
9D00D826  FC5E0020   LW V0, 32(S8)
9D00D82A  B4430015   BNE V1, V0, 0x9D00D858
9D00D82C  00150C00   SLL ZERO, S5, 1
9D00D82E      0C00   NOP
172:                         {
173:                             events[a]=0x0;
9D00D830  41A28000   LUI V0, 0x8000
9D00D834  FC7E0010   LW V1, 16(S8)
9D00D838      25B4   SLL V1, V1, 2
9D00D83A  30420AE4   ADDIU V0, V0, 2788
9D00D83C      0AE4   LBU A1, 4(A2)
9D00D83E      0526   ADDU V0, V1, V0
9D00D840      E820   SW S0, 0(V0)
174:                             //a0=adresa tabulky, a1=velikost polozky, a2=max. pocet polozek
175:                             defragTableW(events, 4, EVENT_CAPA);
9D00D842  41A28000   LUI V0, 0x8000
9D00D846  30820AE4   ADDIU A0, V0, 2788
9D00D848      0AE4   LBU A1, 4(A2)
9D00D84A      EE84   LI A1, 4
9D00D84C      EF08   LI A2, 8
9D00D84E  7680822C   JALS defragTableW
9D00D852      0C00   NOP
176:                             return;
9D00D854      CC0C   B 0x9D00D86E
9D00D856      0C00   NOP
177:                         }
178:                     }
179:                 }
9D00D86E      0FBE   MOVE SP, S8
9D00D870      4BE7   LW RA, 28(SP)
9D00D872      4BC6   LW S8, 24(SP)
9D00D874      4C11   ADDIU SP, SP, 32
9D00D876      45BF   JRC RA
180:                 static void onEvent()
181:                 {
9D00D878      4FF1   ADDIU SP, SP, -32
9D00D87A      CBE7   SW RA, 28(SP)
9D00D87C      CBC6   SW S8, 24(SP)
9D00D87E      0FDD   MOVE S8, SP
182:                     int a;
183:                     for(a=0; a<EVENT_CAPA; a++)
9D00D880  F81E0010   SW ZERO, 16(S8)
9D00D884      CC29   B 0x9D00D8D8
9D00D886      0C00   NOP
9D00D8C6  FC5E0010   LW V0, 16(S8)
9D00D8C8  00106D20   ADD T5, S0, ZERO
9D00D8CA      6D20   ADDIU V0, V0, 1
9D00D8CC  F85E0010   SW V0, 16(S8)
9D00D8D0      CC03   B 0x9D00D8D8
9D00D8D2      0C00   NOP
9D00D8D8  FC5E0010   LW V0, 16(S8)
9D00D8DC  90420008   SLTI V0, V0, 8
9D00D8E0  40A2FFD2   BNEZC V0, 0x9D00D888
9D00D8E2  FFD20FBE   LW S8, 4030(S2)
184:                     {
185:                         if(events[a]!=0x0)
9D00D888  41A28000   LUI V0, 0x8000
9D00D88C  FC7E0010   LW V1, 16(S8)
9D00D890      25B4   SLL V1, V1, 2
9D00D892  30420AE4   ADDIU V0, V0, 2788
9D00D894      0AE4   LBU A1, 4(A2)
9D00D896      0526   ADDU V0, V1, V0
9D00D898      6920   LW V0, 0(V0)
9D00D89A  40E2001B   BEQZC V0, 0x9D00D8D4
186:                         {
187:                             _event = (void*)events[a];
9D00D89E  41A28000   LUI V0, 0x8000
9D00D8A2  FC7E0010   LW V1, 16(S8)
9D00D8A6      25B4   SLL V1, V1, 2
9D00D8A8  30420AE4   ADDIU V0, V0, 2788
9D00D8AA      0AE4   LBU A1, 4(A2)
9D00D8AC      0526   ADDU V0, V1, V0
9D00D8AE      6920   LW V0, 0(V0)
9D00D8B0  F85C80AC   SW V0, -32596(GP)
188:                             _event(screenX, screenY);
9D00D8B4  FC5C80AC   LW V0, -32596(GP)
9D00D8B8  3C9C806E   LH A0, -32658(GP)
9D00D8BC  3C7C8070   LH V1, -32656(GP)
9D00D8C0      0CA3   MOVE A1, V1
9D00D8C2      45E2   JALRS16 V0
9D00D8C4      0C00   NOP
189:                         }
190:                         else
191:                         {
192:                             //konec
193:                             return;
9D00D8D4      CC07   B 0x9D00D8E4
9D00D8D6      0C00   NOP
194:                         }
195:                     }    
196:                 }
9D00D8E4      0FBE   MOVE SP, S8
9D00D8E6      4BE7   LW RA, 28(SP)
9D00D8E8      4BC6   LW S8, 24(SP)
9D00D8EA      4C11   ADDIU SP, SP, 32
9D00D8EC      45BF   JRC RA
9D00D8EE      0C00   NOP
197:                 
198:                 
199:                 static void setResult(short x, short y)
200:                 {
9D00D8F0      4FE9   ADDIU SP, SP, -48
9D00D8F2      CBEB   SW RA, 44(SP)
9D00D8F4      CBCA   SW S8, 40(SP)
9D00D8F6      0FDD   MOVE S8, SP
9D00D8F8      0C64   MOVE V1, A0
9D00D8FA      0C45   MOVE V0, A1
9D00D8FC  387E0030   SH V1, 48(S8)
9D00D900  385E0034   SH V0, 52(S8)
201:                     
202:                     float w=(float)dispSys.getWidth();     //  320;
9D00D904  41A28000   LUI V0, 0x8000
9D00D908  304206E8   ADDIU V0, V0, 1768
9D00D90A      06E8   ADDU A1, A0, A2
9D00D90C      692F   LW V0, 60(V0)
9D00D90E      45E2   JALRS16 V0
9D00D910      0C00   NOP
9D00D912      0C82   MOVE A0, V0
9D00D914  76800090   JALS sitofp
9D00D916  00900C00   SLL A0, S0, 1
9D00D918      0C00   NOP
9D00D91A  F85E0018   SW V0, 24(S8)
203:                     float h=(float)dispSys.getHeight();    // 240;
9D00D91E  41A28000   LUI V0, 0x8000
9D00D922  304206E8   ADDIU V0, V0, 1768
9D00D924      06E8   ADDU A1, A0, A2
9D00D926  FC420040   LW V0, 64(V0)
9D00D92A      45E2   JALRS16 V0
9D00D92C      0C00   NOP
9D00D92E      0C82   MOVE A0, V0
9D00D930  76800090   JALS sitofp
9D00D932  00900C00   SLL A0, S0, 1
9D00D934      0C00   NOP
9D00D936  F85E001C   SW V0, 28(S8)
204:                     char orient=dispSys.getOrientation();
9D00D93A  41A28000   LUI V0, 0x8000
9D00D93E  304206E8   ADDIU V0, V0, 1768
9D00D940      06E8   ADDU A1, A0, A2
9D00D942      692E   LW V0, 56(V0)
9D00D944      45E2   JALRS16 V0
9D00D946      0C00   NOP
9D00D948  185E0020   SB V0, 32(S8)
205:                     
206:                     float f;
207:                     
208:                     if(orient==0)
9D00D94C  145E0020   LBU V0, 32(S8)
9D00D950  40A200B4   BNEZC V0, 0x9D00DABC
209:                     {
210:                         //na vysku, normalne
211:                         f=((float)MAXY - (float) y) / ((float)MAXY - (float)MINY) * h;
9D00D954  3C5E0034   LH V0, 52(S8)
9D00D958      0C82   MOVE A0, V0
9D00D95A  76800090   JALS sitofp
9D00D95C  00900C00   SLL A0, S0, 1
9D00D95E      0C00   NOP
9D00D960  41A39D01   LUI V1, 0x9D01
9D00D962  9D01FC83   LWC1 F8, -893(AT)
9D00D964  FC833818   LW A0, 14360(V1)
9D00D966  38180CA2   SH ZERO, 3234(T8)
9D00D968      0CA2   MOVE A1, V0
9D00D96A  76809A4A   JALS __subsf3
9D00D96C  9A4A0C00   SWC1 F18, 3072(T2)
9D00D96E      0C00   NOP
9D00D970      0C62   MOVE V1, V0
9D00D972  41A29D01   LUI V0, 0x9D01
9D00D974  9D010C83   LWC1 F8, 3203(AT)
9D00D976      0C83   MOVE A0, V1
9D00D978  FCA2381C   LW A1, 14364(V0)
9D00D97A  381C7680   SH ZERO, 30336(GP)
9D00D97C  76809B14   JALS __divsf3
9D00D97E  9B140C00   SWC1 F24, 3072(S4)
9D00D980      0C00   NOP
9D00D982      0C82   MOVE A0, V0
9D00D984  FCBE001C   LW A1, 28(S8)
9D00D986  001C7680   OR T6, GP, ZERO
9D00D988  76809D88   JALS __mulsf3
9D00D98A  9D880C00   LWC1 F12, 3072(T0)
9D00D98C      0C00   NOP
9D00D98E  F85E0024   SW V0, 36(S8)
212:                         screenY=(short)f;
9D00D992  FC9E0024   LW A0, 36(S8)
9D00D994  00247680   OR T6, A0, AT
9D00D996  76809C16   JALS __fixsfsi
9D00D998  9C160C00   LWC1 F0, 3072(S6)
9D00D99A      0C00   NOP
9D00D99C  00423B3C   SEH V0, V0
9D00D99E  3B3C385C   SH T9, 14428(GP)
9D00D9A0  385C8070   SH V0, -32656(GP)
213:                         if(screenY < 0){ screenY = 0; }
9D00D9A4  3C5C8070   LH V0, -32656(GP)
9D00D9A8  40420003   BGEZ V0, 0x9D00D9B2
9D00D9AA  00030C00   SLL ZERO, V1, 1
9D00D9AC      0C00   NOP
9D00D9AE  381C8070   SH ZERO, -32656(GP)
214:                         if(screenY >= h){ screenY = h-1; }
9D00D9B2  3C5C8070   LH V0, -32656(GP)
9D00D9B6      0C82   MOVE A0, V0
9D00D9B8  76800090   JALS sitofp
9D00D9BA  00900C00   SLL A0, S0, 1
9D00D9BC      0C00   NOP
9D00D9BE  FC9E001C   LW A0, 28(S8)
9D00D9C2      0CA2   MOVE A1, V0
9D00D9C4  76809E3C   JALS __lesf2
9D00D9C6  9E3C0C00   LWC1 F17, 3072(GP)
9D00D9C8      0C00   NOP
9D00D9CA  40C20012   BGTZ V0, 0x9D00D9F2
9D00D9CC  00120C00   SLL ZERO, S2, 1
9D00D9CE      0C00   NOP
9D00D9D0  41A29D01   LUI V0, 0x9D01
9D00D9D2  9D01FC9E   LWC1 F8, -866(AT)
9D00D9D4  FC9E001C   LW A0, 28(S8)
9D00D9D8  FCA23820   LW A1, 14368(V0)
9D00D9DA  38207680   SH AT, 30336(ZERO)
9D00D9DC  76809A4A   JALS __subsf3
9D00D9DE  9A4A0C00   SWC1 F18, 3072(T2)
9D00D9E0      0C00   NOP
9D00D9E2      0C82   MOVE A0, V0
9D00D9E4  76809C16   JALS __fixsfsi
9D00D9E6  9C160C00   LWC1 F0, 3072(S6)
9D00D9E8      0C00   NOP
9D00D9EA  00423B3C   SEH V0, V0
9D00D9EC  3B3C385C   SH T9, 14428(GP)
9D00D9EE  385C8070   SH V0, -32656(GP)
215:                         
216:                         f=((float)MAXX - (float) x) / ((float)MAXX - (float)MINX) * w;
9D00D9F2  3C5E0030   LH V0, 48(S8)
9D00D9F6      0C82   MOVE A0, V0
9D00D9F8  76800090   JALS sitofp
9D00D9FA  00900C00   SLL A0, S0, 1
9D00D9FC      0C00   NOP
9D00D9FE  41A39D01   LUI V1, 0x9D01
9D00DA00  9D01FC83   LWC1 F8, -893(AT)
9D00DA02  FC833824   LW A0, 14372(V1)
9D00DA04  38240CA2   SH AT, 3234(A0)
9D00DA06      0CA2   MOVE A1, V0
9D00DA08  76809A4A   JALS __subsf3
9D00DA0A  9A4A0C00   SWC1 F18, 3072(T2)
9D00DA0C      0C00   NOP
9D00DA0E      0C62   MOVE V1, V0
9D00DA10  41A29D01   LUI V0, 0x9D01
9D00DA12  9D010C83   LWC1 F8, 3203(AT)
9D00DA14      0C83   MOVE A0, V1
9D00DA16  FCA23828   LW A1, 14376(V0)
9D00DA18  38287680   SH AT, 30336(T0)
9D00DA1A  76809B14   JALS __divsf3
9D00DA1C  9B140C00   SWC1 F24, 3072(S4)
9D00DA1E      0C00   NOP
9D00DA20      0C82   MOVE A0, V0
9D00DA22  FCBE0018   LW A1, 24(S8)
9D00DA24  00187680   OR T6, T8, ZERO
9D00DA26  76809D88   JALS __mulsf3
9D00DA28  9D880C00   LWC1 F12, 3072(T0)
9D00DA2A      0C00   NOP
9D00DA2C  F85E0024   SW V0, 36(S8)
217:                         screenX= w-(short)f;
9D00DA30  FC9E0024   LW A0, 36(S8)
9D00DA32  00247680   OR T6, A0, AT
9D00DA34  76809C16   JALS __fixsfsi
9D00DA36  9C160C00   LWC1 F0, 3072(S6)
9D00DA38      0C00   NOP
9D00DA3A  00423B3C   SEH V0, V0
9D00DA3C  3B3C0C82   SH T9, 3202(GP)
9D00DA3E      0C82   MOVE A0, V0
9D00DA40  76800090   JALS sitofp
9D00DA42  00900C00   SLL A0, S0, 1
9D00DA44      0C00   NOP
9D00DA46  FC9E0018   LW A0, 24(S8)
9D00DA4A      0CA2   MOVE A1, V0
9D00DA4C  76809A4A   JALS __subsf3
9D00DA4E  9A4A0C00   SWC1 F18, 3072(T2)
9D00DA50      0C00   NOP
9D00DA52      0C82   MOVE A0, V0
9D00DA54  76809C16   JALS __fixsfsi
9D00DA56  9C160C00   LWC1 F0, 3072(S6)
9D00DA58      0C00   NOP
9D00DA5A  00423B3C   SEH V0, V0
9D00DA5C  3B3C385C   SH T9, 14428(GP)
9D00DA5E  385C806E   SH V0, -32658(GP)
218:                         if(screenX < 0){ screenX = 0; }
9D00DA62  3C5C806E   LH V0, -32658(GP)
9D00DA66  40420003   BGEZ V0, 0x9D00DA70
9D00DA68  00030C00   SLL ZERO, V1, 1
9D00DA6A      0C00   NOP
9D00DA6C  381C806E   SH ZERO, -32658(GP)
219:                         if(screenX >= w){ screenX = w-1; }          
9D00DA70  3C5C806E   LH V0, -32658(GP)
9D00DA74      0C82   MOVE A0, V0
9D00DA76  76800090   JALS sitofp
9D00DA78  00900C00   SLL A0, S0, 1
9D00DA7A      0C00   NOP
9D00DA7C  FC9E0018   LW A0, 24(S8)
9D00DA80      0CA2   MOVE A1, V0
9D00DA82  76809E3C   JALS __lesf2
9D00DA84  9E3C0C00   LWC1 F17, 3072(GP)
9D00DA86      0C00   NOP
9D00DA88  40820004   BLEZ V0, 0x9D00DA94
9D00DA8A  00040C00   SLL ZERO, A0, 1
9D00DA8C      0C00   NOP
9D00DA8E  94000239   B 0x9D00DF04
9D00DA90  02390C00   SLL S1, T9, 1
9D00DA92      0C00   NOP
9D00DA94  41A29D01   LUI V0, 0x9D01
9D00DA96  9D01FC9E   LWC1 F8, -866(AT)
9D00DA98  FC9E0018   LW A0, 24(S8)
9D00DA9C  FCA23820   LW A1, 14368(V0)
9D00DA9E  38207680   SH AT, 30336(ZERO)
9D00DAA0  76809A4A   JALS __subsf3
9D00DAA2  9A4A0C00   SWC1 F18, 3072(T2)
9D00DAA4      0C00   NOP
9D00DAA6      0C82   MOVE A0, V0
9D00DAA8  76809C16   JALS __fixsfsi
9D00DAAA  9C160C00   LWC1 F0, 3072(S6)
9D00DAAC      0C00   NOP
9D00DAAE  00423B3C   SEH V0, V0
9D00DAB0  3B3C385C   SH T9, 14428(GP)
9D00DAB2  385C806E   SH V0, -32658(GP)
9D00DAB6  94000225   B 0x9D00DF04
9D00DAB8  02250C00   SLL S1, A1, 1
9D00DABA      0C00   NOP
220:                     }
221:                     else if(orient==1)
9D00DABC  147E0020   LBU V1, 32(S8)
9D00DAC0      ED01   LI V0, 1
9D00DAC2  B44300A3   BNE V1, V0, 0x9D00DC0C
9D00DAC4  00A30C00   SLL A1, V1, 1
9D00DAC6      0C00   NOP
222:                     {
223:                         //na sirku, normalne
224:                         f=((float)MAXY - (float) y) / ((float)MAXY - (float)MINY) * w;
9D00DAC8  3C5E0034   LH V0, 52(S8)
9D00DACC      0C82   MOVE A0, V0
9D00DACE  76800090   JALS sitofp
9D00DAD0  00900C00   SLL A0, S0, 1
9D00DAD2      0C00   NOP
9D00DAD4  41A39D01   LUI V1, 0x9D01
9D00DAD6  9D01FC83   LWC1 F8, -893(AT)
9D00DAD8  FC833818   LW A0, 14360(V1)
9D00DADA  38180CA2   SH ZERO, 3234(T8)
9D00DADC      0CA2   MOVE A1, V0
9D00DADE  76809A4A   JALS __subsf3
9D00DAE0  9A4A0C00   SWC1 F18, 3072(T2)
9D00DAE2      0C00   NOP
9D00DAE4      0C62   MOVE V1, V0
9D00DAE6  41A29D01   LUI V0, 0x9D01
9D00DAE8  9D010C83   LWC1 F8, 3203(AT)
9D00DAEA      0C83   MOVE A0, V1
9D00DAEC  FCA2381C   LW A1, 14364(V0)
9D00DAEE  381C7680   SH ZERO, 30336(GP)
9D00DAF0  76809B14   JALS __divsf3
9D00DAF2  9B140C00   SWC1 F24, 3072(S4)
9D00DAF4      0C00   NOP
9D00DAF6      0C82   MOVE A0, V0
9D00DAF8  FCBE0018   LW A1, 24(S8)
9D00DAFA  00187680   OR T6, T8, ZERO
9D00DAFC  76809D88   JALS __mulsf3
9D00DAFE  9D880C00   LWC1 F12, 3072(T0)
9D00DB00      0C00   NOP
9D00DB02  F85E0024   SW V0, 36(S8)
225:                         screenX=(short)f;
9D00DB06  FC9E0024   LW A0, 36(S8)
9D00DB08  00247680   OR T6, A0, AT
9D00DB0A  76809C16   JALS __fixsfsi
9D00DB0C  9C160C00   LWC1 F0, 3072(S6)
9D00DB0E      0C00   NOP
9D00DB10  00423B3C   SEH V0, V0
9D00DB12  3B3C385C   SH T9, 14428(GP)
9D00DB14  385C806E   SH V0, -32658(GP)
226:                         if(screenX < 0){ screenX = 0; }
9D00DB18  3C5C806E   LH V0, -32658(GP)
9D00DB1C  40420003   BGEZ V0, 0x9D00DB26
9D00DB1E  00030C00   SLL ZERO, V1, 1
9D00DB20      0C00   NOP
9D00DB22  381C806E   SH ZERO, -32658(GP)
227:                         if(screenX >= w){ screenX = w-1; }
9D00DB26  3C5C806E   LH V0, -32658(GP)
9D00DB2A      0C82   MOVE A0, V0
9D00DB2C  76800090   JALS sitofp
9D00DB2E  00900C00   SLL A0, S0, 1
9D00DB30      0C00   NOP
9D00DB32  FC9E0018   LW A0, 24(S8)
9D00DB36      0CA2   MOVE A1, V0
9D00DB38  76809E3C   JALS __lesf2
9D00DB3A  9E3C0C00   LWC1 F17, 3072(GP)
9D00DB3C      0C00   NOP
9D00DB3E  40C20012   BGTZ V0, 0x9D00DB66
9D00DB40  00120C00   SLL ZERO, S2, 1
9D00DB42      0C00   NOP
9D00DB44  41A29D01   LUI V0, 0x9D01
9D00DB46  9D01FC9E   LWC1 F8, -866(AT)
9D00DB48  FC9E0018   LW A0, 24(S8)
9D00DB4C  FCA23820   LW A1, 14368(V0)
9D00DB4E  38207680   SH AT, 30336(ZERO)
9D00DB50  76809A4A   JALS __subsf3
9D00DB52  9A4A0C00   SWC1 F18, 3072(T2)
9D00DB54      0C00   NOP
9D00DB56      0C82   MOVE A0, V0
9D00DB58  76809C16   JALS __fixsfsi
9D00DB5A  9C160C00   LWC1 F0, 3072(S6)
9D00DB5C      0C00   NOP
9D00DB5E  00423B3C   SEH V0, V0
9D00DB60  3B3C385C   SH T9, 14428(GP)
9D00DB62  385C806E   SH V0, -32658(GP)
228:                         
229:                         f=((float)MAXX - (float) x) / ((float)MAXX - (float)MINX) * h;
9D00DB66  3C5E0030   LH V0, 48(S8)
9D00DB6A      0C82   MOVE A0, V0
9D00DB6C  76800090   JALS sitofp
9D00DB6E  00900C00   SLL A0, S0, 1
9D00DB70      0C00   NOP
9D00DB72  41A39D01   LUI V1, 0x9D01
9D00DB74  9D01FC83   LWC1 F8, -893(AT)
9D00DB76  FC833824   LW A0, 14372(V1)
9D00DB78  38240CA2   SH AT, 3234(A0)
9D00DB7A      0CA2   MOVE A1, V0
9D00DB7C  76809A4A   JALS __subsf3
9D00DB7E  9A4A0C00   SWC1 F18, 3072(T2)
9D00DB80      0C00   NOP
9D00DB82      0C62   MOVE V1, V0
9D00DB84  41A29D01   LUI V0, 0x9D01
9D00DB86  9D010C83   LWC1 F8, 3203(AT)
9D00DB88      0C83   MOVE A0, V1
9D00DB8A  FCA23828   LW A1, 14376(V0)
9D00DB8C  38287680   SH AT, 30336(T0)
9D00DB8E  76809B14   JALS __divsf3
9D00DB90  9B140C00   SWC1 F24, 3072(S4)
9D00DB92      0C00   NOP
9D00DB94      0C82   MOVE A0, V0
9D00DB96  FCBE001C   LW A1, 28(S8)
9D00DB98  001C7680   OR T6, GP, ZERO
9D00DB9A  76809D88   JALS __mulsf3
9D00DB9C  9D880C00   LWC1 F12, 3072(T0)
9D00DB9E      0C00   NOP
9D00DBA0  F85E0024   SW V0, 36(S8)
230:                         screenY=(short)f;
9D00DBA4  FC9E0024   LW A0, 36(S8)
9D00DBA6  00247680   OR T6, A0, AT
9D00DBA8  76809C16   JALS __fixsfsi
9D00DBAA  9C160C00   LWC1 F0, 3072(S6)
9D00DBAC      0C00   NOP
9D00DBAE  00423B3C   SEH V0, V0
9D00DBB0  3B3C385C   SH T9, 14428(GP)
9D00DBB2  385C8070   SH V0, -32656(GP)
231:                         if(screenY < 0){ screenY = 0; }
9D00DBB6  3C5C8070   LH V0, -32656(GP)
9D00DBBA  40420003   BGEZ V0, 0x9D00DBC4
9D00DBBC  00030C00   SLL ZERO, V1, 1
9D00DBBE      0C00   NOP
9D00DBC0  381C8070   SH ZERO, -32656(GP)
232:                         if(screenY >= h){ screenY = h-1; }        
9D00DBC4  3C5C8070   LH V0, -32656(GP)
9D00DBC8      0C82   MOVE A0, V0
9D00DBCA  76800090   JALS sitofp
9D00DBCC  00900C00   SLL A0, S0, 1
9D00DBCE      0C00   NOP
9D00DBD0  FC9E001C   LW A0, 28(S8)
9D00DBD4      0CA2   MOVE A1, V0
9D00DBD6  76809E3C   JALS __lesf2
9D00DBD8  9E3C0C00   LWC1 F17, 3072(GP)
9D00DBDA      0C00   NOP
9D00DBDC  40820003   BLEZ V0, 0x9D00DBE6
9D00DBDE  00030C00   SLL ZERO, V1, 1
9D00DBE0      0C00   NOP
9D00DBE2      CD90   B 0x9D00DF04
9D00DBE4      0C00   NOP
9D00DBE6  41A29D01   LUI V0, 0x9D01
9D00DBE8  9D01FC9E   LWC1 F8, -866(AT)
9D00DBEA  FC9E001C   LW A0, 28(S8)
9D00DBEE  FCA23820   LW A1, 14368(V0)
9D00DBF0  38207680   SH AT, 30336(ZERO)
9D00DBF2  76809A4A   JALS __subsf3
9D00DBF4  9A4A0C00   SWC1 F18, 3072(T2)
9D00DBF6      0C00   NOP
9D00DBF8      0C82   MOVE A0, V0
9D00DBFA  76809C16   JALS __fixsfsi
9D00DBFC  9C160C00   LWC1 F0, 3072(S6)
9D00DBFE      0C00   NOP
9D00DC00  00423B3C   SEH V0, V0
9D00DC02  3B3C385C   SH T9, 14428(GP)
9D00DC04  385C8070   SH V0, -32656(GP)
9D00DC08      CD7D   B 0x9D00DF04
9D00DC0A      0C00   NOP
233:                     }
234:                     else if(orient==2)
9D00DC0C  147E0020   LBU V1, 32(S8)
9D00DC10      ED02   LI V0, 2
9D00DC12  B44300B3   BNE V1, V0, 0x9D00DD7C
9D00DC14  00B30C00   SLL A1, S3, 1
9D00DC16      0C00   NOP
235:                     {
236:                         //na vysku, obracene
237:                         f=((float)MAXY - (float) y) / ((float)MAXY - (float)MINY) * h;
9D00DC18  3C5E0034   LH V0, 52(S8)
9D00DC1C      0C82   MOVE A0, V0
9D00DC1E  76800090   JALS sitofp
9D00DC20  00900C00   SLL A0, S0, 1
9D00DC22      0C00   NOP
9D00DC24  41A39D01   LUI V1, 0x9D01
9D00DC26  9D01FC83   LWC1 F8, -893(AT)
9D00DC28  FC833818   LW A0, 14360(V1)
9D00DC2A  38180CA2   SH ZERO, 3234(T8)
9D00DC2C      0CA2   MOVE A1, V0
9D00DC2E  76809A4A   JALS __subsf3
9D00DC30  9A4A0C00   SWC1 F18, 3072(T2)
9D00DC32      0C00   NOP
9D00DC34      0C62   MOVE V1, V0
9D00DC36  41A29D01   LUI V0, 0x9D01
9D00DC38  9D010C83   LWC1 F8, 3203(AT)
9D00DC3A      0C83   MOVE A0, V1
9D00DC3C  FCA2381C   LW A1, 14364(V0)
9D00DC3E  381C7680   SH ZERO, 30336(GP)
9D00DC40  76809B14   JALS __divsf3
9D00DC42  9B140C00   SWC1 F24, 3072(S4)
9D00DC44      0C00   NOP
9D00DC46      0C82   MOVE A0, V0
9D00DC48  FCBE001C   LW A1, 28(S8)
9D00DC4A  001C7680   OR T6, GP, ZERO
9D00DC4C  76809D88   JALS __mulsf3
9D00DC4E  9D880C00   LWC1 F12, 3072(T0)
9D00DC50      0C00   NOP
9D00DC52  F85E0024   SW V0, 36(S8)
238:                         screenY=h-(short)f;
9D00DC56  FC9E0024   LW A0, 36(S8)
9D00DC58  00247680   OR T6, A0, AT
9D00DC5A  76809C16   JALS __fixsfsi
9D00DC5C  9C160C00   LWC1 F0, 3072(S6)
9D00DC5E      0C00   NOP
9D00DC60  00423B3C   SEH V0, V0
9D00DC62  3B3C0C82   SH T9, 3202(GP)
9D00DC64      0C82   MOVE A0, V0
9D00DC66  76800090   JALS sitofp
9D00DC68  00900C00   SLL A0, S0, 1
9D00DC6A      0C00   NOP
9D00DC6C  FC9E001C   LW A0, 28(S8)
9D00DC70      0CA2   MOVE A1, V0
9D00DC72  76809A4A   JALS __subsf3
9D00DC74  9A4A0C00   SWC1 F18, 3072(T2)
9D00DC76      0C00   NOP
9D00DC78      0C82   MOVE A0, V0
9D00DC7A  76809C16   JALS __fixsfsi
9D00DC7C  9C160C00   LWC1 F0, 3072(S6)
9D00DC7E      0C00   NOP
9D00DC80  00423B3C   SEH V0, V0
9D00DC82  3B3C385C   SH T9, 14428(GP)
9D00DC84  385C8070   SH V0, -32656(GP)
239:                         if(screenY < 0){ screenY = 0; }
9D00DC88  3C5C8070   LH V0, -32656(GP)
9D00DC8C  40420003   BGEZ V0, 0x9D00DC96
9D00DC8E  00030C00   SLL ZERO, V1, 1
9D00DC90      0C00   NOP
9D00DC92  381C8070   SH ZERO, -32656(GP)
240:                         if(screenY >= h){ screenY = h-1; }
9D00DC96  3C5C8070   LH V0, -32656(GP)
9D00DC9A      0C82   MOVE A0, V0
9D00DC9C  76800090   JALS sitofp
9D00DC9E  00900C00   SLL A0, S0, 1
9D00DCA0      0C00   NOP
9D00DCA2  FC9E001C   LW A0, 28(S8)
9D00DCA6      0CA2   MOVE A1, V0
9D00DCA8  76809E3C   JALS __lesf2
9D00DCAA  9E3C0C00   LWC1 F17, 3072(GP)
9D00DCAC      0C00   NOP
9D00DCAE  40C20012   BGTZ V0, 0x9D00DCD6
9D00DCB0  00120C00   SLL ZERO, S2, 1
9D00DCB2      0C00   NOP
9D00DCB4  41A29D01   LUI V0, 0x9D01
9D00DCB6  9D01FC9E   LWC1 F8, -866(AT)
9D00DCB8  FC9E001C   LW A0, 28(S8)
9D00DCBC  FCA23820   LW A1, 14368(V0)
9D00DCBE  38207680   SH AT, 30336(ZERO)
9D00DCC0  76809A4A   JALS __subsf3
9D00DCC2  9A4A0C00   SWC1 F18, 3072(T2)
9D00DCC4      0C00   NOP
9D00DCC6      0C82   MOVE A0, V0
9D00DCC8  76809C16   JALS __fixsfsi
9D00DCCA  9C160C00   LWC1 F0, 3072(S6)
9D00DCCC      0C00   NOP
9D00DCCE  00423B3C   SEH V0, V0
9D00DCD0  3B3C385C   SH T9, 14428(GP)
9D00DCD2  385C8070   SH V0, -32656(GP)
241:                         
242:                         f=((float)MAXX - (float) x) / ((float)MAXX - (float)MINX) * w;
9D00DCD6  3C5E0030   LH V0, 48(S8)
9D00DCDA      0C82   MOVE A0, V0
9D00DCDC  76800090   JALS sitofp
9D00DCDE  00900C00   SLL A0, S0, 1
9D00DCE0      0C00   NOP
9D00DCE2  41A39D01   LUI V1, 0x9D01
9D00DCE4  9D01FC83   LWC1 F8, -893(AT)
9D00DCE6  FC833824   LW A0, 14372(V1)
9D00DCE8  38240CA2   SH AT, 3234(A0)
9D00DCEA      0CA2   MOVE A1, V0
9D00DCEC  76809A4A   JALS __subsf3
9D00DCEE  9A4A0C00   SWC1 F18, 3072(T2)
9D00DCF0      0C00   NOP
9D00DCF2      0C62   MOVE V1, V0
9D00DCF4  41A29D01   LUI V0, 0x9D01
9D00DCF6  9D010C83   LWC1 F8, 3203(AT)
9D00DCF8      0C83   MOVE A0, V1
9D00DCFA  FCA23828   LW A1, 14376(V0)
9D00DCFC  38287680   SH AT, 30336(T0)
9D00DCFE  76809B14   JALS __divsf3
9D00DD00  9B140C00   SWC1 F24, 3072(S4)
9D00DD02      0C00   NOP
9D00DD04      0C82   MOVE A0, V0
9D00DD06  FCBE0018   LW A1, 24(S8)
9D00DD08  00187680   OR T6, T8, ZERO
9D00DD0A  76809D88   JALS __mulsf3
9D00DD0C  9D880C00   LWC1 F12, 3072(T0)
9D00DD0E      0C00   NOP
9D00DD10  F85E0024   SW V0, 36(S8)
243:                         screenX=(short)f;
9D00DD14  FC9E0024   LW A0, 36(S8)
9D00DD16  00247680   OR T6, A0, AT
9D00DD18  76809C16   JALS __fixsfsi
9D00DD1A  9C160C00   LWC1 F0, 3072(S6)
9D00DD1C      0C00   NOP
9D00DD1E  00423B3C   SEH V0, V0
9D00DD20  3B3C385C   SH T9, 14428(GP)
9D00DD22  385C806E   SH V0, -32658(GP)
244:                         if(screenX < 0){ screenX = 0; }
9D00DD26  3C5C806E   LH V0, -32658(GP)
9D00DD2A  40420003   BGEZ V0, 0x9D00DD34
9D00DD2C  00030C00   SLL ZERO, V1, 1
9D00DD2E      0C00   NOP
9D00DD30  381C806E   SH ZERO, -32658(GP)
245:                         if(screenX >= w){ screenX = w-1; }          
9D00DD34  3C5C806E   LH V0, -32658(GP)
9D00DD38      0C82   MOVE A0, V0
9D00DD3A  76800090   JALS sitofp
9D00DD3C  00900C00   SLL A0, S0, 1
9D00DD3E      0C00   NOP
9D00DD40  FC9E0018   LW A0, 24(S8)
9D00DD44      0CA2   MOVE A1, V0
9D00DD46  76809E3C   JALS __lesf2
9D00DD48  9E3C0C00   LWC1 F17, 3072(GP)
9D00DD4A      0C00   NOP
9D00DD4C  40820003   BLEZ V0, 0x9D00DD56
9D00DD4E  00030C00   SLL ZERO, V1, 1
9D00DD50      0C00   NOP
9D00DD52      CCD8   B 0x9D00DF04
9D00DD54      0C00   NOP
9D00DD56  41A29D01   LUI V0, 0x9D01
9D00DD58  9D01FC9E   LWC1 F8, -866(AT)
9D00DD5A  FC9E0018   LW A0, 24(S8)
9D00DD5E  FCA23820   LW A1, 14368(V0)
9D00DD60  38207680   SH AT, 30336(ZERO)
9D00DD62  76809A4A   JALS __subsf3
9D00DD64  9A4A0C00   SWC1 F18, 3072(T2)
9D00DD66      0C00   NOP
9D00DD68      0C82   MOVE A0, V0
9D00DD6A  76809C16   JALS __fixsfsi
9D00DD6C  9C160C00   LWC1 F0, 3072(S6)
9D00DD6E      0C00   NOP
9D00DD70  00423B3C   SEH V0, V0
9D00DD72  3B3C385C   SH T9, 14428(GP)
9D00DD74  385C806E   SH V0, -32658(GP)
9D00DD78      CCC5   B 0x9D00DF04
9D00DD7A      0C00   NOP
246:                     }
247:                     else if(orient==3)
9D00DD7C  147E0020   LBU V1, 32(S8)
9D00DD80      ED03   LI V0, 3
9D00DD82  B44300BF   BNE V1, V0, 0x9D00DF04
9D00DD84  00BF0C00   SLL A1, RA, 1
9D00DD86      0C00   NOP
248:                     {
249:                         //na sirku, obracene
250:                         f=((float)MAXY - (float) y) / ((float)MAXY - (float)MINY) * w;
9D00DD88  3C5E0034   LH V0, 52(S8)
9D00DD8C      0C82   MOVE A0, V0
9D00DD8E  76800090   JALS sitofp
9D00DD90  00900C00   SLL A0, S0, 1
9D00DD92      0C00   NOP
9D00DD94  41A39D01   LUI V1, 0x9D01
9D00DD96  9D01FC83   LWC1 F8, -893(AT)
9D00DD98  FC833818   LW A0, 14360(V1)
9D00DD9A  38180CA2   SH ZERO, 3234(T8)
9D00DD9C      0CA2   MOVE A1, V0
9D00DD9E  76809A4A   JALS __subsf3
9D00DDA0  9A4A0C00   SWC1 F18, 3072(T2)
9D00DDA2      0C00   NOP
9D00DDA4      0C62   MOVE V1, V0
9D00DDA6  41A29D01   LUI V0, 0x9D01
9D00DDA8  9D010C83   LWC1 F8, 3203(AT)
9D00DDAA      0C83   MOVE A0, V1
9D00DDAC  FCA2381C   LW A1, 14364(V0)
9D00DDAE  381C7680   SH ZERO, 30336(GP)
9D00DDB0  76809B14   JALS __divsf3
9D00DDB2  9B140C00   SWC1 F24, 3072(S4)
9D00DDB4      0C00   NOP
9D00DDB6      0C82   MOVE A0, V0
9D00DDB8  FCBE0018   LW A1, 24(S8)
9D00DDBA  00187680   OR T6, T8, ZERO
9D00DDBC  76809D88   JALS __mulsf3
9D00DDBE  9D880C00   LWC1 F12, 3072(T0)
9D00DDC0      0C00   NOP
9D00DDC2  F85E0024   SW V0, 36(S8)
251:                         screenX=w-(short)f;
9D00DDC6  FC9E0024   LW A0, 36(S8)
9D00DDC8  00247680   OR T6, A0, AT
9D00DDCA  76809C16   JALS __fixsfsi
9D00DDCC  9C160C00   LWC1 F0, 3072(S6)
9D00DDCE      0C00   NOP
9D00DDD0  00423B3C   SEH V0, V0
9D00DDD2  3B3C0C82   SH T9, 3202(GP)
9D00DDD4      0C82   MOVE A0, V0
9D00DDD6  76800090   JALS sitofp
9D00DDD8  00900C00   SLL A0, S0, 1
9D00DDDA      0C00   NOP
9D00DDDC  FC9E0018   LW A0, 24(S8)
9D00DDE0      0CA2   MOVE A1, V0
9D00DDE2  76809A4A   JALS __subsf3
9D00DDE4  9A4A0C00   SWC1 F18, 3072(T2)
9D00DDE6      0C00   NOP
9D00DDE8      0C82   MOVE A0, V0
9D00DDEA  76809C16   JALS __fixsfsi
9D00DDEC  9C160C00   LWC1 F0, 3072(S6)
9D00DDEE      0C00   NOP
9D00DDF0  00423B3C   SEH V0, V0
9D00DDF2  3B3C385C   SH T9, 14428(GP)
9D00DDF4  385C806E   SH V0, -32658(GP)
252:                         if(screenX < 0){ screenX = 0; }
9D00DDF8  3C5C806E   LH V0, -32658(GP)
9D00DDFC  40420003   BGEZ V0, 0x9D00DE06
9D00DDFE  00030C00   SLL ZERO, V1, 1
9D00DE00      0C00   NOP
9D00DE02  381C806E   SH ZERO, -32658(GP)
253:                         if(screenX >= w){ screenX = w-1; }
9D00DE06  3C5C806E   LH V0, -32658(GP)
9D00DE0A      0C82   MOVE A0, V0
9D00DE0C  76800090   JALS sitofp
9D00DE0E  00900C00   SLL A0, S0, 1
9D00DE10      0C00   NOP
9D00DE12  FC9E0018   LW A0, 24(S8)
9D00DE16      0CA2   MOVE A1, V0
9D00DE18  76809E3C   JALS __lesf2
9D00DE1A  9E3C0C00   LWC1 F17, 3072(GP)
9D00DE1C      0C00   NOP
9D00DE1E  40C20012   BGTZ V0, 0x9D00DE46
9D00DE20  00120C00   SLL ZERO, S2, 1
9D00DE22      0C00   NOP
9D00DE24  41A29D01   LUI V0, 0x9D01
9D00DE26  9D01FC9E   LWC1 F8, -866(AT)
9D00DE28  FC9E0018   LW A0, 24(S8)
9D00DE2C  FCA23820   LW A1, 14368(V0)
9D00DE2E  38207680   SH AT, 30336(ZERO)
9D00DE30  76809A4A   JALS __subsf3
9D00DE32  9A4A0C00   SWC1 F18, 3072(T2)
9D00DE34      0C00   NOP
9D00DE36      0C82   MOVE A0, V0
9D00DE38  76809C16   JALS __fixsfsi
9D00DE3A  9C160C00   LWC1 F0, 3072(S6)
9D00DE3C      0C00   NOP
9D00DE3E  00423B3C   SEH V0, V0
9D00DE40  3B3C385C   SH T9, 14428(GP)
9D00DE42  385C806E   SH V0, -32658(GP)
254:                         
255:                         f=((float)MAXX - (float) x) / ((float)MAXX - (float)MINX) * h;
9D00DE46  3C5E0030   LH V0, 48(S8)
9D00DE4A      0C82   MOVE A0, V0
9D00DE4C  76800090   JALS sitofp
9D00DE4E  00900C00   SLL A0, S0, 1
9D00DE50      0C00   NOP
9D00DE52  41A39D01   LUI V1, 0x9D01
9D00DE54  9D01FC83   LWC1 F8, -893(AT)
9D00DE56  FC833824   LW A0, 14372(V1)
9D00DE58  38240CA2   SH AT, 3234(A0)
9D00DE5A      0CA2   MOVE A1, V0
9D00DE5C  76809A4A   JALS __subsf3
9D00DE5E  9A4A0C00   SWC1 F18, 3072(T2)
9D00DE60      0C00   NOP
9D00DE62      0C62   MOVE V1, V0
9D00DE64  41A29D01   LUI V0, 0x9D01
9D00DE66  9D010C83   LWC1 F8, 3203(AT)
9D00DE68      0C83   MOVE A0, V1
9D00DE6A  FCA23828   LW A1, 14376(V0)
9D00DE6C  38287680   SH AT, 30336(T0)
9D00DE6E  76809B14   JALS __divsf3
9D00DE70  9B140C00   SWC1 F24, 3072(S4)
9D00DE72      0C00   NOP
9D00DE74      0C82   MOVE A0, V0
9D00DE76  FCBE001C   LW A1, 28(S8)
9D00DE78  001C7680   OR T6, GP, ZERO
9D00DE7A  76809D88   JALS __mulsf3
9D00DE7C  9D880C00   LWC1 F12, 3072(T0)
9D00DE7E      0C00   NOP
9D00DE80  F85E0024   SW V0, 36(S8)
256:                         screenY=h-(short)f;
9D00DE84  FC9E0024   LW A0, 36(S8)
9D00DE86  00247680   OR T6, A0, AT
9D00DE88  76809C16   JALS __fixsfsi
9D00DE8A  9C160C00   LWC1 F0, 3072(S6)
9D00DE8C      0C00   NOP
9D00DE8E  00423B3C   SEH V0, V0
9D00DE90  3B3C0C82   SH T9, 3202(GP)
9D00DE92      0C82   MOVE A0, V0
9D00DE94  76800090   JALS sitofp
9D00DE96  00900C00   SLL A0, S0, 1
9D00DE98      0C00   NOP
9D00DE9A  FC9E001C   LW A0, 28(S8)
9D00DE9E      0CA2   MOVE A1, V0
9D00DEA0  76809A4A   JALS __subsf3
9D00DEA2  9A4A0C00   SWC1 F18, 3072(T2)
9D00DEA4      0C00   NOP
9D00DEA6      0C82   MOVE A0, V0
9D00DEA8  76809C16   JALS __fixsfsi
9D00DEAA  9C160C00   LWC1 F0, 3072(S6)
9D00DEAC      0C00   NOP
9D00DEAE  00423B3C   SEH V0, V0
9D00DEB0  3B3C385C   SH T9, 14428(GP)
9D00DEB2  385C8070   SH V0, -32656(GP)
257:                         if(screenY < 0){ screenY = 0; }
9D00DEB6  3C5C8070   LH V0, -32656(GP)
9D00DEBA  40420003   BGEZ V0, 0x9D00DEC4
9D00DEBC  00030C00   SLL ZERO, V1, 1
9D00DEBE      0C00   NOP
9D00DEC0  381C8070   SH ZERO, -32656(GP)
258:                         if(screenY >= h){ screenY = h-1; }        
9D00DEC4  3C5C8070   LH V0, -32656(GP)
9D00DEC8      0C82   MOVE A0, V0
9D00DECA  76800090   JALS sitofp
9D00DECC  00900C00   SLL A0, S0, 1
9D00DECE      0C00   NOP
9D00DED0  FC9E001C   LW A0, 28(S8)
9D00DED4      0CA2   MOVE A1, V0
9D00DED6  76809E3C   JALS __lesf2
9D00DED8  9E3C0C00   LWC1 F17, 3072(GP)
9D00DEDA      0C00   NOP
9D00DEDC  40C20012   BGTZ V0, 0x9D00DF04
9D00DEDE  00120C00   SLL ZERO, S2, 1
9D00DEE0      0C00   NOP
9D00DEE2  41A29D01   LUI V0, 0x9D01
9D00DEE4  9D01FC9E   LWC1 F8, -866(AT)
9D00DEE6  FC9E001C   LW A0, 28(S8)
9D00DEEA  FCA23820   LW A1, 14368(V0)
9D00DEEC  38207680   SH AT, 30336(ZERO)
9D00DEEE  76809A4A   JALS __subsf3
9D00DEF0  9A4A0C00   SWC1 F18, 3072(T2)
9D00DEF2      0C00   NOP
9D00DEF4      0C82   MOVE A0, V0
9D00DEF6  76809C16   JALS __fixsfsi
9D00DEF8  9C160C00   LWC1 F0, 3072(S6)
9D00DEFA      0C00   NOP
9D00DEFC  00423B3C   SEH V0, V0
9D00DEFE  3B3C385C   SH T9, 14428(GP)
9D00DF00  385C8070   SH V0, -32656(GP)
259:                     }    
260:                     //screenX=x;
261:                     //screenY=y;
262:                     
263:                     intToChar(screenX, val, 4);
9D00DF04  3C5C806E   LH V0, -32658(GP)
9D00DF08      0C82   MOVE A0, V0
9D00DF0A  41A28000   LUI V0, 0x8000
9D00DF0E  30A20B24   ADDIU A1, V0, 2852
9D00DF10      0B24   LBU A2, 4(V0)
9D00DF12      EF04   LI A2, 4
9D00DF14  7680818A   JALS intToChar
9D00DF18      0C00   NOP
264:                     createString(res, 32, "x= ", val, NULL);
9D00DF1A      C804   SW ZERO, 16(SP)
9D00DF1C  41A28000   LUI V0, 0x8000
9D00DF20  30820B04   ADDIU A0, V0, 2820
9D00DF22      0B04   LBU A2, 4(S0)
9D00DF24      EEA0   LI A1, 32
9D00DF26  41A29D01   LUI V0, 0x9D01
9D00DF28  9D0130C2   LWC1 F8, 12482(AT)
9D00DF2A  30C23810   ADDIU A2, V0, 14352
9D00DF2C  381041A2   SH ZERO, 16802(S0)
9D00DF2E  41A28000   LUI V0, 0x8000
9D00DF32  30E20B24   ADDIU A3, V0, 2852
9D00DF34      0B24   LBU A2, 4(V0)
9D00DF36  768083F2   JALS createString
9D00DF3A      0C00   NOP
265:                     graphics.drawString(res, NULL, 100, 80);
9D00DF3C  41A28000   LUI V0, 0x8000
9D00DF40  304206C0   ADDIU V0, V0, 1728
9D00DF42      06C0   ADDU A1, S0, A0
9D00DF44      6922   LW V0, 8(V0)
9D00DF46  41A38000   LUI V1, 0x8000
9D00DF4A  30830B04   ADDIU A0, V1, 2820
9D00DF4C      0B04   LBU A2, 4(S0)
9D00DF4E      0CA0   MOVE A1, ZERO
9D00DF50      EF64   LI A2, 100
9D00DF52      EFD0   LI A3, 80
9D00DF54      45E2   JALRS16 V0
9D00DF56      0C00   NOP
266:                 
267:                     intToChar(screenY, val, 4);
9D00DF58  3C5C8070   LH V0, -32656(GP)
9D00DF5C      0C82   MOVE A0, V0
9D00DF5E  41A28000   LUI V0, 0x8000
9D00DF62  30A20B24   ADDIU A1, V0, 2852
9D00DF64      0B24   LBU A2, 4(V0)
9D00DF66      EF04   LI A2, 4
9D00DF68  7680818A   JALS intToChar
9D00DF6C      0C00   NOP
268:                     createString(res, 32, "y= ", val, NULL);
9D00DF6E      C804   SW ZERO, 16(SP)
9D00DF70  41A28000   LUI V0, 0x8000
9D00DF74  30820B04   ADDIU A0, V0, 2820
9D00DF76      0B04   LBU A2, 4(S0)
9D00DF78      EEA0   LI A1, 32
9D00DF7A  41A29D01   LUI V0, 0x9D01
9D00DF7C  9D0130C2   LWC1 F8, 12482(AT)
9D00DF7E  30C23814   ADDIU A2, V0, 14356
9D00DF80  381441A2   SH ZERO, 16802(S4)
9D00DF82  41A28000   LUI V0, 0x8000
9D00DF86  30E20B24   ADDIU A3, V0, 2852
9D00DF88      0B24   LBU A2, 4(V0)
9D00DF8A  768083F2   JALS createString
9D00DF8E      0C00   NOP
269:                     graphics.drawString(res, NULL, 100, 110);    
9D00DF90  41A28000   LUI V0, 0x8000
9D00DF94  304206C0   ADDIU V0, V0, 1728
9D00DF96      06C0   ADDU A1, S0, A0
9D00DF98      6922   LW V0, 8(V0)
9D00DF9A  41A38000   LUI V1, 0x8000
9D00DF9E  30830B04   ADDIU A0, V1, 2820
9D00DFA0      0B04   LBU A2, 4(S0)
9D00DFA2      0CA0   MOVE A1, ZERO
9D00DFA4      EF64   LI A2, 100
9D00DFA6      EFEE   LI A3, 110
9D00DFA8      45E2   JALRS16 V0
9D00DFAA      0C00   NOP
270:                 }
9D00DFAC      0FBE   MOVE SP, S8
9D00DFAE      4BEB   LW RA, 44(SP)
9D00DFB0      4BCA   LW S8, 40(SP)
9D00DFB2      4C19   ADDIU SP, SP, 48
9D00DFB4      45BF   JRC RA
9D00DFB6      0C00   NOP
271:                 
272:                 
273:                 static void getPort()
274:                 {
9D00DFB8      4FF5   ADDIU SP, SP, -24
9D00DFBA      CBE5   SW RA, 20(SP)
9D00DFBC      CBC4   SW S8, 16(SP)
9D00DFBE      0FDD   MOVE S8, SP
275:                     //spi_Use(display->portIndex, 1, NULL, &eventDC);
276:                     pInfo_touchSys.getPort(&pInfo_touchSys);
9D00DFC0  41A28000   LUI V0, 0x8000
9D00DFC4  30420774   ADDIU V0, V0, 1908
9D00DFC6      0774   ADDU A2, V0, A3
9D00DFC8      6923   LW V0, 12(V0)
9D00DFCA  41A38000   LUI V1, 0x8000
9D00DFCE  30830774   ADDIU A0, V1, 1908
9D00DFD0      0774   ADDU A2, V0, A3
9D00DFD2      45E2   JALRS16 V0
9D00DFD4      0C00   NOP
277:                     
278:                     setCSPin(0);
9D00DFD6      0C80   MOVE A0, ZERO
9D00DFD8  7680700C   JALS setCSPin
9D00DFDA  700C0C00   XORI ZERO, T4, 3072
9D00DFDC      0C00   NOP
279:                 }
9D00DFDE      0FBE   MOVE SP, S8
9D00DFE0      4BE5   LW RA, 20(SP)
9D00DFE2      4BC4   LW S8, 16(SP)
9D00DFE4      4C0D   ADDIU SP, SP, 24
9D00DFE6      45BF   JRC RA
280:                 
281:                 static void freePort()
282:                 {
9D00DFE8      4FF5   ADDIU SP, SP, -24
9D00DFEA      CBE5   SW RA, 20(SP)
9D00DFEC      CBC4   SW S8, 16(SP)
9D00DFEE      0FDD   MOVE S8, SP
283:                     //spi_Free(display->portIndex, 0);
284:                     pInfo_touchSys.freePort(&pInfo_touchSys);               //pri cekani na odvysilani muze volat doEvents()
9D00DFF0  41A28000   LUI V0, 0x8000
9D00DFF4  30420774   ADDIU V0, V0, 1908
9D00DFF6      0774   ADDU A2, V0, A3
9D00DFF8      6924   LW V0, 16(V0)
9D00DFFA  41A38000   LUI V1, 0x8000
9D00DFFE  30830774   ADDIU A0, V1, 1908
9D00E000      0774   ADDU A2, V0, A3
9D00E002      45E2   JALRS16 V0
9D00E004      0C00   NOP
285:                     
286:                     setCSPin(1);
9D00E006      EE01   LI A0, 1
9D00E008  7680700C   JALS setCSPin
9D00E00A  700C0C00   XORI ZERO, T4, 3072
9D00E00C      0C00   NOP
287:                 }
9D00E00E      0FBE   MOVE SP, S8
9D00E010      4BE5   LW RA, 20(SP)
9D00E012      4BC4   LW S8, 16(SP)
9D00E014      4C0D   ADDIU SP, SP, 24
9D00E016      45BF   JRC RA
288:                 
289:                 static void setCSPin(char value)
290:                 {
9D00E018      4FF9   ADDIU SP, SP, -16
9D00E01A      CBC3   SW S8, 12(SP)
9D00E01C      0FDD   MOVE S8, SP
9D00E01E      0C44   MOVE V0, A0
9D00E020  185E0010   SB V0, 16(S8)
291:                     //nastav CS pin na value
292:                     int* p;
293:                     if(value==0)
9D00E024  145E0010   LBU V0, 16(S8)
9D00E028  40A2000B   BNEZC V0, 0x9D00E042
294:                     {
295:                         p=(int*)(pInfo_touchSys.cs_portBase + LAT_OFFSET + CLR_OFFSET);
9D00E02C  41A28000   LUI V0, 0x8000
9D00E030  30420774   ADDIU V0, V0, 1908
9D00E032      0774   ADDU A2, V0, A3
9D00E034      6929   LW V0, 36(V0)
9D00E036  30420034   ADDIU V0, V0, 52
9D00E03A  F85E0000   SW V0, 0(S8)
9D00E03E      CC0A   B 0x9D00E054
9D00E040      0C00   NOP
296:                     }
297:                     else
298:                     {
299:                         p=(int*)(pInfo_touchSys.cs_portBase + LAT_OFFSET + SET_OFFSET);
9D00E042  41A28000   LUI V0, 0x8000
9D00E046  30420774   ADDIU V0, V0, 1908
9D00E048      0774   ADDU A2, V0, A3
9D00E04A      6929   LW V0, 36(V0)
9D00E04C  30420038   ADDIU V0, V0, 56
9D00E050  F85E0000   SW V0, 0(S8)
300:                     }
301:                     
302:                     *p = pInfo_touchSys.cs_pin;  
9D00E054  41A28000   LUI V0, 0x8000
9D00E058  30420774   ADDIU V0, V0, 1908
9D00E05A      0774   ADDU A2, V0, A3
9D00E05C      69AA   LW V1, 40(V0)
9D00E05E  FC5E0000   LW V0, 0(S8)
9D00E060  0000E9A0   SUB SP, ZERO, ZERO
9D00E062      E9A0   SW V1, 0(V0)
303:                 }
9D00E064      0FBE   MOVE SP, S8
9D00E066      4BC3   LW S8, 12(SP)
9D00E068      4C09   ADDIU SP, SP, 16
9D00E06A      45BF   JRC RA
304:                 
305:                 static char getPenIrq()
306:                 {
9D00E06C      4FF9   ADDIU SP, SP, -16
9D00E06E      CBC3   SW S8, 12(SP)
9D00E070      0FDD   MOVE S8, SP
307:                     int v=PENIRQ_PORT & PENIRQ_PIN;
9D00E072  41A2BF80   LUI V0, 0xBF80
9D00E074  BF80FC42   LDC1 F28, -958(ZERO)
9D00E076  FC422BD0   LW V0, 11216(V0)
9D00E078      2BD0   LHU A3, 0(A1)
9D00E07A      2D28   ANDI V0, V0, 0x10
9D00E07C  F85E0000   SW V0, 0(S8)
308:                     if(v==0){ return 0; }
9D00E080  FC5E0000   LW V0, 0(S8)
9D00E084  40A20003   BNEZC V0, 0x9D00E08E
9D00E086  00030C40   SRL ZERO, V1, 1
9D00E088      0C40   MOVE V0, ZERO
9D00E08A      CC02   B 0x9D00E090
9D00E08C      0C00   NOP
309:                     else { return 1; }
9D00E08E      ED01   LI V0, 1
310:                 }
9D00E090      0FBE   MOVE SP, S8
311:                 
312:                 #endif
---  d:/bos/bos/test.c  ---------------------------------------------------------------------------------
1:                   /* ************************************************************************** */
2:                   /** Descriptive File Name
3:                   
4:                     @Company
5:                       Company Name
6:                   
7:                     @File Name
8:                       filename.c
9:                   
10:                    @Summary
11:                      Brief description of the file.
12:                  
13:                    @Description
14:                      Describe the purpose of this file.
15:                   */
16:                  /* ************************************************************************** */
17:                  
18:                  /* ************************************************************************** */
19:                  /* ************************************************************************** */
20:                  /* Section: Included Files                                                    */
21:                  /* ************************************************************************** */
22:                  /* ************************************************************************** */
23:                  
24:                  /* This section lists the other files that are included in this file.
25:                   */
26:                  
27:                  /* TODO:  Include other files here if needed. */
28:                  
29:                  
30:                  /* ************************************************************************** */
31:                  /* ************************************************************************** */
32:                  /* Section: File Scope or Global Data                                         */
33:                  /* ************************************************************************** */
34:                  /* ************************************************************************** */
35:                  
36:                  /*  A brief description of a section can be given directly below the section
37:                      banner.
38:                   */
39:                  
40:                  /* ************************************************************************** */
41:                  /** Descriptive Data Item Name
42:                  
43:                    @Summary
44:                      Brief one-line summary of the data item.
45:                      
46:                    @Description
47:                      Full description, explaining the purpose and usage of data item.
48:                      <p>
49:                      Additional description in consecutive paragraphs separated by HTML 
50:                      paragraph breaks, as necessary.
51:                      <p>
52:                      Type "JavaDoc" in the "How Do I?" IDE toolbar for more information on tags.
53:                      
54:                    @Remarks
55:                      Any additional remarks
56:                   */
57:                  int global_data;
58:                  
59:                  
60:                  /* ************************************************************************** */
61:                  /* ************************************************************************** */
62:                  // Section: Local Functions                                                   */
63:                  /* ************************************************************************** */
64:                  /* ************************************************************************** */
65:                  
66:                  /*  A brief description of a section can be given directly below the section
67:                      banner.
68:                   */
69:                  
70:                  /* ************************************************************************** */
71:                  
72:                  /** 
73:                    @Function
74:                      int ExampleLocalFunctionName ( int param1, int param2 ) 
75:                  
76:                    @Summary
77:                      Brief one-line description of the function.
78:                  
79:                    @Description
80:                      Full description, explaining the purpose and usage of the function.
81:                      <p>
82:                      Additional description in consecutive paragraphs separated by HTML 
83:                      paragraph breaks, as necessary.
84:                      <p>
85:                      Type "JavaDoc" in the "How Do I?" IDE toolbar for more information on tags.
86:                  
87:                    @Precondition
88:                      List and describe any required preconditions. If there are no preconditions,
89:                      enter "None."
90:                  
91:                    @Parameters
92:                      @param param1 Describe the first parameter to the function.
93:                      
94:                      @param param2 Describe the second parameter to the function.
95:                  
96:                    @Returns
97:                      List (if feasible) and describe the return values of the function.
98:                      <ul>
99:                        <li>1   Indicates an error occurred
100:                       <li>0   Indicates an error did not occur
101:                     </ul>
102:                 
103:                   @Remarks
104:                     Describe any special behavior not described above.
105:                     <p>
106:                     Any additional remarks.
107:                 
108:                   @Example
109:                     @code
110:                     if(ExampleFunctionName(1, 2) == 0)
111:                     {
112:                         return 3;
113:                     }
114:                  */
115:                 static int ExampleLocalFunction(int param1, int param2) {
9D013C18      4FB0   ADDIU SP, SP, -8
9D013C1A      CBC1   SW S8, 4(SP)
9D013C1C      0FDD   MOVE S8, SP
9D013C1E  F89E0008   SW A0, 8(S8)
9D013C22  F8BE000C   SW A1, 12(S8)
9D013C24  000C0C40   SRL ZERO, T4, 1
116:                     return 0;
9D013C26      0C40   MOVE V0, ZERO
117:                 }
9D013C28      0FBE   MOVE SP, S8
9D013C2A      4BC1   LW S8, 4(SP)
9D013C2C      4C05   ADDIU SP, SP, 8
9D013C2E      45BF   JRC RA
118:                 
119:                 
120:                 /* ************************************************************************** */
121:                 /* ************************************************************************** */
122:                 // Section: Interface Functions                                               */
123:                 /* ************************************************************************** */
124:                 /* ************************************************************************** */
125:                 
126:                 /*  A brief description of a section can be given directly below the section
127:                     banner.
128:                  */
129:                 
130:                 // *****************************************************************************
131:                 
132:                 /** 
133:                   @Function
134:                     int ExampleInterfaceFunctionName ( int param1, int param2 ) 
135:                 
136:                   @Summary
137:                     Brief one-line description of the function.
138:                 
139:                   @Remarks
140:                     Refer to the example_file.h interface header for function usage details.
141:                  */
142:                 int ExampleInterfaceFunction(int param1, int param2) {
9D013C30      4FB0   ADDIU SP, SP, -8
9D013C32      CBC1   SW S8, 4(SP)
9D013C34      0FDD   MOVE S8, SP
9D013C36  F89E0008   SW A0, 8(S8)
9D013C3A  F8BE000C   SW A1, 12(S8)
9D013C3C  000C0C40   SRL ZERO, T4, 1
143:                     return 0;
9D013C3E      0C40   MOVE V0, ZERO
144:                 }
9D013C40      0FBE   MOVE SP, S8
145:                 
146:                 
147:                 /* *****************************************************************************
148:                  End of File
149:                  */
---  d:/bos/bos/spi.c  ----------------------------------------------------------------------------------
1:                   #include <xc.h>
2:                   #include <stdio.h>
3:                   #include <stdlib.h>
4:                   #include "globals.h"
5:                   #include "spi.h"
6:                   
7:                   /*
8:                    * autor JR
9:                    * verze 1.0
10:                   * I2C driver pro procesory rady PIC32MM
11:                   */
12:                  
13:                  #if (defined SPI1_INIT || defined SPI2_INIT || SPI3_INIT) && (defined PIC32MM)
14:                  
15:                  //spi driver PIC32MM0064/0256, (PIC32MZ - neni dodelano)
16:                  //9/8/2017
17:                  
18:                  //SPI - Master mode
19:                  //SPI muze vyuzivat vice modulu, je-li na jednom SPI kanalu vice zarizeni, musi pouzivat CS signal
20:                  //fce spi_Exchange provede zapis dat SPI (nebo zapis i cteni, je-li zadany Rx buffer)
21:                  //data jsou v tx_bufferu, delka len
22:                  //volajici musi pockat na used=0
23:                  //napr:
24:                  //while(spi_getUsed(0)==1){ doEvents(); }
25:                  //spi_setUsed(0, 1)
26:                  //setCSpin(active)
27:                  //setDCPin(DATA)
28:                  //spi_Exchange(0, ... , &sendFinish)
29:                  //return
30:                  
31:                  //void sendFinish() {
32:                  //setCSPin(deactive)
33:                  //spi_setUsed(0, 0) }
34:                  
35:                  
36:                  
37:                  #ifdef PIC32MM
38:                  
39:                  #define     SPI_FIFO_SIZE               16     //fifo size [bytes]
40:                  
41:                  #ifdef PIC32MM0064
42:                  #define     SPI1_DISABLE_TxINTERRUPT    IEC0CLR=0x00200000
43:                  #define     SPI1_ENABLE_TxINTERRUPT     IEC0SET=0x00200000
44:                  #define     SPI2_DISABLE_TxINTERRUPT    IEC1CLR=0x00000040
45:                  #define     SPI2_ENABLE_TxINTERRUPT     IEC1SET=0x00000040
46:                  #endif
47:                  
48:                  #ifdef PIC32MM0256
49:                  #define     SPI1_DISABLE_TxINTERRUPT    IEC1CLR=0x00000400
50:                  #define     SPI1_ENABLE_TxINTERRUPT     IEC1SET=0x00000400
51:                  #define     SPI2_DISABLE_TxINTERRUPT    IEC1CLR=0x00002000
52:                  #define     SPI2_ENABLE_TxINTERRUPT     IEC1SET=0x00002000
53:                  #define     SPI3_DISABLE_TxINTERRUPT    IEC1CLR=0x00010000
54:                  #define     SPI3_ENABLE_TxINTERRUPT     IEC1SET=0x00010000
55:                  #endif
56:                  
57:                  //local var
58:                  void (*_finish)(int);
59:                  
60:                  SPIControl s1={ NULL, NULL, NULL, NULL, &SPI1BUF, 0, 0, 0, 0, 0, 0 };
61:                  SPIControl s2={ NULL, NULL, NULL, NULL, &SPI2BUF, 0, 0, 0, 0, 0, 0 };   
62:                  SPIControl s3={ NULL, NULL, NULL, NULL, &SPI3BUF, 0, 0, 0, 0, 0, 0 }; 
63:                  SPIControl* controlStruct[]={&s1, &s2, &s3};
64:                  
65:                  //local void
66:                  static void clearRxFifo(int index);
67:                  
68:                  void spi_init()
69:                  {
9D00E098      4FF5   ADDIU SP, SP, -24
9D00E09A      CBE5   SW RA, 20(SP)
9D00E09C      CBC4   SW S8, 16(SP)
9D00E09E      0FDD   MOVE S8, SP
70:                      
71:                  #ifdef SPI1_INIT
72:                      
73:                      SPI1CON = 0;                    // Stops and resets the SPI1.
74:                      clearRxFifo(0);
75:                      
76:                  #ifdef PIC32MM0064  
77:                      // disable all interrupts IEC0.20 - SPI1Error, 21 - SPI1 TRN, 22 - SPI1 REC 
78:                      IEC0CLR=0x00700000;
79:                      // clear any existing event
80:                      IFS0CLR=0x00700000;
81:                      
82:                      //SPI1 Tx, Rx, Err, Prior:1, SubPrior:0
83:                      IPC5bits.SPI1TXIP = 1;                  //Tx prior
84:                      IPC5bits.SPI1TXIS = 0;                  //Tx subprior
85:                      IPC5bits.SPI1EIP = 1;                   //Err prior
86:                      IPC5bits.SPI1EIS = 0;                   //Err subprior
87:                      IPC5bits.SPI1RXIP = 1;                  //Rx prior
88:                      IPC5bits.SPI1RXIS = 0;                  //Rx subprior
89:                  #endif  
90:                      
91:                  #ifdef PIC32MM0256   
92:                      IEC1bits.SPI1EIE=0;
93:                      IEC1bits.SPI1RXIE=0;
94:                      IEC1bits.SPI1TXIE=0;
95:                      
96:                      IFS1bits.SPI1EIF=0;
97:                      IFS1bits.SPI1RXIF=0;
98:                      IFS1bits.SPI1TXIF=0;
99:                      
100:                     IPC10bits.SPI1TXIP = 1;
101:                     IPC10bits.SPI1TXIS = 0;
102:                     IPC10bits.SPI1EIP = 1;
103:                     IPC10bits.SPI1EIS = 0;
104:                     IPC10bits.SPI1RXIP = 1;
105:                     IPC10bits.SPI1RXIS = 0;
106:                 #endif
107:                     
108:                     // FRMERR disabled; 
109:                     SPI1STAT = 0x0;
110:                     // SPI1BRG 10; 
111:                     SPI1BRG = 0x0;          //0x1... pri 8MHz
112:                     // AUDMONO disabled; AUDEN disabled; SPITUREN disabled; FRMERREN disabled; IGNROV disabled; SPISGNEXT disabled; SPIROVEN disabled; AUDMOD disabled; IGNTUR disabled; 
113:                     SPI1CON2 = 0x0;
114:                     
115:                     //buffer Enhanced, Rx pin I/O port, FrameSync disable, 8-bit data
116:                     // MCLKSEL PBCLK; DISSDO disabled; SRXISEL Last Word is Read; CKP Idle:Low, Active:High; FRMEN disabled; FRMSYPW One-Clock; SSEN disabled; FRMCNT 1; MSSEN disabled; MSTEN Master; MODE16 disabled; FRMPOL disabled; SMP Middle; SIDL disabled; FRMSYNC disabled; CKE Idle to Active; MODE32 disabled; SPIFE Frame Sync pulse precedes; STXISEL Complete; DISSDI disabled; ON enabled; ENHBUF enabled; 
117:                     SPI1CON = 0x18130;      //0x18130
118:                     
119:                 #endif
120:                     
121:                 #ifdef SPI2_INIT
122:                 
123:                     SPI2CON = 0;                    // Stops and resets the SPI2.
9D00E0A0  41A2BF81   LUI V0, 0xBF81
9D00E0A2  BF81F802   LDC1 F28, -2046(AT)
9D00E0A4  F8028200   SW ZERO, -32256(V0)
124:                     clearRxFifo(1);
9D00E0A8      EE01   LI A0, 1
9D00E0AA  7680755A   JALS clearRxFifo
9D00E0AC  755A0C00   JALS 0x9AB41800
9D00E0AE      0C00   NOP
125:                     
126:                 #ifdef PIC32MM0064  
127:                     
128:                     // disable all interrupts IEC0.20 - SPI1Error, 21 - SPI1 TRN, 22 - SPI1 REC 
129:                     IEC1CLR=0x000000E0;
130:                     // clear any existing event
131:                     IFS1CLR=0x000000E0;
132:                     
133:                     //SPI1 Tx, Rx, Err, Prior:1, SubPrior:0
134:                     IPC9bits.SPI2TXIP = 1;                  //Tx prior
135:                     IPC9bits.SPI2TXIS = 0;                  //Tx subprior
136:                     IPC9bits.SPI2EIP = 1;                   //Err prior
137:                     IPC9bits.SPI2EIS = 0;                   //Err subprior
138:                     IPC9bits.SPI2RXIP = 1;                  //Rx prior
139:                     IPC9bits.SPI2RXIS = 0;                  //Rx subprior
140:                 #endif    
141:                     
142:                 #ifdef PIC32MM0256  
143:                     IEC1bits.SPI2EIE=0;
9D00E0B0  41A3BF81   LUI V1, 0xBF81
9D00E0B2  BF81FC43   LDC1 F28, -957(AT)
9D00E0B4  FC43F0D0   LW V0, -3888(V1)
9D00E0B6  F0D00040   JALX 0x9B400100
9D00E0B8  0040630C   INS V0, ZERO, 12, 1
9D00E0BC  F843F0D0   SW V0, -3888(V1)
9D00E0BE  F0D041A3   JALX 0x9B41068C
144:                     IEC1bits.SPI2RXIE=0;
9D00E0C0  41A3BF81   LUI V1, 0xBF81
9D00E0C2  BF81FC43   LDC1 F28, -957(AT)
9D00E0C4  FC43F0D0   LW V0, -3888(V1)
9D00E0C6  F0D00040   JALX 0x9B400100
9D00E0C8  0040738C   INS V0, ZERO, 14, 1
9D00E0CA  738CF843   XORI GP, T4, -1981
9D00E0CC  F843F0D0   SW V0, -3888(V1)
9D00E0CE  F0D041A3   JALX 0x9B41068C
145:                     IEC1bits.SPI2TXIE=0;
9D00E0D0  41A3BF81   LUI V1, 0xBF81
9D00E0D2  BF81FC43   LDC1 F28, -957(AT)
9D00E0D4  FC43F0D0   LW V0, -3888(V1)
9D00E0D6  F0D00040   JALX 0x9B400100
9D00E0D8  00406B4C   INS V0, ZERO, 13, 1
9D00E0DA      6B4C   LW A2, 48(A0)
9D00E0DC  F843F0D0   SW V0, -3888(V1)
9D00E0DE  F0D041A3   JALX 0x9B41068C
146:                     
147:                     IFS1bits.SPI2EIF=0;
9D00E0E0  41A3BF81   LUI V1, 0xBF81
9D00E0E2  BF81FC43   LDC1 F28, -957(AT)
9D00E0E4  FC43F050   LW V0, -4016(V1)
9D00E0E6  F0500040   JALX 0x99400100
9D00E0E8  0040630C   INS V0, ZERO, 12, 1
9D00E0EC  F843F050   SW V0, -4016(V1)
9D00E0EE  F05041A3   JALX 0x9941068C
148:                     IFS1bits.SPI2RXIF=0;
9D00E0F0  41A3BF81   LUI V1, 0xBF81
9D00E0F2  BF81FC43   LDC1 F28, -957(AT)
9D00E0F4  FC43F050   LW V0, -4016(V1)
9D00E0F6  F0500040   JALX 0x99400100
9D00E0F8  0040738C   INS V0, ZERO, 14, 1
9D00E0FA  738CF843   XORI GP, T4, -1981
9D00E0FC  F843F050   SW V0, -4016(V1)
9D00E0FE  F05041A3   JALX 0x9941068C
149:                     IFS1bits.SPI2TXIF=0;
9D00E100  41A3BF81   LUI V1, 0xBF81
9D00E102  BF81FC43   LDC1 F28, -957(AT)
9D00E104  FC43F050   LW V0, -4016(V1)
9D00E106  F0500040   JALX 0x99400100
9D00E108  00406B4C   INS V0, ZERO, 13, 1
9D00E10A      6B4C   LW A2, 48(A0)
9D00E10C  F843F050   SW V0, -4016(V1)
9D00E10E  F05041A3   JALX 0x9941068C
150:                     
151:                     IPC11bits.SPI2TXIP = 1;
9D00E110  41A3BF81   LUI V1, 0xBF81
9D00E112  BF81FC43   LDC1 F28, -957(AT)
9D00E114  FC43F1F0   LW V0, -3600(V1)
9D00E116  F1F0EE01   JALX 0x9FC3B804
9D00E118      EE01   LI A0, 1
9D00E11A  0044628C   INS V0, A0, 10, 3
9D00E11E  F843F1F0   SW V0, -3600(V1)
9D00E120  F1F041A3   JALX 0x9FC1068C
152:                     IPC11bits.SPI2TXIS = 0;
9D00E122  41A3BF81   LUI V1, 0xBF81
9D00E124  BF81FC43   LDC1 F28, -957(AT)
9D00E126  FC43F1F0   LW V0, -3600(V1)
9D00E128  F1F00040   JALX 0x9FC00100
9D00E12A  00404A0C   INS V0, ZERO, 8, 2
9D00E12C      4A0C   LW S0, 48(SP)
9D00E12E  F843F1F0   SW V0, -3600(V1)
9D00E130  F1F041A3   JALX 0x9FC1068C
153:                     IPC11bits.SPI2EIP = 1;
9D00E132  41A3BF81   LUI V1, 0xBF81
9D00E134  BF81FC43   LDC1 F28, -957(AT)
9D00E136  FC43F1F0   LW V0, -3600(V1)
9D00E138  F1F0EE01   JALX 0x9FC3B804
9D00E13A      EE01   LI A0, 1
9D00E13C  0044208C   INS V0, A0, 2, 3
9D00E140  F843F1F0   SW V0, -3600(V1)
9D00E142  F1F041A3   JALX 0x9FC1068C
154:                     IPC11bits.SPI2EIS = 0;
9D00E144  41A3BF81   LUI V1, 0xBF81
9D00E146  BF81FC43   LDC1 F28, -957(AT)
9D00E148  FC43F1F0   LW V0, -3600(V1)
9D00E14A  F1F00040   JALX 0x9FC00100
9D00E14C  0040080C   INS V0, ZERO, 0, 2
9D00E14E      080C   LBU S0, 12(S0)
9D00E150  F843F1F0   SW V0, -3600(V1)
9D00E152  F1F041A3   JALX 0x9FC1068C
155:                     IPC11bits.SPI2RXIP = 1;
9D00E154  41A3BF81   LUI V1, 0xBF81
9D00E156  BF81FC43   LDC1 F28, -957(AT)
9D00E158  FC43F1F0   LW V0, -3600(V1)
9D00E15A  F1F0EE01   JALX 0x9FC3B804
9D00E15C      EE01   LI A0, 1
9D00E15E  0044A48C   INS V0, A0, 18, 3
9D00E162  F843F1F0   SW V0, -3600(V1)
9D00E164  F1F041A3   JALX 0x9FC1068C
156:                     IPC11bits.SPI2RXIS = 0;
9D00E166  41A3BF81   LUI V1, 0xBF81
9D00E168  BF81FC43   LDC1 F28, -957(AT)
9D00E16A  FC43F1F0   LW V0, -3600(V1)
9D00E16C  F1F00040   JALX 0x9FC00100
9D00E16E  00408C0C   INS V0, ZERO, 16, 2
9D00E170      8C0C   BEQZ S0, 0x9D00E18A
9D00E172  F843F1F0   SW V0, -3600(V1)
9D00E174  F1F041A2   JALX 0x9FC10688
157:                 #endif  
158:                     
159:                     // FRMERR disabled; 
160:                     SPI2STAT = 0x0;
9D00E176  41A2BF81   LUI V0, 0xBF81
9D00E178  BF81F802   LDC1 F28, -2046(AT)
9D00E17A  F8028210   SW ZERO, -32240(V0)
161:                     // SPI1BRG 10; 
162:                     SPI2BRG = 0x0; //0x0;          //0xA, 0x1... pri 8MHz
9D00E17E  41A2BF81   LUI V0, 0xBF81
9D00E180  BF81F802   LDC1 F28, -2046(AT)
9D00E182  F8028230   SW ZERO, -32208(V0)
163:                     // AUDMONO disabled; AUDEN disabled; SPITUREN disabled; FRMERREN disabled; IGNROV disabled; SPISGNEXT disabled; SPIROVEN disabled; AUDMOD disabled; IGNTUR disabled; 
164:                     SPI2CON2 = 0x0;
9D00E186  41A2BF81   LUI V0, 0xBF81
9D00E188  BF81F802   LDC1 F28, -2046(AT)
9D00E18A  F8028240   SW ZERO, -32192(V0)
165:                     
166:                     //buffer Enhanced, Rx pin I/O port, FrameSync disable, 8-bit data
167:                     // MCLKSEL PBCLK; DISSDO disabled; SRXISEL Last Word is Read; CKP Idle:Low, Active:High; FRMEN disabled; FRMSYPW One-Clock; SSEN disabled; FRMCNT 1; MSSEN disabled; MSTEN Master; MODE16 disabled; FRMPOL disabled; SMP Middle; SIDL disabled; FRMSYNC disabled; CKE Idle to Active; MODE32 disabled; SPIFE Frame Sync pulse precedes; STXISEL Complete; DISSDI disabled; ON enabled; ENHBUF enabled; 
168:                     //SPI2CON = 0x00818130;      //SDI pin DISABLE        //0x18130
169:                     SPI2CON = 0x00818120;      //SDI pin ENABLE        //0x18130
9D00E18E  41A2BF81   LUI V0, 0xBF81
9D00E190  BF8141A3   LDC1 F28, 16803(AT)
9D00E192  41A30081   LUI V1, 0x81
9D00E196  50638120   ORI V1, V1, -32480
9D00E19A  F8628200   SW V1, -32256(V0)
170:                     
171:                 #endif    
172:                     
173:                 #ifdef SPI3_INIT
174:                 
175:                     SPI3CON = 0;                    // Stops and resets the SPI2.
176:                     clearRxFifo(2);
177:                     
178:                 #ifdef PIC32MM0064  
179:                 
180:                 #endif    
181:                     
182:                 #ifdef PIC32MM0256  
183:                     IEC1bits.SPI3EIE=0;
184:                     IEC1bits.SPI3RXIE=0;
185:                     IEC1bits.SPI3TXIE=0;
186:                     
187:                     IFS1bits.SPI3EIF=0;
188:                     IFS1bits.SPI3RXIF=0;
189:                     IFS1bits.SPI3TXIF=0;
190:                     
191:                     IPC12bits.SPI3TXIP = 1;
192:                     IPC12bits.SPI3TXIS = 0;
193:                     IPC11bits.SPI3EIP = 1;
194:                     IPC11bits.SPI3EIS = 0;
195:                     IPC12bits.SPI3RXIP = 1;
196:                     IPC12bits.SPI3RXIS = 0;
197:                 #endif  
198:                     
199:                     // FRMERR disabled; 
200:                     SPI3STAT = 0x0;
201:                     // SPI1BRG 10; 
202:                     SPI3BRG = 0x0;          //0xA, 0x1... pri 8MHz
203:                     // AUDMONO disabled; AUDEN disabled; SPITUREN disabled; FRMERREN disabled; IGNROV disabled; SPISGNEXT disabled; SPIROVEN disabled; AUDMOD disabled; IGNTUR disabled; 
204:                     SPI3CON2 = 0x0;
205:                     
206:                     //buffer Enhanced, Rx pin I/O port, FrameSync disable, 8-bit data
207:                     // MCLKSEL PBCLK; DISSDO disabled; SRXISEL Last Word is Read; CKP Idle:Low, Active:High; FRMEN disabled; FRMSYPW One-Clock; SSEN disabled; FRMCNT 1; MSSEN disabled; MSTEN Master; MODE16 disabled; FRMPOL disabled; SMP Middle; SIDL disabled; FRMSYNC disabled; CKE Idle to Active; MODE32 disabled; SPIFE Frame Sync pulse precedes; STXISEL Complete; DISSDI disabled; ON enabled; ENHBUF enabled; 
208:                     SPI3CON = 0x18130;      //0x18130
209:                     
210:                 #endif        
211:                     
212:                 }
9D00E19E      0FBE   MOVE SP, S8
9D00E1A0      4BE5   LW RA, 20(SP)
9D00E1A2      4BC4   LW S8, 16(SP)
9D00E1A4      4C0D   ADDIU SP, SP, 24
9D00E1A6      45BF   JRC RA
213:                 
214:                 char spi_getUsed(int index)
215:                 {
9D00E1A8      4FB0   ADDIU SP, SP, -8
9D00E1AA      CBC1   SW S8, 4(SP)
9D00E1AC      0FDD   MOVE S8, SP
9D00E1AE  F89E0008   SW A0, 8(S8)
216:                     //used nastavuje volajici proces, muze nastavit jakoukoliv hodnotu > -1(SPI_EMPTY)
217:                     //tato hodnota bude pouzita po skonceni prenosu pri volani _finish, volajici proces
218:                     //podle ni muze zjistit, jaky prenos byl ukoncen
219:                     return controlStruct[index]->used;
9D00E1B2  41A28000   LUI V0, 0x8000
9D00E1B6  FC7E0008   LW V1, 8(S8)
9D00E1BA      25B4   SLL V1, V1, 2
9D00E1BC  30420AD8   ADDIU V0, V0, 2776
9D00E1BE      0AD8   LBU A1, 8(A1)
9D00E1C0      0526   ADDU V0, V1, V0
9D00E1C2      6920   LW V0, 0(V0)
9D00E1C4  1442001A   LBU V0, 26(V0)
220:                 }
9D00E1C8      0FBE   MOVE SP, S8
9D00E1CA      4BC1   LW S8, 4(SP)
9D00E1CC      4C05   ADDIU SP, SP, 8
9D00E1CE      45BF   JRC RA
221:                 
222:                 /*
223:                 void spi_setUsed(int index, int val)
224:                 {
225:                     //used nastavuje volajici proces, SPI_STATE.EMPTY nebo SPI_STATE.USED
226:                     controlStruct[index]->used=val;
227:                 }
228:                 */
229:                 
230:                 char spi_Process(char index, char wait)
231:                 {
9D00E1D0      4FF5   ADDIU SP, SP, -24
9D00E1D2      CBE5   SW RA, 20(SP)
9D00E1D4      CBC4   SW S8, 16(SP)
9D00E1D6      0FDD   MOVE S8, SP
9D00E1D8      0C64   MOVE V1, A0
9D00E1DA      0C45   MOVE V0, A1
9D00E1DC  187E0018   SB V1, 24(S8)
9D00E1E0  185E001C   SB V0, 28(S8)
232:                     //vraci SPI_STATE.SENDING=probiha vysilani bufferu, SPI_STATE.FINISHED=vysilani dokonceno
233:                     //nastavuje SPI automaticky
234:                     
235:                     while(1)
236:                     {
237:                         if(controlStruct[index]->process == SPI_STATE.FINISHED)
9D00E1E4  147E0018   LBU V1, 24(S8)
9D00E1E8  41A28000   LUI V0, 0x8000
9D00E1EC      25B4   SLL V1, V1, 2
9D00E1EE  30420AD8   ADDIU V0, V0, 2776
9D00E1F0      0AD8   LBU A1, 8(A1)
9D00E1F2      0526   ADDU V0, V1, V0
9D00E1F4      6920   LW V0, 0(V0)
9D00E1F6  1462001B   LBU V1, 27(V0)
9D00E1F8  001B0C40   SRL ZERO, K1, 1
9D00E1FA      0C40   MOVE V0, ZERO
9D00E1FC  B4430004   BNE V1, V0, 0x9D00E208
9D00E1FE  00040C00   SLL ZERO, A0, 1
9D00E200      0C00   NOP
238:                         {
239:                             return SPI_STATE.FINISHED;
9D00E202      0C40   MOVE V0, ZERO
9D00E204      CC0D   B 0x9D00E220
9D00E206      0C00   NOP
240:                         }
241:                         
242:                         //vysilani neni dokonceno
243:                         if(wait==0) { return SPI_STATE.SENDING; }
9D00E208  145E001C   LBU V0, 28(S8)
9D00E20C  40A20003   BNEZC V0, 0x9D00E216
9D00E210      ED01   LI V0, 1
9D00E212      CC06   B 0x9D00E220
9D00E214      0C00   NOP
244:                         doEvents();
9D00E216  76807F8E   JALS doEvents
9D00E21A      0C00   NOP
245:                     }
9D00E21C      CFE3   B 0x9D00E1E4
9D00E21E      0C00   NOP
246:                     
247:                     return controlStruct[index]->process;
248:                 }
9D00E220      0FBE   MOVE SP, S8
9D00E222      4BE5   LW RA, 20(SP)
9D00E224      4BC4   LW S8, 16(SP)
9D00E226      4C0D   ADDIU SP, SP, 24
9D00E228      45BF   JRC RA
9D00E22A      0C00   NOP
249:                 
250:                 void spi_ExchangeDE(int index, char* txbuff, char* rxbuff, int l)
251:                 {
9D00E22C      4FF5   ADDIU SP, SP, -24
9D00E22E      CBE5   SW RA, 20(SP)
9D00E230      CBC4   SW S8, 16(SP)
9D00E232      0FDD   MOVE S8, SP
9D00E234  F89E0018   SW A0, 24(S8)
9D00E238  F8BE001C   SW A1, 28(S8)
9D00E23C  F8DE0020   SW A2, 32(S8)
9D00E240  F8FE0024   SW A3, 36(S8)
252:                     //pokud probiha vysilani, vola doEvents, ceka na dokonceni
253:                     while(controlStruct[index]->process != SPI_STATE.FINISHED)
9D00E244      CC04   B 0x9D00E24E
9D00E246      0C00   NOP
9D00E24E  41A28000   LUI V0, 0x8000
9D00E252  FC7E0018   LW V1, 24(S8)
9D00E256      25B4   SLL V1, V1, 2
9D00E258  30420AD8   ADDIU V0, V0, 2776
9D00E25A      0AD8   LBU A1, 8(A1)
9D00E25C      0526   ADDU V0, V1, V0
9D00E25E      6920   LW V0, 0(V0)
9D00E260  1462001B   LBU V1, 27(V0)
9D00E262  001B0C40   SRL ZERO, K1, 1
9D00E264      0C40   MOVE V0, ZERO
9D00E266  B443FFEF   BNE V1, V0, 0x9D00E248
9D00E268  FFEF0C00   LW RA, 3072(T7)
9D00E26A      0C00   NOP
254:                     {
255:                         doEvents();
9D00E248  76807F8E   JALS doEvents
9D00E24C      0C00   NOP
256:                     }
257:                     
258:                     spi_Exchange(index, txbuff, rxbuff, l);    
9D00E26C  FC9E0018   LW A0, 24(S8)
9D00E270  FCBE001C   LW A1, 28(S8)
9D00E274  FCDE0020   LW A2, 32(S8)
9D00E278  FCFE0024   LW A3, 36(S8)
9D00E27A  00247680   OR T6, A0, AT
9D00E27C  76807146   JALS spi_Exchange
9D00E27E  71460C00   XORI T2, A2, 3072
9D00E280      0C00   NOP
259:                 }
9D00E282      0FBE   MOVE SP, S8
9D00E284      4BE5   LW RA, 20(SP)
9D00E286      4BC4   LW S8, 16(SP)
9D00E288      4C0D   ADDIU SP, SP, 24
9D00E28A      45BF   JRC RA
260:                 
261:                 void spi_Exchange(int index, char* txbuff, char* rxbuff, int l)
262:                 {
9D00E28C      4FF5   ADDIU SP, SP, -24
9D00E28E      CBE5   SW RA, 20(SP)
9D00E290      CBC4   SW S8, 16(SP)
9D00E292      0FDD   MOVE S8, SP
9D00E294  F89E0018   SW A0, 24(S8)
9D00E298  F8BE001C   SW A1, 28(S8)
9D00E29C  F8DE0020   SW A2, 32(S8)
9D00E2A0  F8FE0024   SW A3, 36(S8)
263:                     //je-li rxbuff=NULL, probiha pouze vysilani, jinak vysilani i prijem
264:                     //void f se vola po ukonceni trasnakce
265:                     
266:                     controlStruct[index]->tx_buffer=txbuff;
9D00E2A4  41A28000   LUI V0, 0x8000
9D00E2A8  FC7E0018   LW V1, 24(S8)
9D00E2AC      25B4   SLL V1, V1, 2
9D00E2AE  30420AD8   ADDIU V0, V0, 2776
9D00E2B0      0AD8   LBU A1, 8(A1)
9D00E2B2      0526   ADDU V0, V1, V0
9D00E2B4      6920   LW V0, 0(V0)
9D00E2B6  FC7E001C   LW V1, 28(S8)
9D00E2B8  001CE9A0   SUB SP, GP, ZERO
9D00E2BA      E9A0   SW V1, 0(V0)
267:                     controlStruct[index]->rx_buffer=rxbuff;
9D00E2BC  41A28000   LUI V0, 0x8000
9D00E2C0  FC7E0018   LW V1, 24(S8)
9D00E2C4      25B4   SLL V1, V1, 2
9D00E2C6  30420AD8   ADDIU V0, V0, 2776
9D00E2C8      0AD8   LBU A1, 8(A1)
9D00E2CA      0526   ADDU V0, V1, V0
9D00E2CC      6920   LW V0, 0(V0)
9D00E2CE  FC7E0020   LW V1, 32(S8)
9D00E2D2      E9A1   SW V1, 4(V0)
268:                     controlStruct[index]->len=l;
9D00E2D4  41A28000   LUI V0, 0x8000
9D00E2D8  FC7E0018   LW V1, 24(S8)
9D00E2DC      25B4   SLL V1, V1, 2
9D00E2DE  30420AD8   ADDIU V0, V0, 2776
9D00E2E0      0AD8   LBU A1, 8(A1)
9D00E2E2      0526   ADDU V0, V1, V0
9D00E2E4      6920   LW V0, 0(V0)
9D00E2E6  FC7E0024   LW V1, 36(S8)
9D00E2EA  00633B3C   SEH V1, V1
9D00E2EC  3B3CA9AA   SH T9, -22102(GP)
9D00E2EE      A9AA   SH V1, 20(V0)
269:                     controlStruct[index]->tx_count=0;
9D00E2F0  41A28000   LUI V0, 0x8000
9D00E2F4  FC7E0018   LW V1, 24(S8)
9D00E2F8      25B4   SLL V1, V1, 2
9D00E2FA  30420AD8   ADDIU V0, V0, 2776
9D00E2FC      0AD8   LBU A1, 8(A1)
9D00E2FE      0526   ADDU V0, V1, V0
9D00E300      6920   LW V0, 0(V0)
9D00E302      A82B   SH S0, 22(V0)
270:                     controlStruct[index]->process=SPI_STATE.SENDING;
9D00E304  41A28000   LUI V0, 0x8000
9D00E308  FC7E0018   LW V1, 24(S8)
9D00E30C      25B4   SLL V1, V1, 2
9D00E30E  30420AD8   ADDIU V0, V0, 2776
9D00E310      0AD8   LBU A1, 8(A1)
9D00E312      0526   ADDU V0, V1, V0
9D00E314      6920   LW V0, 0(V0)
9D00E316      ED81   LI V1, 1
9D00E318  1862001B   SB V1, 27(V0)
271:                     
272:                     if(controlStruct[index]->rx_buffer != NULL)
9D00E31C  41A28000   LUI V0, 0x8000
9D00E320  FC7E0018   LW V1, 24(S8)
9D00E324      25B4   SLL V1, V1, 2
9D00E326  30420AD8   ADDIU V0, V0, 2776
9D00E328      0AD8   LBU A1, 8(A1)
9D00E32A      0526   ADDU V0, V1, V0
9D00E32C      6920   LW V0, 0(V0)
9D00E32E      6921   LW V0, 4(V0)
9D00E330  40E20005   BEQZC V0, 0x9D00E33E
273:                     {
274:                         //vyjme vsechny data z spi_rx_bufferu (a nuluje overflow flag)
275:                         clearRxFifo(index);
9D00E334  FC9E0018   LW A0, 24(S8)
9D00E336  00187680   OR T6, T8, ZERO
9D00E338  7680755A   JALS clearRxFifo
9D00E33A  755A0C00   JALS 0x9AB41800
9D00E33C      0C00   NOP
276:                     }
277:                     
278:                     if(index==0)
9D00E33E  FC5E0018   LW V0, 24(S8)
9D00E342  40E20009   BEQZC V0, 0x9D00E358
279:                     { 
280:                 #ifdef SPI1_INIT        
281:                         spi1_TxInterrupt(); 
282:                 #endif        
283:                     }
284:                     else if(index==1)
9D00E346  FC7E0018   LW V1, 24(S8)
9D00E34A      ED01   LI V0, 1
9D00E34C  B4430004   BNE V1, V0, 0x9D00E358
9D00E34E  00040C00   SLL ZERO, A0, 1
9D00E350      0C00   NOP
285:                     { 
286:                 #ifdef SPI2_INIT             
287:                         spi2_TxInterrupt(); 
9D00E352  76807422   JALS spi2_TxInterrupt
9D00E354  74220C00   JALS 0x98441800
9D00E356      0C00   NOP
288:                 #endif        
289:                     }
290:                     else if (index==2)
291:                     {
292:                 #ifdef SPI3_INIT             
293:                         spi3_TxInterrupt();
294:                 #endif        
295:                     }
296:                 }
9D00E358      0FBE   MOVE SP, S8
9D00E35A      4BE5   LW RA, 20(SP)
9D00E35C      4BC4   LW S8, 16(SP)
9D00E35E      4C0D   ADDIU SP, SP, 24
9D00E360      45BF   JRC RA
9D00E362      0C00   NOP
297:                 
298:                 void spi_ExchangeModeDE(int index, char* txbuff, char* rxbuff, int l, char mode)
299:                 {
9D00E364      4FF1   ADDIU SP, SP, -32
9D00E366      CBE7   SW RA, 28(SP)
9D00E368      CBC6   SW S8, 24(SP)
9D00E36A      0FDD   MOVE S8, SP
9D00E36C  F89E0020   SW A0, 32(S8)
9D00E370  F8BE0024   SW A1, 36(S8)
9D00E374  F8DE0028   SW A2, 40(S8)
9D00E378  F8FE002C   SW A3, 44(S8)
300:                     //pokud probiha vysilani, vola doEvents, ceka na dokonceni
301:                     while(controlStruct[index]->process != SPI_STATE.FINISHED)
9D00E37C      CC04   B 0x9D00E386
9D00E37E      0C00   NOP
9D00E386  41A28000   LUI V0, 0x8000
9D00E38A  FC7E0020   LW V1, 32(S8)
9D00E38E      25B4   SLL V1, V1, 2
9D00E390  30420AD8   ADDIU V0, V0, 2776
9D00E392      0AD8   LBU A1, 8(A1)
9D00E394      0526   ADDU V0, V1, V0
9D00E396      6920   LW V0, 0(V0)
9D00E398  1462001B   LBU V1, 27(V0)
9D00E39A  001B0C40   SRL ZERO, K1, 1
9D00E39C      0C40   MOVE V0, ZERO
9D00E39E  B443FFEF   BNE V1, V0, 0x9D00E380
9D00E3A0  FFEF0C00   LW RA, 3072(T7)
9D00E3A2      0C00   NOP
302:                     {
303:                         doEvents();
9D00E380  76807F8E   JALS doEvents
9D00E384      0C00   NOP
304:                     }
305:                     
306:                     spi_ExchangeMode(index, txbuff, rxbuff, l, mode);
9D00E3A4  145E0030   LBU V0, 48(S8)
9D00E3A8      C844   SW V0, 16(SP)
9D00E3AA  FC9E0020   LW A0, 32(S8)
9D00E3AE  FCBE0024   LW A1, 36(S8)
9D00E3B2  FCDE0028   LW A2, 40(S8)
9D00E3B6  FCFE002C   LW A3, 44(S8)
9D00E3B8  002C7680   OR T6, T4, AT
9D00E3BA  768071E6   JALS spi_ExchangeMode
9D00E3BC  71E60C00   XORI T7, A2, 3072
9D00E3BE      0C00   NOP
307:                 }
9D00E3C0      0FBE   MOVE SP, S8
9D00E3C2      4BE7   LW RA, 28(SP)
9D00E3C4      4BC6   LW S8, 24(SP)
9D00E3C6      4C11   ADDIU SP, SP, 32
9D00E3C8      45BF   JRC RA
9D00E3CA      0C00   NOP
308:                 
309:                 void spi_ExchangeMode(int index, char* txbuff, char* rxbuff, int l, char mode)
310:                 {
9D00E3CC      4FF5   ADDIU SP, SP, -24
9D00E3CE      CBE5   SW RA, 20(SP)
9D00E3D0      CBC4   SW S8, 16(SP)
9D00E3D2      0FDD   MOVE S8, SP
9D00E3D4  F89E0018   SW A0, 24(S8)
9D00E3D8  F8BE001C   SW A1, 28(S8)
9D00E3DC  F8DE0020   SW A2, 32(S8)
9D00E3E0  F8FE0024   SW A3, 36(S8)
311:                     //je-li rxbuff=NULL, probiha pouze vysilani, jinak vysilani i prijem
312:                     
313:                     
314:                     controlStruct[index]->tx_buffer=txbuff;
9D00E3E4  41A28000   LUI V0, 0x8000
9D00E3E8  FC7E0018   LW V1, 24(S8)
9D00E3EC      25B4   SLL V1, V1, 2
9D00E3EE  30420AD8   ADDIU V0, V0, 2776
9D00E3F0      0AD8   LBU A1, 8(A1)
9D00E3F2      0526   ADDU V0, V1, V0
9D00E3F4      6920   LW V0, 0(V0)
9D00E3F6  FC7E001C   LW V1, 28(S8)
9D00E3F8  001CE9A0   SUB SP, GP, ZERO
9D00E3FA      E9A0   SW V1, 0(V0)
315:                     controlStruct[index]->rx_buffer=rxbuff;
9D00E3FC  41A28000   LUI V0, 0x8000
9D00E400  FC7E0018   LW V1, 24(S8)
9D00E404      25B4   SLL V1, V1, 2
9D00E406  30420AD8   ADDIU V0, V0, 2776
9D00E408      0AD8   LBU A1, 8(A1)
9D00E40A      0526   ADDU V0, V1, V0
9D00E40C      6920   LW V0, 0(V0)
9D00E40E  FC7E0020   LW V1, 32(S8)
9D00E412      E9A1   SW V1, 4(V0)
316:                     controlStruct[index]->len=l;
9D00E414  41A28000   LUI V0, 0x8000
9D00E418  FC7E0018   LW V1, 24(S8)
9D00E41C      25B4   SLL V1, V1, 2
9D00E41E  30420AD8   ADDIU V0, V0, 2776
9D00E420      0AD8   LBU A1, 8(A1)
9D00E422      0526   ADDU V0, V1, V0
9D00E424      6920   LW V0, 0(V0)
9D00E426  FC7E0024   LW V1, 36(S8)
9D00E42A  00633B3C   SEH V1, V1
9D00E42C  3B3CA9AA   SH T9, -22102(GP)
9D00E42E      A9AA   SH V1, 20(V0)
317:                     controlStruct[index]->tx_count=0;
9D00E430  41A28000   LUI V0, 0x8000
9D00E434  FC7E0018   LW V1, 24(S8)
9D00E438      25B4   SLL V1, V1, 2
9D00E43A  30420AD8   ADDIU V0, V0, 2776
9D00E43C      0AD8   LBU A1, 8(A1)
9D00E43E      0526   ADDU V0, V1, V0
9D00E440      6920   LW V0, 0(V0)
9D00E442      A82B   SH S0, 22(V0)
318:                     controlStruct[index]->mode_count=0;
9D00E444  41A28000   LUI V0, 0x8000
9D00E448  FC7E0018   LW V1, 24(S8)
9D00E44C      25B4   SLL V1, V1, 2
9D00E44E  30420AD8   ADDIU V0, V0, 2776
9D00E450      0AD8   LBU A1, 8(A1)
9D00E452      0526   ADDU V0, V1, V0
9D00E454      6920   LW V0, 0(V0)
9D00E456  18020018   SB ZERO, 24(V0)
319:                     controlStruct[index]->mode=mode;
9D00E45A  41A28000   LUI V0, 0x8000
9D00E45E  FC7E0018   LW V1, 24(S8)
9D00E462      25B4   SLL V1, V1, 2
9D00E464  30420AD8   ADDIU V0, V0, 2776
9D00E466      0AD8   LBU A1, 8(A1)
9D00E468      0526   ADDU V0, V1, V0
9D00E46A      6920   LW V0, 0(V0)
9D00E46C  147E0028   LBU V1, 40(S8)
9D00E470  18620019   SB V1, 25(V0)
320:                     controlStruct[index]->process=SPI_STATE.SENDING;
9D00E474  41A28000   LUI V0, 0x8000
9D00E478  FC7E0018   LW V1, 24(S8)
9D00E47C      25B4   SLL V1, V1, 2
9D00E47E  30420AD8   ADDIU V0, V0, 2776
9D00E480      0AD8   LBU A1, 8(A1)
9D00E482      0526   ADDU V0, V1, V0
9D00E484      6920   LW V0, 0(V0)
9D00E486      ED81   LI V1, 1
9D00E488  1862001B   SB V1, 27(V0)
321:                     
322:                     if(controlStruct[index]->rx_buffer != NULL)
9D00E48C  41A28000   LUI V0, 0x8000
9D00E490  FC7E0018   LW V1, 24(S8)
9D00E494      25B4   SLL V1, V1, 2
9D00E496  30420AD8   ADDIU V0, V0, 2776
9D00E498      0AD8   LBU A1, 8(A1)
9D00E49A      0526   ADDU V0, V1, V0
9D00E49C      6920   LW V0, 0(V0)
9D00E49E      6921   LW V0, 4(V0)
9D00E4A0  40E20005   BEQZC V0, 0x9D00E4AE
323:                     {
324:                         //vyjme vsechny data z spi_rx_bufferu
325:                         clearRxFifo(index);
9D00E4A4  FC9E0018   LW A0, 24(S8)
9D00E4A6  00187680   OR T6, T8, ZERO
9D00E4A8  7680755A   JALS clearRxFifo
9D00E4AA  755A0C00   JALS 0x9AB41800
9D00E4AC      0C00   NOP
326:                     }
327:                     
328:                     if(index==0)
9D00E4AE  FC5E0018   LW V0, 24(S8)
9D00E4B2  40E20009   BEQZC V0, 0x9D00E4C8
329:                     { 
330:                 #ifdef SPI1_INIT        
331:                         spi1_TxInterrupt(); 
332:                 #endif        
333:                     }
334:                     else if(index==1)
9D00E4B6  FC7E0018   LW V1, 24(S8)
9D00E4BA      ED01   LI V0, 1
9D00E4BC  B4430004   BNE V1, V0, 0x9D00E4C8
9D00E4BE  00040C00   SLL ZERO, A0, 1
9D00E4C0      0C00   NOP
335:                     { 
336:                 #ifdef SPI2_INIT             
337:                         spi2_TxInterrupt(); 
9D00E4C2  76807422   JALS spi2_TxInterrupt
9D00E4C4  74220C00   JALS 0x98441800
9D00E4C6      0C00   NOP
338:                 #endif        
339:                     }
340:                     else if (index==2)
341:                     {
342:                 #ifdef SPI3_INIT             
343:                         spi3_TxInterrupt();
344:                 #endif        
345:                     }
346:                 }
9D00E4C8      0FBE   MOVE SP, S8
9D00E4CA      4BE5   LW RA, 20(SP)
9D00E4CC      4BC4   LW S8, 16(SP)
9D00E4CE      4C0D   ADDIU SP, SP, 24
9D00E4D0      45BF   JRC RA
9D00E4D2      0C00   NOP
347:                 
348:                 void spi_Free(int index)
349:                 {
9D00E4D4      4FF5   ADDIU SP, SP, -24
9D00E4D6      CBE5   SW RA, 20(SP)
9D00E4D8      CBC4   SW S8, 16(SP)
9D00E4DA      0FDD   MOVE S8, SP
9D00E4DC  F89E0018   SW A0, 24(S8)
350:                     //pokud jeste probiha vysilani dat
351:                     //ceka na dokonceni, protoze po spi_free se vetsinou vola setCS>1
352:                     //takze by data nebyla prijata 
353:                     
354:                     while(controlStruct[index]->process == SPI_STATE.SENDING)
9D00E4E0      CC04   B 0x9D00E4EA
9D00E4E2      0C00   NOP
9D00E4EA  41A28000   LUI V0, 0x8000
9D00E4EE  FC7E0018   LW V1, 24(S8)
9D00E4F2      25B4   SLL V1, V1, 2
9D00E4F4  30420AD8   ADDIU V0, V0, 2776
9D00E4F6      0AD8   LBU A1, 8(A1)
9D00E4F8      0526   ADDU V0, V1, V0
9D00E4FA      6920   LW V0, 0(V0)
9D00E4FC  1462001B   LBU V1, 27(V0)
9D00E500      ED01   LI V0, 1
9D00E502  9443FFEF   BEQ V1, V0, 0x9D00E4E4
9D00E504  FFEF0C00   LW RA, 3072(T7)
9D00E506      0C00   NOP
355:                     {
356:                         //jeste probiha vysilani
357:                         doEvents();
9D00E4E4  76807F8E   JALS doEvents
9D00E4E8      0C00   NOP
358:                     }
359:                     controlStruct[index]->used=SPI_STATE.EMPTY;
9D00E508  41A28000   LUI V0, 0x8000
9D00E50C  FC7E0018   LW V1, 24(S8)
9D00E510      25B4   SLL V1, V1, 2
9D00E512  30420AD8   ADDIU V0, V0, 2776
9D00E514      0AD8   LBU A1, 8(A1)
9D00E516      0526   ADDU V0, V1, V0
9D00E518      6920   LW V0, 0(V0)
9D00E51A      0C60   MOVE V1, ZERO
9D00E51C  1862001A   SB V1, 26(V0)
360:                 }
9D00E520      0FBE   MOVE SP, S8
9D00E522      4BE5   LW RA, 20(SP)
9D00E524      4BC4   LW S8, 16(SP)
9D00E526      4C0D   ADDIU SP, SP, 24
9D00E528      45BF   JRC RA
9D00E52A      0C00   NOP
361:                 
362:                 //char index
363:                 char spi_Use(char index, char wait, void* finish, void* event)
364:                 {
9D00E52C      4FF5   ADDIU SP, SP, -24
9D00E52E      CBE5   SW RA, 20(SP)
9D00E530      CBC4   SW S8, 16(SP)
9D00E532      0FDD   MOVE S8, SP
9D00E534      0C64   MOVE V1, A0
9D00E536      0C45   MOVE V0, A1
9D00E538  F8DE0020   SW A2, 32(S8)
9D00E53C  F8FE0024   SW A3, 36(S8)
9D00E540  187E0018   SB V1, 24(S8)
9D00E544  185E001C   SB V0, 28(S8)
365:                     //je-li spi volne, nastavi SPI_STATE.USED a vraci 1 (true)
366:                     //neni-li volne 
367:                     //a) pri wait==1 ceka (doEvents) na uvolneni
368:                     //b) pri wait==0 vraci 0 (obsazeno jinym procesem)
369:                     
370:                     while(1)
371:                     {
372:                         if((controlStruct[index]->used == SPI_STATE.EMPTY) && (controlStruct[index]->process == SPI_STATE.FINISHED))
9D00E548  147E0018   LBU V1, 24(S8)
9D00E54C  41A28000   LUI V0, 0x8000
9D00E550      25B4   SLL V1, V1, 2
9D00E552  30420AD8   ADDIU V0, V0, 2776
9D00E554      0AD8   LBU A1, 8(A1)
9D00E556      0526   ADDU V0, V1, V0
9D00E558      6920   LW V0, 0(V0)
9D00E55A  1462001A   LBU V1, 26(V0)
9D00E55C  001A0C40   SRL ZERO, K0, 1
9D00E55E      0C40   MOVE V0, ZERO
9D00E560  B4430037   BNE V1, V0, 0x9D00E5D2
9D00E562  00370C00   SLL AT, S7, 1
9D00E564      0C00   NOP
9D00E566  147E0018   LBU V1, 24(S8)
9D00E56A  41A28000   LUI V0, 0x8000
9D00E56E      25B4   SLL V1, V1, 2
9D00E570  30420AD8   ADDIU V0, V0, 2776
9D00E572      0AD8   LBU A1, 8(A1)
9D00E574      0526   ADDU V0, V1, V0
9D00E576      6920   LW V0, 0(V0)
9D00E578  1462001B   LBU V1, 27(V0)
9D00E57A  001B0C40   SRL ZERO, K1, 1
9D00E57C      0C40   MOVE V0, ZERO
9D00E57E  B4430028   BNE V1, V0, 0x9D00E5D2
9D00E580  00280C00   SLL AT, T0, 1
9D00E582      0C00   NOP
373:                         {
374:                             controlStruct[index]->used=SPI_STATE.USED;
9D00E584  147E0018   LBU V1, 24(S8)
9D00E588  41A28000   LUI V0, 0x8000
9D00E58C      25B4   SLL V1, V1, 2
9D00E58E  30420AD8   ADDIU V0, V0, 2776
9D00E590      0AD8   LBU A1, 8(A1)
9D00E592      0526   ADDU V0, V1, V0
9D00E594      6920   LW V0, 0(V0)
9D00E596      ED81   LI V1, 1
9D00E598  1862001A   SB V1, 26(V0)
375:                             controlStruct[index]->finishFn=finish;
9D00E59C  147E0018   LBU V1, 24(S8)
9D00E5A0  41A28000   LUI V0, 0x8000
9D00E5A4      25B4   SLL V1, V1, 2
9D00E5A6  30420AD8   ADDIU V0, V0, 2776
9D00E5A8      0AD8   LBU A1, 8(A1)
9D00E5AA      0526   ADDU V0, V1, V0
9D00E5AC      6920   LW V0, 0(V0)
9D00E5AE  FC7E0020   LW V1, 32(S8)
9D00E5B2      E9A2   SW V1, 8(V0)
376:                             controlStruct[index]->eventFn=event;
9D00E5B4  147E0018   LBU V1, 24(S8)
9D00E5B8  41A28000   LUI V0, 0x8000
9D00E5BC      25B4   SLL V1, V1, 2
9D00E5BE  30420AD8   ADDIU V0, V0, 2776
9D00E5C0      0AD8   LBU A1, 8(A1)
9D00E5C2      0526   ADDU V0, V1, V0
9D00E5C4      6920   LW V0, 0(V0)
9D00E5C6  FC7E0024   LW V1, 36(S8)
9D00E5CA      E9A3   SW V1, 12(V0)
377:                             return 1;
9D00E5CC      ED01   LI V0, 1
9D00E5CE      CC0D   B 0x9D00E5EA
9D00E5D0      0C00   NOP
378:                         }
379:                         
380:                         if(wait==0) { return 0; }
9D00E5D2  145E001C   LBU V0, 28(S8)
9D00E5D6  40A20003   BNEZC V0, 0x9D00E5E0
9D00E5D8  00030C40   SRL ZERO, V1, 1
9D00E5DA      0C40   MOVE V0, ZERO
9D00E5DC      CC06   B 0x9D00E5EA
9D00E5DE      0C00   NOP
381:                         
382:                         doEvents();
9D00E5E0  76807F8E   JALS doEvents
9D00E5E4      0C00   NOP
383:                     }
9D00E5E6      CFB0   B 0x9D00E548
9D00E5E8      0C00   NOP
384:                 }
9D00E5EA      0FBE   MOVE SP, S8
9D00E5EC      4BE5   LW RA, 20(SP)
9D00E5EE      4BC4   LW S8, 16(SP)
9D00E5F0      4C0D   ADDIU SP, SP, 24
9D00E5F2      45BF   JRC RA
385:                 
386:                 volatile int* spi_getHwBuffer(char index)
387:                 {
9D00E5F4      4FB0   ADDIU SP, SP, -8
9D00E5F6      CBC1   SW S8, 4(SP)
9D00E5F8      0FDD   MOVE S8, SP
9D00E5FA      0C44   MOVE V0, A0
9D00E5FC  185E0008   SB V0, 8(S8)
388:                     return controlStruct[index]->hw_buffer;
9D00E600  147E0008   LBU V1, 8(S8)
9D00E604  41A28000   LUI V0, 0x8000
9D00E608      25B4   SLL V1, V1, 2
9D00E60A  30420AD8   ADDIU V0, V0, 2776
9D00E60C      0AD8   LBU A1, 8(A1)
9D00E60E      0526   ADDU V0, V1, V0
9D00E610      6920   LW V0, 0(V0)
9D00E612      6924   LW V0, 16(V0)
389:                 }
9D00E614      0FBE   MOVE SP, S8
9D00E616      4BC1   LW S8, 4(SP)
9D00E618      4C05   ADDIU SP, SP, 8
9D00E61A      45BF   JRC RA
390:                 
391:                 void spi_setBusMode(char index, char mode)
392:                 {
9D00E61C      4FB0   ADDIU SP, SP, -8
9D00E61E      CBC1   SW S8, 4(SP)
9D00E620      0FDD   MOVE S8, SP
9D00E622      0C64   MOVE V1, A0
9D00E624      0C45   MOVE V0, A1
9D00E626  187E0008   SB V1, 8(S8)
9D00E62A  185E000C   SB V0, 12(S8)
393:                     if(index==0)
9D00E62E  145E0008   LBU V0, 8(S8)
9D00E632  40A20044   BNEZC V0, 0x9D00E6BE
394:                     {
395:                         if (mode==BUS_MODE._16bit) { SPI1CONbits.MODE16=1; SPI1CONbits.MODE32=0;}
9D00E636      ED01   LI V0, 1
9D00E638  147E000C   LBU V1, 12(S8)
9D00E63C  B4430014   BNE V1, V0, 0x9D00E668
9D00E63E  00140C00   SLL ZERO, S4, 1
9D00E640      0C00   NOP
9D00E642  41A3BF81   LUI V1, 0xBF81
9D00E644  BF81FC43   LDC1 F28, -957(AT)
9D00E646  FC438100   LW V0, -32512(V1)
9D00E64A      EE01   LI A0, 1
9D00E64C  0044528C   INS V0, A0, 10, 1
9D00E64E  528CF843   ORI S4, T4, -1981
9D00E650  F8438100   SW V0, -32512(V1)
9D00E654  41A3BF81   LUI V1, 0xBF81
9D00E656  BF81FC43   LDC1 F28, -957(AT)
9D00E658  FC438100   LW V0, -32512(V1)
9D00E65C  00405ACC   INS V0, ZERO, 11, 1
9D00E660  F8438100   SW V0, -32512(V1)
9D00E664      CCBE   B 0x9D00E7E2
9D00E666      0C00   NOP
396:                         else if (mode==BUS_MODE._32bit) { SPI1CONbits.MODE16=0; SPI1CONbits.MODE32=1;}
9D00E668      ED02   LI V0, 2
9D00E66A  147E000C   LBU V1, 12(S8)
9D00E66E  B4430014   BNE V1, V0, 0x9D00E69A
9D00E670  00140C00   SLL ZERO, S4, 1
9D00E672      0C00   NOP
9D00E674  41A3BF81   LUI V1, 0xBF81
9D00E676  BF81FC43   LDC1 F28, -957(AT)
9D00E678  FC438100   LW V0, -32512(V1)
9D00E67C  0040528C   INS V0, ZERO, 10, 1
9D00E67E  528CF843   ORI S4, T4, -1981
9D00E680  F8438100   SW V0, -32512(V1)
9D00E684  41A3BF81   LUI V1, 0xBF81
9D00E686  BF81FC43   LDC1 F28, -957(AT)
9D00E688  FC438100   LW V0, -32512(V1)
9D00E68C      EE01   LI A0, 1
9D00E68E  00445ACC   INS V0, A0, 11, 1
9D00E692  F8438100   SW V0, -32512(V1)
9D00E696      CCA5   B 0x9D00E7E2
9D00E698      0C00   NOP
397:                         else { SPI1CONbits.MODE16=0; SPI1CONbits.MODE32=0;}
9D00E69A  41A3BF81   LUI V1, 0xBF81
9D00E69C  BF81FC43   LDC1 F28, -957(AT)
9D00E69E  FC438100   LW V0, -32512(V1)
9D00E6A2  0040528C   INS V0, ZERO, 10, 1
9D00E6A4  528CF843   ORI S4, T4, -1981
9D00E6A6  F8438100   SW V0, -32512(V1)
9D00E6AA  41A3BF81   LUI V1, 0xBF81
9D00E6AC  BF81FC43   LDC1 F28, -957(AT)
9D00E6AE  FC438100   LW V0, -32512(V1)
9D00E6B2  00405ACC   INS V0, ZERO, 11, 1
9D00E6B6  F8438100   SW V0, -32512(V1)
9D00E6BA      CC93   B 0x9D00E7E2
9D00E6BC      0C00   NOP
398:                     }
399:                     else if(index==1)
9D00E6BE  147E0008   LBU V1, 8(S8)
9D00E6C2      ED01   LI V0, 1
9D00E6C4  B4430045   BNE V1, V0, 0x9D00E752
9D00E6C6  00450C00   SLL V0, A1, 1
9D00E6C8      0C00   NOP
400:                     {
401:                         if (mode==BUS_MODE._16bit) { SPI2CONbits.MODE16=1; SPI2CONbits.MODE32=0;}
9D00E6CA      ED01   LI V0, 1
9D00E6CC  147E000C   LBU V1, 12(S8)
9D00E6D0  B4430014   BNE V1, V0, 0x9D00E6FC
9D00E6D2  00140C00   SLL ZERO, S4, 1
9D00E6D4      0C00   NOP
9D00E6D6  41A3BF81   LUI V1, 0xBF81
9D00E6D8  BF81FC43   LDC1 F28, -957(AT)
9D00E6DA  FC438200   LW V0, -32256(V1)
9D00E6DE      EE01   LI A0, 1
9D00E6E0  0044528C   INS V0, A0, 10, 1
9D00E6E2  528CF843   ORI S4, T4, -1981
9D00E6E4  F8438200   SW V0, -32256(V1)
9D00E6E8  41A3BF81   LUI V1, 0xBF81
9D00E6EA  BF81FC43   LDC1 F28, -957(AT)
9D00E6EC  FC438200   LW V0, -32256(V1)
9D00E6F0  00405ACC   INS V0, ZERO, 11, 1
9D00E6F4  F8438200   SW V0, -32256(V1)
9D00E6F8      CC74   B 0x9D00E7E2
9D00E6FA      0C00   NOP
402:                         else if (mode==BUS_MODE._32bit) { SPI2CONbits.MODE16=0; SPI2CONbits.MODE32=1;}
9D00E6FC      ED02   LI V0, 2
9D00E6FE  147E000C   LBU V1, 12(S8)
9D00E702  B4430014   BNE V1, V0, 0x9D00E72E
9D00E704  00140C00   SLL ZERO, S4, 1
9D00E706      0C00   NOP
9D00E708  41A3BF81   LUI V1, 0xBF81
9D00E70A  BF81FC43   LDC1 F28, -957(AT)
9D00E70C  FC438200   LW V0, -32256(V1)
9D00E710  0040528C   INS V0, ZERO, 10, 1
9D00E712  528CF843   ORI S4, T4, -1981
9D00E714  F8438200   SW V0, -32256(V1)
9D00E718  41A3BF81   LUI V1, 0xBF81
9D00E71A  BF81FC43   LDC1 F28, -957(AT)
9D00E71C  FC438200   LW V0, -32256(V1)
9D00E720      EE01   LI A0, 1
9D00E722  00445ACC   INS V0, A0, 11, 1
9D00E726  F8438200   SW V0, -32256(V1)
9D00E72A      CC5B   B 0x9D00E7E2
9D00E72C      0C00   NOP
403:                         else { SPI2CONbits.MODE16=0; SPI2CONbits.MODE32=0;}
9D00E72E  41A3BF81   LUI V1, 0xBF81
9D00E730  BF81FC43   LDC1 F28, -957(AT)
9D00E732  FC438200   LW V0, -32256(V1)
9D00E736  0040528C   INS V0, ZERO, 10, 1
9D00E738  528CF843   ORI S4, T4, -1981
9D00E73A  F8438200   SW V0, -32256(V1)
9D00E73E  41A3BF81   LUI V1, 0xBF81
9D00E740  BF81FC43   LDC1 F28, -957(AT)
9D00E742  FC438200   LW V0, -32256(V1)
9D00E746  00405ACC   INS V0, ZERO, 11, 1
9D00E74A  F8438200   SW V0, -32256(V1)
9D00E74E      CC49   B 0x9D00E7E2
9D00E750      0C00   NOP
404:                     }
405:                     else if(index==2)
9D00E752  147E0008   LBU V1, 8(S8)
9D00E756      ED02   LI V0, 2
9D00E758  B4430043   BNE V1, V0, 0x9D00E7E2
9D00E75A  00430C00   SLL V0, V1, 1
9D00E75C      0C00   NOP
406:                     {
407:                         if (mode==BUS_MODE._16bit) { SPI3CONbits.MODE16=1; SPI3CONbits.MODE32=0;}
9D00E75E      ED01   LI V0, 1
9D00E760  147E000C   LBU V1, 12(S8)
9D00E764  B4430014   BNE V1, V0, 0x9D00E790
9D00E766  00140C00   SLL ZERO, S4, 1
9D00E768      0C00   NOP
9D00E76A  41A3BF81   LUI V1, 0xBF81
9D00E76C  BF81FC43   LDC1 F28, -957(AT)
9D00E76E  FC438300   LW V0, -32000(V1)
9D00E772      EE01   LI A0, 1
9D00E774  0044528C   INS V0, A0, 10, 1
9D00E776  528CF843   ORI S4, T4, -1981
9D00E778  F8438300   SW V0, -32000(V1)
9D00E77C  41A3BF81   LUI V1, 0xBF81
9D00E77E  BF81FC43   LDC1 F28, -957(AT)
9D00E780  FC438300   LW V0, -32000(V1)
9D00E784  00405ACC   INS V0, ZERO, 11, 1
9D00E788  F8438300   SW V0, -32000(V1)
9D00E78C      CC2A   B 0x9D00E7E2
9D00E78E      0C00   NOP
408:                         else if (mode==BUS_MODE._32bit) { SPI3CONbits.MODE16=0; SPI3CONbits.MODE32=1;}
9D00E790      ED02   LI V0, 2
9D00E792  147E000C   LBU V1, 12(S8)
9D00E796  B4430014   BNE V1, V0, 0x9D00E7C2
9D00E798  00140C00   SLL ZERO, S4, 1
9D00E79A      0C00   NOP
9D00E79C  41A3BF81   LUI V1, 0xBF81
9D00E79E  BF81FC43   LDC1 F28, -957(AT)
9D00E7A0  FC438300   LW V0, -32000(V1)
9D00E7A4  0040528C   INS V0, ZERO, 10, 1
9D00E7A6  528CF843   ORI S4, T4, -1981
9D00E7A8  F8438300   SW V0, -32000(V1)
9D00E7AC  41A3BF81   LUI V1, 0xBF81
9D00E7AE  BF81FC43   LDC1 F28, -957(AT)
9D00E7B0  FC438300   LW V0, -32000(V1)
9D00E7B4      EE01   LI A0, 1
9D00E7B6  00445ACC   INS V0, A0, 11, 1
9D00E7BA  F8438300   SW V0, -32000(V1)
9D00E7BE      CC11   B 0x9D00E7E2
9D00E7C0      0C00   NOP
409:                         else { SPI3CONbits.MODE16=0; SPI3CONbits.MODE32=0;}
9D00E7C2  41A3BF81   LUI V1, 0xBF81
9D00E7C4  BF81FC43   LDC1 F28, -957(AT)
9D00E7C6  FC438300   LW V0, -32000(V1)
9D00E7CA  0040528C   INS V0, ZERO, 10, 1
9D00E7CC  528CF843   ORI S4, T4, -1981
9D00E7CE  F8438300   SW V0, -32000(V1)
9D00E7D2  41A3BF81   LUI V1, 0xBF81
9D00E7D4  BF81FC43   LDC1 F28, -957(AT)
9D00E7D6  FC438300   LW V0, -32000(V1)
9D00E7DA  00405ACC   INS V0, ZERO, 11, 1
9D00E7DE  F8438300   SW V0, -32000(V1)
410:                     }    
411:                 }
9D00E7E2      0FBE   MOVE SP, S8
9D00E7E4      4BC1   LW S8, 4(SP)
9D00E7E6      4C05   ADDIU SP, SP, 8
9D00E7E8      45BF   JRC RA
9D00E7EA      0C00   NOP
412:                 
413:                 void spi_setSpeed(int index, int speed)
414:                 {
9D00E7EC      4FF9   ADDIU SP, SP, -16
9D00E7EE      CBC3   SW S8, 12(SP)
9D00E7F0      0FDD   MOVE S8, SP
9D00E7F2  F89E0010   SW A0, 16(S8)
9D00E7F6  F8BE0014   SW A1, 20(S8)
415:                     int x;
416:                     if(index==0)
9D00E7FA  FC5E0010   LW V0, 16(S8)
9D00E7FE  40E2001C   BEQZC V0, 0x9D00E83A
417:                     {
418:                 #ifdef SPI1_INIT        
419:                         x=SPI1CON;                      //zaloha SPIxCON
420:                         SPI1CON=0x0;                    //SPIxCON=0, SPI OFF
421:                         SPI1BRG=speed;                  //nastav BRG (divider)
422:                         SPI1CON=x;                      //SPIxCON puvodni hodnota        
423:                 #endif        
424:                     }
425:                     else if(index==1)
9D00E802  FC7E0010   LW V1, 16(S8)
9D00E806      ED01   LI V0, 1
9D00E808  B4430017   BNE V1, V0, 0x9D00E83A
9D00E80A  00170C00   SLL ZERO, S7, 1
9D00E80C      0C00   NOP
426:                     {
427:                 #ifdef SPI2_INIT         
428:                         x=SPI2CON;                      //zaloha SPIxCON
9D00E80E  41A2BF81   LUI V0, 0xBF81
9D00E810  BF81FC42   LDC1 F28, -958(AT)
9D00E812  FC428200   LW V0, -32256(V0)
9D00E816  F85E0000   SW V0, 0(S8)
429:                         SPI2CON=0x0;                    //SPIxCON=0, SPI OFF
9D00E81A  41A2BF81   LUI V0, 0xBF81
9D00E81C  BF81F802   LDC1 F28, -2046(AT)
9D00E81E  F8028200   SW ZERO, -32256(V0)
430:                         SPI2BRG=speed;                  //nastav BRG (divider)
9D00E822  FC7E0014   LW V1, 20(S8)
9D00E826  41A2BF81   LUI V0, 0xBF81
9D00E828  BF81F862   LDC1 F28, -1950(AT)
9D00E82A  F8628230   SW V1, -32208(V0)
431:                         SPI2CON=x;                      //SPIxCON puvodni hodnota
9D00E82E  FC7E0000   LW V1, 0(S8)
9D00E832  41A2BF81   LUI V0, 0xBF81
9D00E834  BF81F862   LDC1 F28, -1950(AT)
9D00E836  F8628200   SW V1, -32256(V0)
432:                 #endif        
433:                     }
434:                     else if (index==2)
435:                     {
436:                 #ifdef SPI3_INIT         
437:                         x=SPI3CON;                      //zaloha SPIxCON
438:                         SPI3CON=0x0;                    //SPIxCON=0, SPI OFF
439:                         SPI3BRG=speed;                  //nastav BRG (divider)
440:                         SPI3CON=x;                      //SPIxCON puvodni hodnota        
441:                 #endif        
442:                     }
443:                 }
9D00E83A      0FBE   MOVE SP, S8
9D00E83C      4BC3   LW S8, 12(SP)
9D00E83E      4C09   ADDIU SP, SP, 16
9D00E840      45BF   JRC RA
9D00E842      0C00   NOP
444:                 
445:                 
446:                 
447:                 #ifdef SPI1_INIT
448:                 void spi1_TxInterrupt()
449:                 {
450:                     //vola se z spiExchange a z SPI interruptu
451:                     //interrupt pri dokonceni vysilani (nikoliv tx_fifo empty)
452:                     
453:                     SPIControl* ctl = controlStruct[0];
454:                     
455:                     //load rx_fifo, pokud existuje
456:                     while(ctl->tx_count > 0)
457:                     {
458:                         //predpoklada, ze v rx_fifo je stejny pocet bytes, jaky byl minule odvysilan
459:                         *ctl->rx_buffer=SPI1BUF;
460:                         ctl->rx_buffer++;
461:                         ctl->tx_count--;
462:                     }
463:                 
464:                     
465:                     if(ctl->len == 0)
466:                     {
467:                         //konec
468:                         //ctl.inProcess=0;
469:                         //disableSpi1TxInterrupt();  
470:                         SPI1_DISABLE_TxINTERRUPT;
471:                         
472:                         if(ctl->finish != NULL)
473:                         {
474:                             _finish=ctl->finish;
475:                             _finish(ctl->used);
476:                         }
477:                     }
478:                     else
479:                     {
480:                         //odeslat dalsi data, max SPI_HW_BUFFER_SIZE bytes
481:                         int c=0;
482:                         while(ctl->len > 0 && c<SPI_FIFO_SIZE)
483:                         {
484:                             c++;
485:                             ctl->len--;                                                  //pocet --
486:                             if(ctl->rx_buffer != NULL) { ctl->tx_count ++;}       //priste bude probihat read fifo
487:                             //tx fifo
488:                             SPI1BUF=*ctl->tx_buffer;
489:                             ctl->tx_buffer++;                                            //dalsi znak
490:                         }
491:                         
492:                         //povolit TX buffer empty interrupt
493:                         //enableSpi1TxInterrupt();        
494:                         SPI1_ENABLE_TxINTERRUPT;
495:                     }
496:                     
497:                 }
498:                 #endif
499:                 
500:                 #ifdef SPI2_INIT
501:                 void spi2_TxInterrupt()
502:                 {
9D00E844      4FED   ADDIU SP, SP, -40
9D00E846      CBE9   SW RA, 36(SP)
9D00E848      CBC8   SW S8, 32(SP)
9D00E84A      0FDD   MOVE S8, SP
503:                     //vola se z spiExchange a z SPI interruptu
504:                     //interrupt pri dokonceni vysilani (nikoliv tx_fifo empty)
505:                     
506:                     //ctl->mode=1
507:                     //[0] 0b00 000001    //nasleduje 1 byte + vola EventFn(0b00000001)
508:                     //[1] 0xXX           //data byte
509:                     //[2] 0b01 000100    //nasleduji 4 byte + vola EventFn(0b01000100)
510:                     //[3-6] 4xdata
511:                     //len=7
512:                     //pokud ctl->mode_count=0, jedna se o command byte 
513:                     //command byte definuje pocet bytes dat, ktere nasleduji (ty se vysilaji). Zaroven se CB pouzije jako param pri volani Event fce
514:                     //po odvysilani daneho poctu dat nasleduje dalsi CB, dokud (ctl->len > 0)
515:                     
516:                     SPIControl* ctl = controlStruct[1];
9D00E84C  41A28000   LUI V0, 0x8000
9D00E850  30420AD8   ADDIU V0, V0, 2776
9D00E852      0AD8   LBU A1, 8(A1)
9D00E854      6921   LW V0, 4(V0)
9D00E856  F85E0014   SW V0, 20(S8)
517:                     
518:                     //load rx_fifo, pokud existuje
519:                     while(ctl->tx_count > 0)
9D00E85A      CC1B   B 0x9D00E892
9D00E85C      0C00   NOP
9D00E892  FC5E0014   LW V0, 20(S8)
9D00E896  3C420016   LH V0, 22(V0)
9D00E89A  40C2FFE0   BGTZ V0, 0x9D00E85E
9D00E89C  FFE00C00   LW RA, 3072(ZERO)
9D00E89E      0C00   NOP
520:                     {
521:                         //tx_count je pocet bytes posledniho vysilani
522:                         //predpoklada, ze v rx_fifo je stejny pocet bytes, jaky byl minule odvysilan
523:                         *ctl->rx_buffer=SPI2BUF;
9D00E85E  FC5E0014   LW V0, 20(S8)
9D00E862      6921   LW V0, 4(V0)
9D00E864  41A3BF81   LUI V1, 0xBF81
9D00E866  BF81FC63   LDC1 F28, -925(AT)
9D00E868  FC638220   LW V1, -32224(V1)
9D00E86C      2DBD   ANDI V1, V1, 0xFF
9D00E86E      89A0   SB V1, 0(V0)
524:                         ctl->rx_buffer++;
9D00E870  FC5E0014   LW V0, 20(S8)
9D00E874      6921   LW V0, 4(V0)
9D00E876      6DA0   ADDIU V1, V0, 1
9D00E878  FC5E0014   LW V0, 20(S8)
9D00E87C      E9A1   SW V1, 4(V0)
525:                         ctl->tx_count--;
9D00E87E  FC5E0014   LW V0, 20(S8)
9D00E882  3C420016   LH V0, 22(V0)
9D00E886      6D2E   ADDIU V0, V0, -1
9D00E888  00623B3C   SEH V1, V0
9D00E88A  3B3CFC5E   SH T9, -930(GP)
9D00E88C  FC5E0014   LW V0, 20(S8)
9D00E890      A9AB   SH V1, 22(V0)
526:                     }
527:                 
528:                     
529:                     if(ctl->len == 0)
9D00E8A0  FC5E0014   LW V0, 20(S8)
9D00E8A4  3C420014   LH V0, 20(V0)
9D00E8A8  40A20020   BNEZC V0, 0x9D00E8EC
530:                     {
531:                         //konec, vsechna data byla odeslana
532:                         SPI2_DISABLE_TxINTERRUPT;
9D00E8AC  41A2BF81   LUI V0, 0xBF81
9D00E8AE  BF813060   LDC1 F28, 12384(AT)
9D00E8B0  30602000   ADDIU V1, ZERO, 8192
9D00E8B4  F862F0D4   SW V1, -3884(V0)
9D00E8B6  F0D4FC5E   JALX 0x9B53F178
533:                         
534:                         if(ctl->finishFn != NULL)
9D00E8B8  FC5E0014   LW V0, 20(S8)
9D00E8BC      6922   LW V0, 8(V0)
9D00E8BE  40E2000E   BEQZC V0, 0x9D00E8DE
535:                         {
536:                             _finish=ctl->finishFn;
9D00E8C2  FC5E0014   LW V0, 20(S8)
9D00E8C6      6922   LW V0, 8(V0)
9D00E8C8  F85C8098   SW V0, -32616(GP)
537:                             _finish(ctl->used);
9D00E8CC  FC5C8098   LW V0, -32616(GP)
9D00E8D0  FC7E0014   LW V1, 20(S8)
9D00E8D4  1463001A   LBU V1, 26(V1)
9D00E8D8      0C83   MOVE A0, V1
9D00E8DA      45E2   JALRS16 V0
9D00E8DC      0C00   NOP
538:                         }
539:                         
540:                         ctl->process=SPI_STATE.FINISHED;
9D00E8DE      0C60   MOVE V1, ZERO
9D00E8E0  FC5E0014   LW V0, 20(S8)
9D00E8E4  1862001B   SB V1, 27(V0)
9D00E8E8      CCE0   B 0x9D00EAAA
9D00E8EA      0C00   NOP
541:                     }
542:                     else
543:                     {
544:                         if((ctl->mode==1) && (ctl->mode_count==0))
9D00E8EC  FC5E0014   LW V0, 20(S8)
9D00E8F0  14620019   LBU V1, 25(V0)
9D00E8F4      ED01   LI V0, 1
9D00E8F6  B443003E   BNE V1, V0, 0x9D00E976
9D00E8F8  003E0C00   SLL AT, S8, 1
9D00E8FA      0C00   NOP
9D00E8FC  FC5E0014   LW V0, 20(S8)
9D00E900  14420018   LBU V0, 24(V0)
9D00E904  40A20037   BNEZC V0, 0x9D00E976
545:                         {
546:                             //control byte
547:                             char x=*ctl->tx_buffer;
9D00E908  FC5E0014   LW V0, 20(S8)
9D00E90A  00146920   ADD T5, S4, ZERO
9D00E90C      6920   LW V0, 0(V0)
9D00E90E      0920   LBU V0, 0(V0)
9D00E910  185E0018   SB V0, 24(S8)
548:                             ctl->mode_count=(x & 0x3F);                   //nuluje b7,b6 (b0-b5 = pocet bytes)
9D00E914  145E0018   LBU V0, 24(S8)
9D00E918      2D2B   ANDI V0, V0, 0x3F
9D00E91A      2DAD   ANDI V1, V0, 0xFF
9D00E91C  FC5E0014   LW V0, 20(S8)
9D00E920  18620018   SB V1, 24(V0)
549:                             _finish=ctl->eventFn;
9D00E924  FC5E0014   LW V0, 20(S8)
9D00E928      6923   LW V0, 12(V0)
9D00E92A  F85C8098   SW V0, -32616(GP)
550:                             _finish(x);
9D00E92E  FC5C8098   LW V0, -32616(GP)
9D00E932  147E0018   LBU V1, 24(S8)
9D00E936      0C83   MOVE A0, V1
9D00E938      45E2   JALRS16 V0
9D00E93A      0C00   NOP
551:                             
552:                             if((x>>6)==0b11)
9D00E93C  145E0018   LBU V0, 24(S8)
9D00E93E  0018252D   PRECRQ_RS.PH.W A0, T8, ZERO
9D00E940      252D   SRL V0, V0, 6
9D00E942      2DAD   ANDI V1, V0, 0xFF
9D00E944      ED03   LI V0, 3
9D00E946  B4430005   BNE V1, V0, 0x9D00E954
9D00E948  00050C00   SLL ZERO, A1, 1
9D00E94A      0C00   NOP
553:                             {
554:                                 //pokud command byte b6-b7 = 11, nastavi mode=0 (pouze odesila zbytek bufferu v modu 0)
555:                                 ctl->mode=0;
9D00E94C  FC5E0014   LW V0, 20(S8)
9D00E950  18020019   SB ZERO, 25(V0)
556:                             }
557:                                 
558:                             ctl->len--;
9D00E954  FC5E0014   LW V0, 20(S8)
9D00E958  3C420014   LH V0, 20(V0)
9D00E95C      6D2E   ADDIU V0, V0, -1
9D00E95E  00623B3C   SEH V1, V0
9D00E960  3B3CFC5E   SH T9, -930(GP)
9D00E962  FC5E0014   LW V0, 20(S8)
9D00E966      A9AA   SH V1, 20(V0)
559:                             ctl->tx_buffer++; 
9D00E968  FC5E0014   LW V0, 20(S8)
9D00E96A  00146920   ADD T5, S4, ZERO
9D00E96C      6920   LW V0, 0(V0)
9D00E96E      6DA0   ADDIU V1, V0, 1
9D00E970  FC5E0014   LW V0, 20(S8)
9D00E972  0014E9A0   SUB SP, S4, ZERO
9D00E974      E9A0   SW V1, 0(V0)
560:                         }
561:                         
562:                         int c=0;
9D00E976  F81E0010   SW ZERO, 16(S8)
563:                         if(ctl->mode==0)
9D00E97A  FC5E0014   LW V0, 20(S8)
9D00E97E  14420019   LBU V0, 25(V0)
9D00E982  40A2003F   BNEZC V0, 0x9D00EA04
564:                         {
565:                             //odeslat dalsi data, max SPI_HW_BUFFER_SIZE bytes
566:                             while((ctl->len > 0) && (c<SPI_FIFO_SIZE))
9D00E986      CC2F   B 0x9D00E9E6
9D00E988      0C00   NOP
9D00E9E6  FC5E0014   LW V0, 20(S8)
9D00E9EA  3C420014   LH V0, 20(V0)
9D00E9EE  40820056   BLEZ V0, 0x9D00EA9E
9D00E9F0  00560C00   SLL V0, S6, 1
9D00E9F2      0C00   NOP
9D00E9F4  FC5E0010   LW V0, 16(S8)
9D00E9F8  90420010   SLTI V0, V0, 16
9D00E9FC  40A2FFC5   BNEZC V0, 0x9D00E98A
9D00E9FE  FFC5CC4E   LW S8, -13234(A1)
9D00EA00      CC4E   B 0x9D00EA9E
9D00EA02      0C00   NOP
567:                             {
568:                                 c++;
9D00E98A  FC5E0010   LW V0, 16(S8)
9D00E98C  00106D20   ADD T5, S0, ZERO
9D00E98E      6D20   ADDIU V0, V0, 1
9D00E990  F85E0010   SW V0, 16(S8)
569:                                 ctl->len--;                                                     //pocet --
9D00E994  FC5E0014   LW V0, 20(S8)
9D00E998  3C420014   LH V0, 20(V0)
9D00E99C      6D2E   ADDIU V0, V0, -1
9D00E99E  00623B3C   SEH V1, V0
9D00E9A0  3B3CFC5E   SH T9, -930(GP)
9D00E9A2  FC5E0014   LW V0, 20(S8)
9D00E9A6      A9AA   SH V1, 20(V0)
570:                                 if(ctl->rx_buffer != NULL) { ctl->tx_count ++;}                 //priste bude probihat read fifo
9D00E9A8  FC5E0014   LW V0, 20(S8)
9D00E9AC      6921   LW V0, 4(V0)
9D00E9AE  40E2000A   BEQZC V0, 0x9D00E9C6
9D00E9B2  FC5E0014   LW V0, 20(S8)
9D00E9B6  3C420016   LH V0, 22(V0)
9D00E9B8  00166D20   ADD T5, S6, ZERO
9D00E9BA      6D20   ADDIU V0, V0, 1
9D00E9BC  00623B3C   SEH V1, V0
9D00E9BE  3B3CFC5E   SH T9, -930(GP)
9D00E9C0  FC5E0014   LW V0, 20(S8)
9D00E9C4      A9AB   SH V1, 22(V0)
571:                                 //tx fifo
572:                                 SPI2BUF=*ctl->tx_buffer;
9D00E9C6  FC5E0014   LW V0, 20(S8)
9D00E9C8  00146920   ADD T5, S4, ZERO
9D00E9CA      6920   LW V0, 0(V0)
9D00E9CC      0920   LBU V0, 0(V0)
9D00E9CE      0C62   MOVE V1, V0
9D00E9D0  41A2BF81   LUI V0, 0xBF81
9D00E9D2  BF81F862   LDC1 F28, -1950(AT)
9D00E9D4  F8628220   SW V1, -32224(V0)
573:                                 ctl->tx_buffer++;                                               //dalsi znak
9D00E9D8  FC5E0014   LW V0, 20(S8)
9D00E9DA  00146920   ADD T5, S4, ZERO
9D00E9DC      6920   LW V0, 0(V0)
9D00E9DE      6DA0   ADDIU V1, V0, 1
9D00E9E0  FC5E0014   LW V0, 20(S8)
9D00E9E2  0014E9A0   SUB SP, S4, ZERO
9D00E9E4      E9A0   SW V1, 0(V0)
574:                             }
575:                         }
576:                         else
577:                         {
578:                             while((ctl->mode_count > 0) && (ctl->len > 0) && (c < SPI_FIFO_SIZE))
9D00EA04      CC39   B 0x9D00EA78
9D00EA06      0C00   NOP
9D00EA78  FC5E0014   LW V0, 20(S8)
9D00EA7C  14420018   LBU V0, 24(V0)
9D00EA80  40E2000D   BEQZC V0, 0x9D00EA9E
9D00EA84  FC5E0014   LW V0, 20(S8)
9D00EA88  3C420014   LH V0, 20(V0)
9D00EA8C  40820007   BLEZ V0, 0x9D00EA9E
9D00EA8E  00070C00   SLL ZERO, A3, 1
9D00EA90      0C00   NOP
9D00EA92  FC5E0010   LW V0, 16(S8)
9D00EA96  90420010   SLTI V0, V0, 16
9D00EA9A  40A2FFB5   BNEZC V0, 0x9D00EA08
9D00EA9C  FFB541A2   LW SP, 16802(S5)
579:                             {
580:                                 c++;
9D00EA08  FC5E0010   LW V0, 16(S8)
9D00EA0A  00106D20   ADD T5, S0, ZERO
9D00EA0C      6D20   ADDIU V0, V0, 1
9D00EA0E  F85E0010   SW V0, 16(S8)
581:                                 ctl->mode_count--;
9D00EA12  FC5E0014   LW V0, 20(S8)
9D00EA16  14420018   LBU V0, 24(V0)
9D00EA1A      6D2E   ADDIU V0, V0, -1
9D00EA1C      2DAD   ANDI V1, V0, 0xFF
9D00EA1E  FC5E0014   LW V0, 20(S8)
9D00EA22  18620018   SB V1, 24(V0)
582:                                 ctl->len--;                                                     //pocet --
9D00EA26  FC5E0014   LW V0, 20(S8)
9D00EA2A  3C420014   LH V0, 20(V0)
9D00EA2E      6D2E   ADDIU V0, V0, -1
9D00EA30  00623B3C   SEH V1, V0
9D00EA32  3B3CFC5E   SH T9, -930(GP)
9D00EA34  FC5E0014   LW V0, 20(S8)
9D00EA38      A9AA   SH V1, 20(V0)
583:                                 if(ctl->rx_buffer != NULL) { ctl->tx_count ++;}                 //priste bude probihat read fifo
9D00EA3A  FC5E0014   LW V0, 20(S8)
9D00EA3E      6921   LW V0, 4(V0)
9D00EA40  40E2000A   BEQZC V0, 0x9D00EA58
9D00EA44  FC5E0014   LW V0, 20(S8)
9D00EA48  3C420016   LH V0, 22(V0)
9D00EA4A  00166D20   ADD T5, S6, ZERO
9D00EA4C      6D20   ADDIU V0, V0, 1
9D00EA4E  00623B3C   SEH V1, V0
9D00EA50  3B3CFC5E   SH T9, -930(GP)
9D00EA52  FC5E0014   LW V0, 20(S8)
9D00EA56      A9AB   SH V1, 22(V0)
584:                                 //tx fifo
585:                                 SPI2BUF=*ctl->tx_buffer;
9D00EA58  FC5E0014   LW V0, 20(S8)
9D00EA5A  00146920   ADD T5, S4, ZERO
9D00EA5C      6920   LW V0, 0(V0)
9D00EA5E      0920   LBU V0, 0(V0)
9D00EA60      0C62   MOVE V1, V0
9D00EA62  41A2BF81   LUI V0, 0xBF81
9D00EA64  BF81F862   LDC1 F28, -1950(AT)
9D00EA66  F8628220   SW V1, -32224(V0)
586:                                 ctl->tx_buffer++;                                               //dalsi znak
9D00EA6A  FC5E0014   LW V0, 20(S8)
9D00EA6C  00146920   ADD T5, S4, ZERO
9D00EA6E      6920   LW V0, 0(V0)
9D00EA70      6DA0   ADDIU V1, V0, 1
9D00EA72  FC5E0014   LW V0, 20(S8)
9D00EA74  0014E9A0   SUB SP, S4, ZERO
9D00EA76      E9A0   SW V1, 0(V0)
587:                             }                
588:                         }
589:                         
590:                         //povolit TX buffer empty interrupt
591:                         SPI2_ENABLE_TxINTERRUPT;
9D00EA9E  41A2BF81   LUI V0, 0xBF81
9D00EAA0  BF813060   LDC1 F28, 12384(AT)
9D00EAA2  30602000   ADDIU V1, ZERO, 8192
9D00EAA6  F862F0D8   SW V1, -3880(V0)
9D00EAA8  F0D80FBE   JALX 0x9B603EF8
592:                     }
593:                         
594:                 }
9D00EAAA      0FBE   MOVE SP, S8
9D00EAAC      4BE9   LW RA, 36(SP)
9D00EAAE      4BC8   LW S8, 32(SP)
9D00EAB0      4C15   ADDIU SP, SP, 40
9D00EAB2      45BF   JRC RA
595:                 #endif
596:                 
597:                 #ifdef SPI3_INIT
598:                 void spi3_TxInterrupt()
599:                 {
600:                     //vola se z spiExchange a z SPI interruptu
601:                     //interrupt pri dokonceni vysilani (nikoliv tx_fifo empty)
602:                     
603:                     SPIControl* ctl = controlStruct[2];
604:                     
605:                     //load rx_fifo, pokud existuje
606:                     while(ctl->tx_count > 0)
607:                     {
608:                         //predpoklada, ze v rx_fifo je stejny pocet bytes, jaky byl minule odvysilan
609:                         *ctl->rx_buffer=SPI3BUF;
610:                         ctl->rx_buffer++;
611:                         ctl->tx_count--;
612:                     }
613:                 
614:                     
615:                     if(ctl->len == 0)
616:                     {
617:                         //konec
618:                         //ctl.inProcess=0;
619:                         //disableSpi1TxInterrupt();  
620:                         SPI3_DISABLE_TxINTERRUPT;
621:                         
622:                         if(ctl->finish != NULL)
623:                         {
624:                             _finish=ctl->finish;
625:                             _finish(ctl->used);
626:                         }
627:                     }
628:                     else
629:                     {
630:                         //odeslat dalsi data, max SPI_HW_BUFFER_SIZE bytes
631:                         int c=0;
632:                         while(ctl->len > 0 && c<SPI_FIFO_SIZE)
633:                         {
634:                             c++;
635:                             ctl->len--;                                                 //pocet --
636:                             if(ctl->rx_buffer != NULL) { ctl->tx_count ++;}             //priste bude probihat read fifo
637:                             //tx fifo
638:                             SPI3BUF=*ctl->tx_buffer;
639:                             ctl->tx_buffer++;                                           //dalsi znak
640:                         }
641:                         
642:                         //povolit TX buffer empty interrupt
643:                         //enableSpi1TxInterrupt();        
644:                         SPI3_ENABLE_TxINTERRUPT;
645:                     }
646:                         
647:                 }
648:                 #endif
649:                 
650:                 
651:                 static void clearRxFifo(int index)
652:                 {
9D00EAB4      4FB0   ADDIU SP, SP, -8
9D00EAB6      CBC1   SW S8, 4(SP)
9D00EAB8      0FDD   MOVE S8, SP
9D00EABA  F89E0008   SW A0, 8(S8)
9D00EABC  00080C00   SLL ZERO, T0, 1
653:                 #ifdef SIMULATOR
654:                     return;
9D00EABE      0C00   NOP
655:                 #endif    
656:                     
657:                     //vyprazdni rx_fifo
658:                     int x;
659:                     if(index==0)
660:                     {
661:                 #ifdef SPI1_INIT        
662:                         while(SPI1STATbits.SPIRBE==0)
663:                         {
664:                             x=SPI1BUF;
665:                         }
666:                         //nuluje overflow flag (pokud je nastaven, neprijima data)
667:                         SPI1STATbits.SPIROV=0;
668:                 #endif         
669:                     }
670:                     else 
671:                     {
672:                 #ifdef SPI2_INIT          
673:                         while(SPI2STATbits.SPIRBE==0)
674:                         {
675:                             x=SPI2BUF;
676:                         }
677:                         //nuluje overflow flag (pokud je nastaven, neprijima data)
678:                         SPI2STATbits.SPIROV=0;
679:                 #endif          
680:                     }
681:                 }
9D00EAC0      0FBE   MOVE SP, S8
682:                 
683:                 #endif //(ifdef PIC32MM)
684:                 
685:                 #ifdef PIC32MZ
686:                 
687:                 #endif  //(ifdef PIC32MZ)
688:                 
689:                 
690:                 #endif //(ifdef SPI1_INIT, SPI2_INIT, SPI3_INIT)
---  d:/bos/bos/pwm.c  ----------------------------------------------------------------------------------
1:                   
2:                   #include <xc.h>
3:                   #include <stdio.h>
4:                   //#include <stdlib.h>
5:                   #include "def.h"
6:                   #include "asm.h"
7:                   #include "pwm.h"
8:                   
9:                   #if (defined PWM_INIT && defined PIC32MM)
10:                  
11:                  #define     PERIOD              4096                            //regulace 0 - 4096
12:                  
13:                  #ifdef PWM_SOFT
14:                  //pro PWM_SOFT plati:
15:                  //fce v tomto modulu nastavi data v tabulce pwm_table a asm fce pwm_soft_timer
16:                  //zajisti soft zmenu vykonu. pwm_soft_timer je volana z timer1 interruptu
17:                  
18:                  //byte[0]     timebase, cas kroku
19:                  //byte[1]     aktualni time value
20:                  //byte[2-3]   (linear) target value / (exp) target index
21:                  //byte[4-7]   (linear) step / (exp) step(+1,-1,0), aktual index
22:                  //byte[8-11]  adresa fce pwm_soft_linear_down, pwm_soft_linear_up, pwm_soft_exp
23:                  //byte[12-15] adresa CCPxRB registru - obsahuje value   
24:                  //byte[16-19] (exp) adresa pole dat pro jiny, nez linearni prubeh, definuje hodnoty pro jednotlive indexy  
25:                  
26:                  int   pwm_table[(CCP_PWM_TABLE_ISIZE/4) * CCP_PWM_COUNT];       //CCP_PWM_TABLE_ISIZE velikost bytes
27:                  void* pwm_soft_fn=NULL;                                         //adresa pwm_soft_timer, nebo null
28:                  
29:                  
30:                  #define     EXP_MAX             37                             //max. index pwm_exp
31:                  //const short pwm_exp[]={0,1,2,3,4,6,8,10,12,14,16,20,24,28,32,40,48,56,64,80,96,112,128,170,
32:                  //                       212,256,341,426,512,682,852,1024,1536,2048,3072,4096}; //36 polozek
33:                  //const short pwm_exp[]={0,1,2,3,4,6,8,10,12,14,16,20,24,28,32,40,48,56,64,80,96,112,128,160,
34:                  //                       200,256,300,390,512,640,820,1024,1250,1550,2048,2450,2950,3500,4096}; //39 polozek
35:                  //const short pwm_exp[]={0,2,4,8,13,19,25,32,40,50,64,80,100,128,160,
36:                  //                       200,256,300,390,512,640,820,1024,1250,1550,2048,2450,2950,3500,4096}; //30 polozek
37:                  
38:                  const short pwm_exp[]={0,2,5,10,15,22,27,35,43,52,62,80,110,140,170,
39:                                         200,240,300,350,400,500,600,700,800,900,1000,1200,1400,1600,1800,
40:                                          2000, 2200, 2400, 2800, 3000, 3200, 3500, 4096}; //38 polozek
41:                  
42:                  //stejne jako power_exp lze vytvorit jine prubehy
43:                  
44:                  
45:                  
46:                  void pwm_setPowerLinearProc(char index, int target_proc, int step_ms, int step_size)
47:                  {
48:                      //plynula zmena vykonu na vysledny, zadany v procentech
49:                      //speed -rychlost zmeny 1=10ms, 2=20ms (nastaveni timer1_event=10ms, tj. nejmensi interval)
50:                      //step_size - velikost zmeny 1 = 1/4096
51:                      
52:                      int target_val=target_proc * PERIOD / 100;
53:                      pwm_setPowerLinear(index, target_val, step_ms, step_size);
54:                  }
55:                  
56:                  void pwm_setPowerLinear(char index, int target_val, int step_ms, int step_size)
57:                  {
58:                      //target = cilovy power
59:                      //speed -rychlost zmeny 1=10ms, 2=20ms (nastaveni timer1_event=10ms, tj. nejmensi interval)
60:                      //step_size - velikost zmeny 1 = 1/4096
61:                      
62:                      //pozastavi volani pwm fce (volane z timer1 interruptu) na dobu prenastavovani dat
63:                      pwm_soft_fn=NULL;
64:                      
65:                      //prepocet vykonu z procent na target value
66:                      //int target_val=target_proc * PERIOD / 100;
67:                      if(target_val>PERIOD) { target_val = PERIOD; }
68:                      if(target_val<0) { target_val = 0; }
69:                      
70:                      int pwm_table_index=0;
71:                      
72:                  #ifdef CCP1_PWM    
73:                      if(index==0)
74:                      {
75:                          int val=CCP1RB;
76:                          pwm_table[pwm_table_index+0]=target_val<<16 | step_ms<<8 | step_ms;
77:                          
78:                          pwm_table[pwm_table_index+3]=(int)&CCP1RB;
79:                          
80:                          pwm_table[pwm_table_index+1]= step_size;          
81:                          if(val>target_val)
82:                          {
83:                              //down
84:                              pwm_table[pwm_table_index+2]=(int)&pwm_soft_linear_down;
85:                          }
86:                          else
87:                          {
88:                              //up
89:                              pwm_table[pwm_table_index+2]=(int)&pwm_soft_linear_up;  
90:                          }
91:                      }
92:                      pwm_table_index+=(CCP_PWM_TABLE_ISIZE/4);
93:                  #endif    
94:                      
95:                  #ifdef CCP2_PWM    
96:                      if(index==1)
97:                      {
98:                          int val=CCP2RB;
99:                          pwm_table[pwm_table_index+0]=target_val<<16 | step_ms<<8 | step_ms;
100:                         
101:                         pwm_table[pwm_table_index+3]=(int)&CCP2RB;
102:                         
103:                         pwm_table[pwm_table_index+1]= step_size;          
104:                         if(val>target_val)
105:                         {
106:                             //down
107:                             pwm_table[pwm_table_index+2]=(int)&pwm_soft_linear_down;
108:                         }
109:                         else
110:                         {
111:                             //up
112:                             pwm_table[pwm_table_index+2]=(int)&pwm_soft_linear_up;  
113:                         }
114:                     } 
115:                     pwm_table_index+=(CCP_PWM_TABLE_ISIZE/4);
116:                 #endif    
117:                     
118:                 #ifdef CCP3_PWM    
119:                     if(index==2)
120:                     {
121:                         int val=CCP3RB;
122:                         pwm_table[pwm_table_index+0]=target_val<<16 | step_ms<<8 | step_ms;
123:                         
124:                         pwm_table[pwm_table_index+3]=(int)&CCP3RB;
125:                         
126:                         pwm_table[pwm_table_index+1]= step_size;          
127:                         if(val>target_val)
128:                         {
129:                             //down
130:                             pwm_table[pwm_table_index+2]=(int)&pwm_soft_linear_down;
131:                         }
132:                         else
133:                         {
134:                             //up
135:                             pwm_table[pwm_table_index+2]=(int)&pwm_soft_linear_up;  
136:                         }
137:                     }      
138:                 #endif    
139:                     
140:                     //timer1 interrupt vola fci pwm_soft_timer, po skonceni pwm_soft tento ukazatel nuluje, timer1 ji prestane volat 
141:                     //pwm_soft_timer pracuje v interruptu (timeru1)
142:                     pwm_soft_fn = &pwm_soft_timer;
143:                 }
144:                 
145:                 void pwm_setPowerExp(char index, int target_index, int step_ms)
146:                 {
147:                     //target_index je cilovy target, value bude zjistena z tabulky dat (akt. index je urcen automaticky)
148:                     //rizeni vykonu podle tabulky dat, zmena vykonu znemou indexu dat
149:                     
150:                     //pozastavi volani pwm fce (volane z timer1 interruptu) na dobu prenastavovani dat
151:                     pwm_soft_fn=NULL;
152:                     
153:                     int pwm_table_index=0;
154:                     
155:                     if(target_index<0) { target_index = 0; }
156:                     if(target_index>EXP_MAX) { target_index = EXP_MAX; }
157:                     
158:                 #ifdef CCP1_PWM    
159:                     if(index==0)
160:                     {
161:                         int val=CCP1RB;
162:                         
163:                         //najdi aktualni index, prvni polozka data, ktera je vetsi nebo rovna
164:                         int vali=-1, a;
165:                         for(a=0; a<=EXP_MAX; a++)
166:                         {
167:                             if(val<=pwm_exp[a]) { vali=a; break; }
168:                         }
169:                         
170:                         pwm_table[pwm_table_index+0]=target_index<<16 | step_ms<<8 | step_ms;  //target_index, time, timebase
171:                         pwm_table[pwm_table_index+2]=(int)&pwm_soft_exp;                       //adresa fce
172:                         pwm_table[pwm_table_index+3]=(int)&CCP1RB;                             //adresa registru
173:                         pwm_table[pwm_table_index+4]=(int)pwm_exp;                             //adresa pole data
174:                         
175:                         if(vali<target_index)
176:                         {
177:                             //step=+1, aktualni index
178:                             pwm_table[pwm_table_index+1]= 1<<8 | vali;
179:                         }
180:                         else if(vali>target_index)
181:                         {
182:                             //step=-1, aktualni index
183:                             pwm_table[pwm_table_index+1]= -1<<8 | vali;
184:                         }
185:                         else
186:                         {
187:                             //step=0, vali=target (pouze nastavi target hodnotu)
188:                             pwm_table[pwm_table_index+1] = target_index;
189:                         }
190:                     }  
191:                     pwm_table_index+=(CCP_PWM_TABLE_ISIZE/4);
192:                 #endif     
193:                     
194:                 #ifdef CCP2_PWM    
195:                     if(index==1)
196:                     {
197:                         int val=CCP2RB;
198:                         
199:                         //najdi aktualni index, prvni polozka data, ktera je vetsi nebo rovna
200:                         int vali=-1, a;
201:                         for(a=0; a<=EXP_MAX; a++)
202:                         {
203:                             if(val<=pwm_exp[a]) { vali=a; break; }
204:                         }
205:                         
206:                         pwm_table[pwm_table_index+0]=target_index<<16 | step_ms<<8 | step_ms;  //target_index, time, timebase
207:                         pwm_table[pwm_table_index+2]=(int)&pwm_soft_exp;                       //adresa fce
208:                         pwm_table[pwm_table_index+3]=(int)&CCP2RB;                             //adresa registru
209:                         pwm_table[pwm_table_index+4]=(int)pwm_exp;                             //adresa pole data
210:                         
211:                         if(vali<target_index)
212:                         {
213:                             //step=+1, aktualni index
214:                             pwm_table[pwm_table_index+1]= 1<<8 | vali;
215:                         }
216:                         else if(vali>target_index)
217:                         {
218:                             //step=-1, aktualni index
219:                             pwm_table[pwm_table_index+1]= -1<<8 | vali;
220:                         }
221:                         else
222:                         {
223:                             //step=0, vali=target (pouze nastavi target hodnotu)
224:                             pwm_table[pwm_table_index+1] = target_index;
225:                         }
226:                     }  
227:                     pwm_table_index+=(CCP_PWM_TABLE_ISIZE/4);
228:                 #endif 
229:                     
230:                 #ifdef CCP3_PWM    
231:                     if(index==2)
232:                     {
233:                         int val=CCP3RB;
234:                         
235:                         //najdi aktualni index, prvni polozka data, ktera je vetsi nebo rovna
236:                         int vali=-1, a;
237:                         for(a=0; a<=EXP_MAX; a++)
238:                         {
239:                             if(val<=pwm_exp[a]) { vali=a; break; }
240:                         }
241:                         
242:                         pwm_table[pwm_table_index+0]=target_index<<16 | step_ms<<8 | step_ms;  //target_index, time, timebase
243:                         pwm_table[pwm_table_index+2]=(int)&pwm_soft_exp;                       //adresa fce
244:                         pwm_table[pwm_table_index+3]=(int)&CCP3RB;                             //adresa registru
245:                         pwm_table[pwm_table_index+4]=(int)pwm_exp;                             //adresa pole data
246:                         
247:                         if(vali<target_index)
248:                         {
249:                             //step=+1, aktualni index
250:                             pwm_table[pwm_table_index+1]= 1<<8 | vali;
251:                         }
252:                         else if(vali>target_index)
253:                         {
254:                             //step=-1, aktualni index
255:                             pwm_table[pwm_table_index+1]= -1<<8 | vali;
256:                         }
257:                         else
258:                         {
259:                             //step=0, vali=target (pouze nastavi target hodnotu)
260:                             pwm_table[pwm_table_index+1] = target_index;
261:                         }
262:                     }  
263:                 #endif     
264:                     
265:                     //timer1 interrupt vola fci pwm_soft_timer, po skonceni pwm_soft tento ukazatel nuluje, timer1 ji prestane volat 
266:                     //pwm_soft_timer pracuje v interruptu (timeru1)    
267:                     pwm_soft_fn = &pwm_soft_timer;
268:                 }
269:                 
270:                 #endif
271:                 
272:                 void pwm_on(char index, char val)
273:                 {
9D012EC0      4FB0   ADDIU SP, SP, -8
9D012EC2      CBC1   SW S8, 4(SP)
9D012EC4      0FDD   MOVE S8, SP
9D012EC6      0C64   MOVE V1, A0
9D012EC8      0C45   MOVE V0, A1
9D012ECA  187E0008   SB V1, 8(S8)
9D012ECE  185E000C   SB V0, 12(S8)
274:                     //provede zapnuti nebo vypnuti CPPx (val=1 ON, val=0 OFF)
275:                     if(index==0)
276:                     {
277:                 #ifdef CCP1_PWM        
278:                         CCP1CON1bits.ON = val;                // Turn on MCCP module       
279:                 #endif    
280:                     }
281:                     else if (index==1)
282:                     {
283:                 #ifdef CCP2_PWM       
284:                         CCP2CON1bits.ON = val;                // Turn on MCCP module       
285:                 #endif        
286:                     }
287:                     else if (index==2)
288:                     {
289:                 #ifdef CCP3_PWM       
290:                         CCP3CON1bits.ON = val;                // Turn on MCCP module       
291:                 #endif        
292:                     } 
293:                     else if (index==3)
294:                     {
295:                 #ifdef CCP4_PWM       
296:                         CCP4CON1bits.ON = val;                // Turn on MCCP module       
297:                 #endif        
298:                     }     
299:                 }
9D012ED2      0FBE   MOVE SP, S8
9D012ED4      4BC1   LW S8, 4(SP)
9D012ED6      4C05   ADDIU SP, SP, 8
9D012ED8      45BF   JRC RA
9D012EDA      0C00   NOP
300:                 
301:                 void pwm_setPower(char index, int val)
302:                 {
9D012EDC      4FB0   ADDIU SP, SP, -8
9D012EDE      CBC1   SW S8, 4(SP)
9D012EE0      0FDD   MOVE S8, SP
9D012EE2      0C44   MOVE V0, A0
9D012EE4  F8BE000C   SW A1, 12(S8)
9D012EE8  185E0008   SB V0, 8(S8)
303:                     //nastavi power (CCPxRB) na zadanou hodnotu
304:                     //val - 0=nulovy vykon, PERIOD (4096)=max. vykon
305:                     //na zacatku cyklu je vystup nastaven na 1, val definuje okamzik vypnuti
306:                     //je-li CCPxRB=0 k sepnuti nedojde vubec   
307:                     
308:                     if(val > PERIOD) { val=PERIOD; }
9D012EEC  FC5E000C   LW V0, 12(S8)
9D012EF0  90421001   SLTI V0, V0, 4097
9D012EF2  100140A2   ADDI ZERO, AT, 16546
9D012EF4  40A20004   BNEZC V0, 0x9D012F00
9D012EF6  00043040   SRL ZERO, A0, 6
9D012EF8  30401000   ADDIU V0, ZERO, 4096
9D012EFA  1000F85E   ADDI ZERO, ZERO, -1954
9D012EFC  F85E000C   SW V0, 12(S8)
309:                     if(val < 0) { val=0; }
9D012F00  FC5E000C   LW V0, 12(S8)
9D012F04  40420003   BGEZ V0, 0x9D012F0E
9D012F06  00030C00   SLL ZERO, V1, 1
9D012F08      0C00   NOP
9D012F0A  F81E000C   SW ZERO, 12(S8)
310:                     
311:                     if(index==0)
9D012F0E  145E0008   LBU V0, 8(S8)
9D012F12  40A20008   BNEZC V0, 0x9D012F26
312:                     {
313:                         CCP1RB = val;
9D012F16  FC7E000C   LW V1, 12(S8)
9D012F1A  41A2BF80   LUI V0, 0xBF80
9D012F1C  BF80F862   LDC1 F28, -1950(ZERO)
9D012F1E  F8620170   SW V1, 368(V0)
9D012F22      CC29   B 0x9D012F76
9D012F24      0C00   NOP
314:                     }
315:                     else if(index==1)
9D012F26  147E0008   LBU V1, 8(S8)
9D012F2A      ED01   LI V0, 1
9D012F2C  B4430009   BNE V1, V0, 0x9D012F42
9D012F2E  00090C00   SLL ZERO, T1, 1
9D012F30      0C00   NOP
316:                     {
317:                         CCP2RB = val;
9D012F32  FC7E000C   LW V1, 12(S8)
9D012F36  41A2BF80   LUI V0, 0xBF80
9D012F38  BF80F862   LDC1 F28, -1950(ZERO)
9D012F3A  F8620270   SW V1, 624(V0)
9D012F3E      CC1B   B 0x9D012F76
9D012F40      0C00   NOP
318:                     }
319:                     else if (index==2)
9D012F42  147E0008   LBU V1, 8(S8)
9D012F46      ED02   LI V0, 2
9D012F48  B4430009   BNE V1, V0, 0x9D012F5E
9D012F4A  00090C00   SLL ZERO, T1, 1
9D012F4C      0C00   NOP
320:                     {
321:                         CCP3RB = val;
9D012F4E  FC7E000C   LW V1, 12(S8)
9D012F52  41A2BF80   LUI V0, 0xBF80
9D012F54  BF80F862   LDC1 F28, -1950(ZERO)
9D012F56  F8620370   SW V1, 880(V0)
9D012F58  0370CC0D   ADDQ_S.PH T9, S0, K1
9D012F5A      CC0D   B 0x9D012F76
9D012F5C      0C00   NOP
322:                     }
323:                     else if (index==3)
9D012F5E  147E0008   LBU V1, 8(S8)
9D012F62      ED03   LI V0, 3
9D012F64  B4430007   BNE V1, V0, 0x9D012F76
9D012F66  00070C00   SLL ZERO, A3, 1
9D012F68      0C00   NOP
324:                     {
325:                         CCP4RB = val;
9D012F6A  FC7E000C   LW V1, 12(S8)
9D012F6E  41A2BF80   LUI V0, 0xBF80
9D012F70  BF80F862   LDC1 F28, -1950(ZERO)
9D012F72  F8620470   SW V1, 1136(V0)
9D012F74      0470   ADDU S0, S0, A3
326:                     }    
327:                 }
9D012F76      0FBE   MOVE SP, S8
9D012F78      4BC1   LW S8, 4(SP)
9D012F7A      4C05   ADDIU SP, SP, 8
9D012F7C      45BF   JRC RA
9D012F7E      0C00   NOP
328:                 
329:                 int pwm_getProc(char index)
330:                 {
9D012F80      4FF9   ADDIU SP, SP, -16
9D012F82      CBC3   SW S8, 12(SP)
9D012F84      0FDD   MOVE S8, SP
9D012F86      0C44   MOVE V0, A0
9D012F88  185E0010   SB V0, 16(S8)
331:                     //vraci aktualni vykon v proc
332:                     
333:                     int val=0;
9D012F8C  F81E0000   SW ZERO, 0(S8)
334:                     if(index==0) { val=CCP1RB; }
9D012F90  145E0010   LBU V0, 16(S8)
9D012F94  40A20008   BNEZC V0, 0x9D012FA8
9D012F98  41A2BF80   LUI V0, 0xBF80
9D012F9A  BF80FC42   LDC1 F28, -958(ZERO)
9D012F9C  FC420170   LW V0, 368(V0)
9D012FA0  F85E0000   SW V0, 0(S8)
9D012FA4      CC1B   B 0x9D012FDC
9D012FA6      0C00   NOP
335:                     else if(index==1) { val=CCP2RB; }
9D012FA8  147E0010   LBU V1, 16(S8)
9D012FAC      ED01   LI V0, 1
9D012FAE  B4430009   BNE V1, V0, 0x9D012FC4
9D012FB0  00090C00   SLL ZERO, T1, 1
9D012FB2      0C00   NOP
9D012FB4  41A2BF80   LUI V0, 0xBF80
9D012FB6  BF80FC42   LDC1 F28, -958(ZERO)
9D012FB8  FC420270   LW V0, 624(V0)
9D012FBC  F85E0000   SW V0, 0(S8)
9D012FBE  0000CC0D   ADDQ_S.PH T9, ZERO, ZERO
9D012FC0      CC0D   B 0x9D012FDC
9D012FC2      0C00   NOP
336:                     else if(index==2) { val=CCP3RB; }
9D012FC4  147E0010   LBU V1, 16(S8)
9D012FC8      ED02   LI V0, 2
9D012FCA  B4430007   BNE V1, V0, 0x9D012FDC
9D012FCC  00070C00   SLL ZERO, A3, 1
9D012FCE      0C00   NOP
9D012FD0  41A2BF80   LUI V0, 0xBF80
9D012FD2  BF80FC42   LDC1 F28, -958(ZERO)
9D012FD4  FC420370   LW V0, 880(V0)
9D012FD8  F85E0000   SW V0, 0(S8)
337:                     
338:                     //prida 0,5%
339:                     return (val+PERIOD/200)*100/PERIOD;
9D012FDC  FC5E0000   LW V0, 0(S8)
9D012FE0      6D2A   ADDIU V0, V0, 20
9D012FE2      2524   SLL V0, V0, 2
9D012FE4      25A4   SLL V1, V0, 2
9D012FE6      0534   ADDU V0, V0, V1
9D012FE8      25A4   SLL V1, V0, 2
9D012FEA      0534   ADDU V0, V0, V1
9D012FEC  30620FFF   ADDIU V1, V0, 4095
9D012FEE      0FFF   MOVE RA, RA
9D012FF0  90820000   SLTI A0, V0, 0
9D012FF4  00831018   MOVN V0, V1, A0
9D012FF6  10180042   ADDI ZERO, T8, 66
9D012FF8  00426080   SRA V0, V0, 12
9D012FFA  60800FBE   LWL A0, -66(ZERO)
340:                 }
9D012FFC      0FBE   MOVE SP, S8
9D012FFE      4BC3   LW S8, 12(SP)
9D013000      4C09   ADDIU SP, SP, 16
9D013002      45BF   JRC RA
341:                 
342:                 int pwm_getValue(char index)
343:                 {
9D013004      4FF9   ADDIU SP, SP, -16
9D013006      CBC3   SW S8, 12(SP)
9D013008      0FDD   MOVE S8, SP
9D01300A      0C44   MOVE V0, A0
9D01300C  185E0010   SB V0, 16(S8)
344:                     int val=0;
9D013010  F81E0000   SW ZERO, 0(S8)
345:                     if(index==0) { val=CCP1RB; }
9D013014  145E0010   LBU V0, 16(S8)
9D013018  40A20008   BNEZC V0, 0x9D01302C
9D01301C  41A2BF80   LUI V0, 0xBF80
9D01301E  BF80FC42   LDC1 F28, -958(ZERO)
9D013020  FC420170   LW V0, 368(V0)
9D013024  F85E0000   SW V0, 0(S8)
9D013028      CC1B   B 0x9D013060
9D01302A      0C00   NOP
346:                     else if(index==1) { val=CCP2RB; }
9D01302C  147E0010   LBU V1, 16(S8)
9D013030      ED01   LI V0, 1
9D013032  B4430009   BNE V1, V0, 0x9D013048
9D013034  00090C00   SLL ZERO, T1, 1
9D013036      0C00   NOP
9D013038  41A2BF80   LUI V0, 0xBF80
9D01303A  BF80FC42   LDC1 F28, -958(ZERO)
9D01303C  FC420270   LW V0, 624(V0)
9D013040  F85E0000   SW V0, 0(S8)
9D013042  0000CC0D   ADDQ_S.PH T9, ZERO, ZERO
9D013044      CC0D   B 0x9D013060
9D013046      0C00   NOP
347:                     else if(index==2) { val=CCP3RB; }    
9D013048  147E0010   LBU V1, 16(S8)
9D01304C      ED02   LI V0, 2
9D01304E  B4430007   BNE V1, V0, 0x9D013060
9D013050  00070C00   SLL ZERO, A3, 1
9D013052      0C00   NOP
9D013054  41A2BF80   LUI V0, 0xBF80
9D013056  BF80FC42   LDC1 F28, -958(ZERO)
9D013058  FC420370   LW V0, 880(V0)
9D01305C  F85E0000   SW V0, 0(S8)
348:                     return val;
9D013060  FC5E0000   LW V0, 0(S8)
349:                 }
9D013064      0FBE   MOVE SP, S8
9D013066      4BC3   LW S8, 12(SP)
9D013068      4C09   ADDIU SP, SP, 16
9D01306A      45BF   JRC RA
350:                 
351:                 void pwm_init()
352:                 {
9D01306C      4FB0   ADDIU SP, SP, -8
9D01306E      CBC1   SW S8, 4(SP)
9D013070      0FDD   MOVE S8, SP
353:                     //nastavi modul, ale zustava OFF, zapnout volanim fce pwm_on(index, 1)
354:                     
355:                 #ifdef CCP1_PWM  
356:                 
357:                         // Set MCCP operating mode
358:                         CCP1CON1bits.CCSEL = 0;             // Set MCCP operating mode (OC mode)
359:                         CCP1CON1bits.MOD = 0b0101;          // Set mode (Buffered Dual-Compare/PWM mode)
360:                 
361:                         //Configure MCCP Timebase
362:                         CCP1CON1bits.T32 = 0;               // Set timebase width (16-bit)
363:                         CCP1CON1bits.TMRSYNC = 0;           // Set timebase synchronization (Synchronized)
364:                         CCP1CON1bits.CLKSEL = 0b000;        // Set the clock source (Tcy)
365:                         CCP1CON1bits.TMRPS = 0b00;          // Set the clock prescaler (1:1)
366:                         CCP1CON1bits.TRIGEN = 0;            // Set Sync/Triggered mode (Synchronous)
367:                         CCP1CON1bits.SYNC = 0b00000;        // Select Sync/Trigger source (Self-sync)
368:                 
369:                         //Configure MCCP output for PWM signal
370:                         CCP1CON2bits.OCAEN = 1;             // Enable desired output signals (OC1A)
371:                         CCP1CON3bits.OUTM = 0b000;          // Set advanced output modes (Standard output)
372:                         CCP1CON3bits.POLACE = 0;            // Configure output polarity (Active High)
373:                         CCP1TMRbits.TMRL = 0x0000;          // Initialize timer prior to enable module.
374:                 
375:                         CCP1PRbits.PRL = PERIOD;             // Configure timebase period
376:                         CCP1RA = 0x0;                        // Set the rising edge compare value
377:                         CCP1RB = 0;                          // Set the falling edge compare value
378:                         //CCP1CON1bits.ON = 1;                 // Turn on MCCP module  
379:                     
380:                       
381:                 #endif
382:                 
383:                 #ifdef CCP2_PWM
384:                     //RP5=SCCP2, nastaveni vystupu SCCP2 na RP5 (SOIC28 = RB4, pin 11)
385:                     //RPOR2bits.RP11R=6;
386:                     RPOR1bits.RP5R=6;
387:                     
388:                     // Set MCCP operating mode
389:                     CCP2CON1bits.CCSEL = 0;             // Set MCCP operating mode (OC mode)
390:                     CCP2CON1bits.MOD = 0b0101;          // Set mode (Buffered Dual-Compare/PWM mode)
391:                     
392:                     //Configure MCCP Timebase
393:                     CCP2CON1bits.T32 = 0;               // Set timebase width (16-bit)
394:                     CCP2CON1bits.TMRSYNC = 0;           // Set timebase synchronization (Synchronized)
395:                     CCP2CON1bits.CLKSEL = 0b000;        // Set the clock source (Tcy)
396:                     CCP2CON1bits.TMRPS = 0b00;          // Set the clock prescaler (1:1)
397:                     CCP2CON1bits.TRIGEN = 0;            // Set Sync/Triggered mode (Synchronous)
398:                     CCP2CON1bits.SYNC = 0b00000;        // Select Sync/Trigger source (Self-sync)
399:                     
400:                     //Configure MCCP output for PWM signal
401:                     CCP2CON2bits.OCAEN = 1;             // Enable desired output signals (OC1A)
402:                     //CCP2CON3bits.OUTM = 0b000;          // Set advanced output modes (Standard output)
403:                     CCP2CON3bits.POLACE = 0;            // Configure output polarity (Active High)
404:                     CCP2TMRbits.TMRL = 0x0000;          // Initialize timer prior to enable module.
405:                     
406:                     CCP2PRbits.PRL = PERIOD;            // Configure timebase period
407:                     CCP2RA = 0x0;                       // Set the rising edge compare value
408:                     CCP2RB = 0;                         // Set the falling edge compare value
409:                     //CCP1CON1bits.ON = 1;              // Turn on MCCP module    
410:                 #endif    
411:                 
412:                 #ifdef CCP3_PWM    
413:                     //RP6=SCCP3, nastaveni vystupu SCCP3 na RP6 (SOIC28 = RA4, pin 12)
414:                     //RPOR1bits.RP6R=7;  
415:                     
416:                     
417:                     // Set MCCP operating mode
418:                     CCP3CON1bits.CCSEL = 0;             // Set MCCP operating mode (OC mode)
419:                     CCP3CON1bits.MOD = 0b0101;          // Set mode (Buffered Dual-Compare/PWM mode)
420:                     
421:                     //Configure MCCP Timebase
422:                     CCP3CON1bits.T32 = 0;               // Set timebase width (16-bit)
423:                     CCP3CON1bits.TMRSYNC = 0;           // Set timebase synchronization (Synchronized)
424:                     CCP3CON1bits.CLKSEL = 0b000;        // Set the clock source (Tcy)
425:                     CCP3CON1bits.TMRPS = 0b00;          // Set the clock prescaler (1:1)
426:                     CCP3CON1bits.TRIGEN = 0;            // Set Sync/Triggered mode (Synchronous)
427:                     CCP3CON1bits.SYNC = 0b00000;        // Select Sync/Trigger source (Self-sync)
428:                     
429:                     //Configure MCCP output for PWM signal
430:                     CCP3CON2bits.OCAEN = 1;             // Enable desired output signals (OC1A)
431:                     //CCP3CON3bits.OUTM = 0b000;          // Set advanced output modes (Standard output)
432:                     CCP3CON3bits.POLACE = 0;            // Configure output polarity (Active High)
433:                     CCP3TMRbits.TMRL = 0x0000;          // Initialize timer prior to enable module.
434:                     
435:                     CCP3PRbits.PRL = PERIOD;            // Configure timebase period
436:                     CCP3RA = 0x0;                       // Set the rising edge compare value
437:                     CCP3RB = 0;                         // Set the falling edge compare value
438:                     //CCP1CON1bits.ON = 1;              // Turn on MCCP module    
439:                 #endif      
440:                 
441:                 #ifdef CCP4_PWM    
442:                     //RP6=SCCP3, nastaveni vystupu SCCP3 na RP6 (SOIC28 = RA4, pin 12)
443:                     //RPOR1bits.RP6R=7;
444:                     
445:                     //36-pin, PIN9, RB4, RP10=11, CCP4OUT
446:                     RPOR2bits.RP10R=11;
447:                     
448:                     
449:                     // Set MCCP operating mode
450:                     CCP4CON1bits.CCSEL = 0;             // Set MCCP operating mode (OC mode)
451:                     CCP4CON1bits.MOD = 0b0101;          // Set mode (Buffered Dual-Compare/PWM mode)
452:                     
453:                     //Configure MCCP Timebase
454:                     CCP4CON1bits.T32 = 0;               // Set timebase width (16-bit)
455:                     CCP4CON1bits.TMRSYNC = 0;           // Set timebase synchronization (Synchronized)
456:                     CCP4CON1bits.CLKSEL = 0b000;        // Set the clock source (Tcy)
457:                     CCP4CON1bits.TMRPS = 0b00;          // Set the clock prescaler (1:1)
458:                     CCP4CON1bits.TRIGEN = 0;            // Set Sync/Triggered mode (Synchronous)
459:                     CCP4CON1bits.SYNC = 0b00000;        // Select Sync/Trigger source (Self-sync)
460:                     
461:                     //Configure MCCP output for PWM signal
462:                     CCP4CON2bits.OCAEN = 1;             // Enable desired output signals (OC1A)
463:                     //CCP3CON3bits.OUTM = 0b000;          // Set advanced output modes (Standard output)
464:                     CCP4CON3bits.POLACE = 0;            // Configure output polarity (Active High)
465:                     CCP4TMRbits.TMRL = 0x0000;          // Initialize timer prior to enable module.
466:                     
467:                     CCP4PRbits.PRL = PERIOD;            // Configure timebase period
468:                     CCP4RA = 0x0;                       // Set the rising edge compare value
469:                     CCP4RB = 0;                         // Set the falling edge compare value
470:                     //CCP1CON1bits.ON = 1;              // Turn on MCCP module    
471:                 #endif    
472:                     
473:                 }
9D013072      0FBE   MOVE SP, S8
474:                 
475:                 #endif
---  d:/bos/bos/portwriter.c  ---------------------------------------------------------------------------
1:                   #include <xc.h>
2:                   #include <stdio.h>
3:                   #include <stdlib.h>
4:                   #include "globals.h"
5:                   #include "asm.h"
6:                   #include "graphics.h"
7:                   
8:                   static void spiWriteBuffer(void* info, char* buffer, short len);
9:                   static void spiWriteBufferMode(void* info, char* buffer, short len, char mode);
10:                  static void spiGetPort(void* info);
11:                  static void spiFreePort(void* info);
12:                  static void spiSetBusMode(void* info, char mode);
13:                  
14:                  static void i2cWriteBuffer(void* info, char* buffer, short len);
15:                  static void i2cGetPort(void* info);
16:                  static void i2cFreePort(void* info);
17:                  
18:                  void portWriter_init(PORT_INFO* info, char periph_type, char index)
19:                  {
9D0124C4      4FF5   ADDIU SP, SP, -24
9D0124C6      CBE5   SW RA, 20(SP)
9D0124C8      CBC4   SW S8, 16(SP)
9D0124CA      0FDD   MOVE S8, SP
9D0124CC  F89E0018   SW A0, 24(S8)
9D0124CE  00180C65   MULEQ_S.W.PHR AT, T8, ZERO
9D0124D0      0C65   MOVE V1, A1
9D0124D2      0C46   MOVE V0, A2
9D0124D4  187E001C   SB V1, 28(S8)
9D0124D8  185E0020   SB V0, 32(S8)
20:                      info->periphType=periph_type;
9D0124DC  FC5E0018   LW V0, 24(S8)
9D0124E0  147E001C   LBU V1, 28(S8)
9D0124E4  18620040   SB V1, 64(V0)
21:                      info->portIndex=index;
9D0124E8  FC5E0018   LW V0, 24(S8)
9D0124EC  147E0020   LBU V1, 32(S8)
9D0124F0  1862003C   SB V1, 60(V0)
9D0124F2  003C0C40   SRL AT, GP, 1
22:                      if(periph_type==PERIPH_TYPE.spi)
9D0124F4      0C40   MOVE V0, ZERO
9D0124F6  147E001C   LBU V1, 28(S8)
9D0124FA  B4430030   BNE V1, V0, 0x9D01255E
9D0124FC  00300C00   SLL AT, S0, 1
9D0124FE      0C00   NOP
23:                      {
24:                          //info->writeBuffer=&writeBufferSpi;      
25:                          info->writeBuffer=&spiWriteBuffer;
9D012500  FC5E0018   LW V0, 24(S8)
9D012504  41A39D01   LUI V1, 0x9D01
9D012506  9D013063   LWC1 F8, 12387(AT)
9D012508  306325A5   ADDIU V1, V1, 9637
9D01250A      25A5   SRL V1, V0, 2
9D01250C      E9A0   SW V1, 0(V0)
26:                          info->writeBufferMode=&spiWriteBufferMode;
9D01250E  FC5E0018   LW V0, 24(S8)
9D012512  41A39D01   LUI V1, 0x9D01
9D012514  9D013063   LWC1 F8, 12387(AT)
9D012516  306325ED   ADDIU V1, V1, 9709
9D012518      25ED   SRL V1, A2, 6
9D01251A      E9A1   SW V1, 4(V0)
27:                          
28:                          info->getPort=&spiGetPort;
9D01251C  FC5E0018   LW V0, 24(S8)
9D012520  41A39D01   LUI V1, 0x9D01
9D012522  9D013063   LWC1 F8, 12387(AT)
9D012524  30632641   ADDIU V1, V1, 9793
9D012526      2641   SRL A0, A0, 8
9D012528      E9A3   SW V1, 12(V0)
29:                          info->freePort=&spiFreePort;
9D01252A  FC5E0018   LW V0, 24(S8)
9D01252E  41A39D01   LUI V1, 0x9D01
9D012530  9D013063   LWC1 F8, 12387(AT)
9D012532  30632681   ADDIU V1, V1, 9857
9D012534      2681   SRL A1, S0, 8
9D012536      E9A4   SW V1, 16(V0)
30:                          info->setBusMode=&spiSetBusMode;
9D012538  FC5E0018   LW V0, 24(S8)
9D01253C  41A39D01   LUI V1, 0x9D01
9D01253E  9D013063   LWC1 F8, 12387(AT)
9D012540  306326B1   ADDIU V1, V1, 9905
9D012542      26B1   SRL A1, V1, 8
9D012544      E9A7   SW V1, 28(V0)
31:                  
32:                          info->directModeHwBuffer=(int*)spi_getHwBuffer(index);
9D012546  145E0020   LBU V0, 32(S8)
9D01254A      0C82   MOVE A0, V0
9D01254C  768072FA   JALS spi_getHwBuffer
9D01254E  72FA0C00   XORI S7, K0, 3072
9D012550      0C00   NOP
9D012552      0C62   MOVE V1, V0
9D012554  FC5E0018   LW V0, 24(S8)
9D012558      E9A8   SW V1, 32(V0)
9D01255A      CC1F   B 0x9D01259A
9D01255C      0C00   NOP
33:                      }
34:                      else if(periph_type==PERIPH_TYPE.i2c)
9D01255E      ED02   LI V0, 2
9D012560  147E001C   LBU V1, 28(S8)
9D012564  B4430019   BNE V1, V0, 0x9D01259A
9D012566  00190C00   SLL ZERO, T9, 1
9D012568      0C00   NOP
35:                      {
36:                          info->writeBuffer=&i2cWriteBuffer;
9D01256A  FC5E0018   LW V0, 24(S8)
9D01256E  41A39D01   LUI V1, 0x9D01
9D012570  9D013063   LWC1 F8, 12387(AT)
9D012572  306326ED   ADDIU V1, V1, 9965
9D012574      26ED   SRL A1, A2, 6
9D012576      E9A0   SW V1, 0(V0)
37:                          info->writeBufferMode=NULL;
9D012578  FC5E0018   LW V0, 24(S8)
9D01257C      E821   SW S0, 4(V0)
38:                          
39:                          info->getPort=&i2cGetPort;
9D01257E  FC5E0018   LW V0, 24(S8)
9D012582  41A39D01   LUI V1, 0x9D01
9D012584  9D013063   LWC1 F8, 12387(AT)
9D012586  30632739   ADDIU V1, V1, 10041
9D012588      2739   SRL A2, V1, 4
9D01258A      E9A3   SW V1, 12(V0)
40:                          info->freePort=&i2cFreePort;
9D01258C  FC5E0018   LW V0, 24(S8)
9D012590  41A39D01   LUI V1, 0x9D01
9D012592  9D013063   LWC1 F8, 12387(AT)
9D012594  30632775   ADDIU V1, V1, 10101
9D012596      2775   SRL A2, A3, 2
9D012598      E9A4   SW V1, 16(V0)
41:                      }
42:                  }
9D01259A      0FBE   MOVE SP, S8
9D01259C      4BE5   LW RA, 20(SP)
9D01259E      4BC4   LW S8, 16(SP)
9D0125A0      4C0D   ADDIU SP, SP, 24
9D0125A2      45BF   JRC RA
43:                  
44:                  
45:                  
46:                  //<editor-fold defaultstate="collapsed" desc="SPI">
47:                  
48:                  static void spiWriteBuffer(void* info, char* buffer, short len) 
49:                  {
9D0125A4      4FF1   ADDIU SP, SP, -32
9D0125A6      CBE7   SW RA, 28(SP)
9D0125A8      CBC6   SW S8, 24(SP)
9D0125AA      0FDD   MOVE S8, SP
9D0125AC  F89E0020   SW A0, 32(S8)
9D0125B0  F8BE0024   SW A1, 36(S8)
9D0125B4      0C46   MOVE V0, A2
9D0125B6  385E0028   SH V0, 40(S8)
50:                      PORT_INFO* i = (PORT_INFO*) info;
9D0125BA  FC5E0020   LW V0, 32(S8)
9D0125BE  F85E0010   SW V0, 16(S8)
51:                      spi_ExchangeDE(i->portIndex, buffer, NULL, len);
9D0125C2  FC5E0010   LW V0, 16(S8)
9D0125C6  1442003C   LBU V0, 60(V0)
9D0125CA      0C62   MOVE V1, V0
9D0125CC  3C5E0028   LH V0, 40(S8)
9D0125D0      0C83   MOVE A0, V1
9D0125D2  FCBE0024   LW A1, 36(S8)
9D0125D4  00240CC0   ROTR AT, A0, 1
9D0125D6      0CC0   MOVE A2, ZERO
9D0125D8      0CE2   MOVE A3, V0
9D0125DA  76807116   JALS spi_ExchangeDE
9D0125DC  71160C00   XORI T0, S6, 3072
9D0125DE      0C00   NOP
52:                  }
9D0125E0      0FBE   MOVE SP, S8
9D0125E2      4BE7   LW RA, 28(SP)
9D0125E4      4BC6   LW S8, 24(SP)
9D0125E6      4C11   ADDIU SP, SP, 32
9D0125E8      45BF   JRC RA
9D0125EA      0C00   NOP
53:                  
54:                  static void spiWriteBufferMode(void* info, char* buffer, short len, char mode) 
55:                  {
9D0125EC      4FED   ADDIU SP, SP, -40
9D0125EE      CBE9   SW RA, 36(SP)
9D0125F0      CBC8   SW S8, 32(SP)
9D0125F2      0FDD   MOVE S8, SP
9D0125F4  F89E0028   SW A0, 40(S8)
9D0125F8  F8BE002C   SW A1, 44(S8)
9D0125FC      0C66   MOVE V1, A2
9D0125FE      0C47   MOVE V0, A3
9D012600  387E0030   SH V1, 48(S8)
9D012604  185E0034   SB V0, 52(S8)
56:                      PORT_INFO* i = (PORT_INFO*) info;
9D012608  FC5E0028   LW V0, 40(S8)
9D01260C  F85E0018   SW V0, 24(S8)
57:                      spi_ExchangeModeDE(i->portIndex, buffer, NULL, len, mode);
9D012610  FC5E0018   LW V0, 24(S8)
9D012614  1442003C   LBU V0, 60(V0)
9D012618      0C62   MOVE V1, V0
9D01261A  3C5E0030   LH V0, 48(S8)
9D01261E  149E0034   LBU A0, 52(S8)
9D012622      C884   SW A0, 16(SP)
9D012624      0C83   MOVE A0, V1
9D012626  FCBE002C   LW A1, 44(S8)
9D012628  002C0CC0   ROTR AT, T4, 1
9D01262A      0CC0   MOVE A2, ZERO
9D01262C      0CE2   MOVE A3, V0
9D01262E  768071B2   JALS spi_ExchangeModeDE
9D012630  71B20C00   XORI T5, S2, 3072
9D012632      0C00   NOP
58:                  }
9D012634      0FBE   MOVE SP, S8
9D012636      4BE9   LW RA, 36(SP)
9D012638      4BC8   LW S8, 32(SP)
9D01263A      4C15   ADDIU SP, SP, 40
9D01263C      45BF   JRC RA
9D01263E      0C00   NOP
59:                  
60:                  static void spiGetPort(void* info) 
61:                  {
9D012640      4FF1   ADDIU SP, SP, -32
9D012642      CBE7   SW RA, 28(SP)
9D012644      CBC6   SW S8, 24(SP)
9D012646      0FDD   MOVE S8, SP
9D012648  F89E0020   SW A0, 32(S8)
62:                      PORT_INFO* i = (PORT_INFO*) info;
9D01264C  FC5E0020   LW V0, 32(S8)
9D012650  F85E0010   SW V0, 16(S8)
63:                      spi_Use(i->portIndex, 1, i->finishFn, i->eventFn);
9D012654  FC5E0010   LW V0, 16(S8)
9D012658  1442003C   LBU V0, 60(V0)
9D01265C      0C82   MOVE A0, V0
9D01265E  FC5E0010   LW V0, 16(S8)
9D012662      69A6   LW V1, 24(V0)
9D012664  FC5E0010   LW V0, 16(S8)
9D012668      6925   LW V0, 20(V0)
9D01266A      EE81   LI A1, 1
9D01266C      0CC3   MOVE A2, V1
9D01266E      0CE2   MOVE A3, V0
9D012670  76807296   JALS spi_Use
9D012672  72960C00   XORI S4, S6, 3072
9D012674      0C00   NOP
64:                  }
9D012676      0FBE   MOVE SP, S8
9D012678      4BE7   LW RA, 28(SP)
9D01267A      4BC6   LW S8, 24(SP)
9D01267C      4C11   ADDIU SP, SP, 32
9D01267E      45BF   JRC RA
65:                  
66:                  static void spiFreePort(void* info) 
67:                  {
9D012680      4FF1   ADDIU SP, SP, -32
9D012682      CBE7   SW RA, 28(SP)
9D012684      CBC6   SW S8, 24(SP)
9D012686      0FDD   MOVE S8, SP
9D012688  F89E0020   SW A0, 32(S8)
68:                      PORT_INFO* i = (PORT_INFO*) info;
9D01268C  FC5E0020   LW V0, 32(S8)
9D012690  F85E0010   SW V0, 16(S8)
69:                      spi_Free(i->portIndex);
9D012694  FC5E0010   LW V0, 16(S8)
9D012698  1442003C   LBU V0, 60(V0)
9D01269C      0C82   MOVE A0, V0
9D01269E  7680726A   JALS spi_Free
9D0126A0  726A0C00   XORI S3, T2, 3072
9D0126A2      0C00   NOP
70:                  }
9D0126A4      0FBE   MOVE SP, S8
9D0126A6      4BE7   LW RA, 28(SP)
9D0126A8      4BC6   LW S8, 24(SP)
9D0126AA      4C11   ADDIU SP, SP, 32
9D0126AC      45BF   JRC RA
9D0126AE      0C00   NOP
71:                  
72:                  static void spiSetBusMode(void* info, char mode) 
73:                  {
9D0126B0      4FF1   ADDIU SP, SP, -32
9D0126B2      CBE7   SW RA, 28(SP)
9D0126B4      CBC6   SW S8, 24(SP)
9D0126B6      0FDD   MOVE S8, SP
9D0126B8  F89E0020   SW A0, 32(S8)
9D0126BA  00200C45   CMP.LT.PH ZERO, AT
9D0126BC      0C45   MOVE V0, A1
9D0126BE  185E0024   SB V0, 36(S8)
74:                      PORT_INFO* i = (PORT_INFO*) info;
9D0126C2  FC5E0020   LW V0, 32(S8)
9D0126C6  F85E0010   SW V0, 16(S8)
75:                      spi_setBusMode(i->portIndex, mode);
9D0126CA  FC5E0010   LW V0, 16(S8)
9D0126CE  1442003C   LBU V0, 60(V0)
9D0126D2      0C62   MOVE V1, V0
9D0126D4  145E0024   LBU V0, 36(S8)
9D0126D8      0C83   MOVE A0, V1
9D0126DA      0CA2   MOVE A1, V0
9D0126DC  7680730E   JALS spi_setBusMode
9D0126DE  730E0C00   XORI T8, T6, 3072
9D0126E0      0C00   NOP
76:                  }
9D0126E2      0FBE   MOVE SP, S8
9D0126E4      4BE7   LW RA, 28(SP)
9D0126E6      4BC6   LW S8, 24(SP)
9D0126E8      4C11   ADDIU SP, SP, 32
9D0126EA      45BF   JRC RA
77:                  
78:                  // </editor-fold>
79:                  
80:                  // <editor-fold defaultstate="collapsed" desc="I2C">
81:                  
82:                  static void i2cWriteBuffer(void* info, char* buffer, short len) {
9D0126EC      4FF1   ADDIU SP, SP, -32
9D0126EE      CBE7   SW RA, 28(SP)
9D0126F0      CBC6   SW S8, 24(SP)
9D0126F2      0FDD   MOVE S8, SP
9D0126F4  F89E0020   SW A0, 32(S8)
9D0126F8  F8BE0024   SW A1, 36(S8)
9D0126FC      0C46   MOVE V0, A2
9D0126FE  385E0028   SH V0, 40(S8)
83:                      PORT_INFO* i = (PORT_INFO*) info;
9D012702  FC5E0020   LW V0, 32(S8)
9D012706  F85E0010   SW V0, 16(S8)
84:                      i2c_WriteDE(i->portIndex, buffer, len, i->i2cAddress);
9D01270A  FC5E0010   LW V0, 16(S8)
9D01270E  1442003C   LBU V0, 60(V0)
9D012712      0C82   MOVE A0, V0
9D012714  3C7E0028   LH V1, 40(S8)
9D012718  FC5E0010   LW V0, 16(S8)
9D01271C  1442003F   LBU V0, 63(V0)
9D012720  FCBE0024   LW A1, 36(S8)
9D012724      0CC3   MOVE A2, V1
9D012726      0CE2   MOVE A3, V0
9D012728  76808A1E   JALS i2c_WriteDE
9D01272A      8A1E   SB A0, 14(S1)
9D01272C      0C00   NOP
85:                  }
9D01272E      0FBE   MOVE SP, S8
9D012730      4BE7   LW RA, 28(SP)
9D012732      4BC6   LW S8, 24(SP)
9D012734      4C11   ADDIU SP, SP, 32
9D012736      45BF   JRC RA
86:                  
87:                  static void i2cGetPort(void* info) {
9D012738      4FF1   ADDIU SP, SP, -32
9D01273A      CBE7   SW RA, 28(SP)
9D01273C      CBC6   SW S8, 24(SP)
9D01273E      0FDD   MOVE S8, SP
9D012740  F89E0020   SW A0, 32(S8)
88:                      PORT_INFO* i = (PORT_INFO*) info;
9D012744  FC5E0020   LW V0, 32(S8)
9D012748  F85E0010   SW V0, 16(S8)
89:                      i2c_Use(i->portIndex, 1, i->finishFn);
9D01274C  FC5E0010   LW V0, 16(S8)
9D012750  1442003C   LBU V0, 60(V0)
9D012754      0C62   MOVE V1, V0
9D012756  FC5E0010   LW V0, 16(S8)
9D01275A      6926   LW V0, 24(V0)
9D01275C      0C83   MOVE A0, V1
9D01275E      EE81   LI A1, 1
9D012760      0CC2   MOVE A2, V0
9D012762  768089C8   JALS i2c_Use
9D012764      89C8   SB V1, 8(A0)
9D012766      0C00   NOP
90:                  }
9D012768      0FBE   MOVE SP, S8
9D01276A      4BE7   LW RA, 28(SP)
9D01276C      4BC6   LW S8, 24(SP)
9D01276E      4C11   ADDIU SP, SP, 32
9D012770      45BF   JRC RA
9D012772      0C00   NOP
91:                  
92:                  static void i2cFreePort(void* info) {
9D012774      4FF1   ADDIU SP, SP, -32
9D012776      CBE7   SW RA, 28(SP)
9D012778      CBC6   SW S8, 24(SP)
9D01277A      0FDD   MOVE S8, SP
9D01277C  F89E0020   SW A0, 32(S8)
93:                      PORT_INFO* i = (PORT_INFO*) info;
9D012780  FC5E0020   LW V0, 32(S8)
9D012784  F85E0010   SW V0, 16(S8)
94:                      i2c_Free(i->portIndex);
9D012788  FC5E0010   LW V0, 16(S8)
9D01278C  1442003C   LBU V0, 60(V0)
9D012790      0C82   MOVE A0, V0
9D012792  7680899E   JALS i2c_Free
9D012794      899E   SB V1, 14(S1)
9D012796      0C00   NOP
95:                  }
9D012798      0FBE   MOVE SP, S8
96:                  
97:                  // </editor-fold>
---  d:/bos/bos/periph.c  -------------------------------------------------------------------------------
1:                   #include <xc.h>
2:                   #include <stdio.h>
3:                   #include <stdlib.h>
4:                   #include "periph.h"
5:                   #include "def.h"
6:                   #include "asm.h"
7:                   
8:                   
9:                   
10:                  void periph_init()
11:                  {
9D012CE4      4FB0   ADDIU SP, SP, -8
9D012CE6      CBC1   SW S8, 4(SP)
9D012CE8      0FDD   MOVE S8, SP
12:                      
13:                  #ifdef PIC32MZ
14:                      
15:                      TRISH=0b1111111111111000;
16:                      PORTH=0x0;
17:                      LATHSET=0b000;
18:                      
19:                  #endif    
20:                      
21:                  #ifdef PIC32MM0064_28pin
22:                      
23:                      
24:                      /****************************************************************************
25:                       * Setting the Output Latch SFR(s)
26:                       ***************************************************************************/
27:                      LATA = 0xFFFF;
28:                      LATB = 0xFFFF;
29:                      LATC = 0xFFFF;
30:                      
31:                      ANSELA=0;
32:                      ANSELB=0;
33:                      ANSELC=0;
34:                      //direction out (0) 9,8,6,5
35:                      //TRISB = 0xFC9F; //BC9F; 
36:                      //PIC32MM0064
37:                  
38:                      TRISBbits.TRISB5=0;     //LED   pin 14
39:                      TRISBbits.TRISB6=0;     //D/C   pin 15
40:                      TRISBbits.TRISB8=0;     //CLK   pin 17
41:                      TRISBbits.TRISB9=0;     //DO    pin 18    
42:                      TRISBbits.TRISB7=0;     //RESET pin 16
43:                      TRISBbits.TRISB3=0;     //CS    pin 11
44:                      //ANSELBbits.ANSB3=0;     //CS    pin 7
45:                  
46:                      //TRISA=0;
47:                      //TRISB=0;
48:                      //TRISC=0;
49:                      
50:                      
51:                      setPortDigOut(PORTB_BASE, BIT3 | BIT5 | BIT6 | BIT7 | BIT8 | BIT9);
52:                  
53:                      //SPI2
54:                      //RPOR2bits.RP12R=3;
55:                      //RPOR4bits.RP18R=4;
56:                      
57:                  #endif
58:                      
59:                  #ifdef PIC32MM0256_36pin
60:                      
61:                      //nastaveni IO portu v zavislosti a typu IC a aplikaci
62:                      //PIC32MM0256
63:                      //tris=1 - input, tris=0 - output, ansel=1 analog input
64:                      LATA = 0xFFFF;
9D012CEA  41A2BF80   LUI V0, 0xBF80
9D012CEC  BF805060   LDC1 F28, 20576(ZERO)
9D012CEE  5060FFFF   ORI V1, ZERO, -1
9D012CF0  FFFFF862   LW RA, -1950(RA)
9D012CF2  F8622BE0   SW V1, 11232(V0)
9D012CF4      2BE0   LHU A3, 0(A2)
65:                      LATB = 0xFFFF;
9D012CF6  41A2BF80   LUI V0, 0xBF80
9D012CF8  BF805060   LDC1 F28, 20576(ZERO)
9D012CFA  5060FFFF   ORI V1, ZERO, -1
9D012CFC  FFFFF862   LW RA, -1950(RA)
9D012CFE  F8622CE0   SW V1, 11488(V0)
9D012D00      2CE0   ANDI S1, A2, 0x80
66:                      LATC = 0xFFFF;
9D012D02  41A2BF80   LUI V0, 0xBF80
9D012D04  BF805060   LDC1 F28, 20576(ZERO)
9D012D06  5060FFFF   ORI V1, ZERO, -1
9D012D08  FFFFF862   LW RA, -1950(RA)
9D012D0A  F8622DE0   SW V1, 11744(V0)
9D012D0C      2DE0   ANDI V1, A2, 0x80
67:                      
68:                      ANSELA=0;
9D012D0E  41A2BF80   LUI V0, 0xBF80
9D012D10  BF80F802   LDC1 F28, -2046(ZERO)
9D012D12  F8022BB0   SW ZERO, 11184(V0)
9D012D14      2BB0   LHU A3, 0(V1)
69:                      ANSELB=0;
9D012D16  41A2BF80   LUI V0, 0xBF80
9D012D18  BF80F802   LDC1 F28, -2046(ZERO)
9D012D1A  F8022CB0   SW ZERO, 11440(V0)
9D012D1C      2CB0   ANDI S1, V1, 0x80
70:                      ANSELC=0;
9D012D1E  41A2BF80   LUI V0, 0xBF80
9D012D20  BF80F802   LDC1 F28, -2046(ZERO)
9D012D22  F8022DB0   SW ZERO, 11696(V0)
9D012D24      2DB0   ANDI V1, V1, 0x80
71:                      
72:                      //B2,3, C0,1
73:                      
74:                      TRISCbits.TRISC3=0;     //LED1   pin 14
9D012D26  41A3BF80   LUI V1, 0xBF80
9D012D28  BF803443   LDC1 F28, 13379(ZERO)
9D012D2A  34432DC0   LHU V0, 11712(V1)
9D012D2C      2DC0   ANDI V1, A0, 0x80
9D012D2E  004018CC   INS V0, ZERO, 3, 1
9D012D30  18CC3843   SB A2, 14403(T4)
9D012D32  38432DC0   SH V0, 11712(V1)
9D012D34      2DC0   ANDI V1, A0, 0x80
75:                      TRISBbits.TRISB5=0;     //LED2   pin 15
9D012D36  41A3BF80   LUI V1, 0xBF80
9D012D38  BF803443   LDC1 F28, 13379(ZERO)
9D012D3A  34432CC0   LHU V0, 11456(V1)
9D012D3C      2CC0   ANDI S1, A0, 0x80
9D012D3E  0040294C   INS V0, ZERO, 5, 1
9D012D40      294C   LHU V0, 24(A0)
9D012D42  38432CC0   SH V0, 11456(V1)
9D012D44      2CC0   ANDI S1, A0, 0x80
76:                      TRISBbits.TRISB7=0;     //LED3   pin 17 SPI2 CLK
9D012D46  41A3BF80   LUI V1, 0xBF80
9D012D48  BF803443   LDC1 F28, 13379(ZERO)
9D012D4A  34432CC0   LHU V0, 11456(V1)
9D012D4C      2CC0   ANDI S1, A0, 0x80
9D012D4E  004039CC   INS V0, ZERO, 7, 1
9D012D50  39CC3843   SH T6, 14403(T4)
9D012D52  38432CC0   SH V0, 11456(V1)
9D012D54      2CC0   ANDI S1, A0, 0x80
77:                      TRISBbits.TRISB8=0;     //       pin 18 SPI2 DATA
9D012D56  41A3BF80   LUI V1, 0xBF80
9D012D58  BF803443   LDC1 F28, 13379(ZERO)
9D012D5A  34432CC0   LHU V0, 11456(V1)
9D012D5C      2CC0   ANDI S1, A0, 0x80
9D012D5E  0040420C   INS V0, ZERO, 8, 1
9D012D60  420C3843   SYNCI 14403(T4)
9D012D62  38432CC0   SH V0, 11456(V1)
9D012D64      2CC0   ANDI S1, A0, 0x80
78:                      
79:                      TRISBbits.TRISB9=0;     //       pin 19 SPI2 RESET
9D012D66  41A3BF80   LUI V1, 0xBF80
9D012D68  BF803443   LDC1 F28, 13379(ZERO)
9D012D6A  34432CC0   LHU V0, 11456(V1)
9D012D6C      2CC0   ANDI S1, A0, 0x80
9D012D6E  00404A4C   INS V0, ZERO, 9, 1
9D012D70      4A4C   LW S2, 48(SP)
9D012D72  38432CC0   SH V0, 11456(V1)
9D012D74      2CC0   ANDI S1, A0, 0x80
80:                      TRISCbits.TRISC9=0;     //       pin 21 SPI2 DC
9D012D76  41A3BF80   LUI V1, 0xBF80
9D012D78  BF803443   LDC1 F28, 13379(ZERO)
9D012D7A  34432DC0   LHU V0, 11712(V1)
9D012D7C      2DC0   ANDI V1, A0, 0x80
9D012D7E  00404A4C   INS V0, ZERO, 9, 1
9D012D80      4A4C   LW S2, 48(SP)
9D012D82  38432DC0   SH V0, 11712(V1)
9D012D84      2DC0   ANDI V1, A0, 0x80
81:                      
82:                      TRISBbits.TRISB2=0;     //RP8-pin1 (CLK SPI2),       (DATA I2C2)
9D012D86  41A3BF80   LUI V1, 0xBF80
9D012D88  BF803443   LDC1 F28, 13379(ZERO)
9D012D8A  34432CC0   LHU V0, 11456(V1)
9D012D8C      2CC0   ANDI S1, A0, 0x80
9D012D8E  0040108C   INS V0, ZERO, 2, 1
9D012D90  108C3843   ADDI A0, T4, 14403
9D012D92  38432CC0   SH V0, 11456(V1)
9D012D94      2CC0   ANDI S1, A0, 0x80
83:                      TRISBbits.TRISB3=0;     //RP9-pin2 (DATA OUT SPI2),  (CLK  I2C2)
9D012D96  41A3BF80   LUI V1, 0xBF80
9D012D98  BF803443   LDC1 F28, 13379(ZERO)
9D012D9A  34432CC0   LHU V0, 11456(V1)
9D012D9C      2CC0   ANDI S1, A0, 0x80
9D012D9E  004018CC   INS V0, ZERO, 3, 1
9D012DA0  18CC3843   SB A2, 14403(T4)
9D012DA2  38432CC0   SH V0, 11456(V1)
9D012DA4      2CC0   ANDI S1, A0, 0x80
84:                      
85:                      //pozor, je pripojeno na GND
86:                      //TRISAbits.TRISA2=0;
87:                      //LATAbits.LATA2=1;
88:                      
89:                  
90:                      
91:                      //Vadny spoj
92:                      TRISAbits.TRISA9=0;
9D012DA6  41A3BF80   LUI V1, 0xBF80
9D012DA8  BF803443   LDC1 F28, 13379(ZERO)
9D012DAA  34432BC0   LHU V0, 11200(V1)
9D012DAC      2BC0   LHU A3, 0(A0)
9D012DAE  00404A4C   INS V0, ZERO, 9, 1
9D012DB0      4A4C   LW S2, 48(SP)
9D012DB2  38432BC0   SH V0, 11200(V1)
9D012DB4      2BC0   LHU A3, 0(A0)
93:                      LATAbits.LATA9=1;
9D012DB6  41A3BF80   LUI V1, 0xBF80
9D012DB8  BF803443   LDC1 F28, 13379(ZERO)
9D012DBA  34432BE0   LHU V0, 11232(V1)
9D012DBC      2BE0   LHU A3, 0(A2)
9D012DBE      EE01   LI A0, 1
9D012DC0  00444A4C   INS V0, A0, 9, 1
9D012DC2      4A4C   LW S2, 48(SP)
9D012DC4  38432BE0   SH V0, 11232(V1)
9D012DC6      2BE0   LHU A3, 0(A2)
94:                  
95:                      //RB4, RP10, pouzito pro pwm displeje
96:                      //TRISBbits.TRISB4=0;
97:                      //LATBbits.LATB4=0;
98:                      //RPOR2bits.RP10R=11;
99:                  
100:                     // <editor-fold defaultstate="collapsed" desc="test">
101:                     //test
102:                 
103:                     /*
104:                     LATBbits.LATB7 = 1;
105:                     */
106:                 
107:                 
108:                     
109:                     // </editor-fold>
110:                 
111:                     //A.2 je pripojeno na GND (ili9341) - nemenit
112:                     
113:                     // <editor-fold defaultstate="collapsed" desc="SPI2, MM 36pin, RP8, RP9, C0, C1, C2 ">
114:                     
115:                     //pin
116:                     //1  RP12 - SPI2CLK
117:                     //2  RP13 - SPI2DATA out
118:                     //3  C0 - DC     display
119:                     //4  C1 - RESET  display
120:                     //5  C2 - CS     display
121:                     //7  A2-pripojeno na GND
122:                     //8  A3 - CS     touchpad
123:                     //9  RP10 - SPI2DATA in
124:                     //10 A4 - penirq touchpad
125:                     
126:                     //DISPLAY: RESET, DC, CS
127:                     TRISCbits.TRISC0=0;         //pin 3 DC (ili9341), C0
9D012DC8  41A3BF80   LUI V1, 0xBF80
9D012DCA  BF803443   LDC1 F28, 13379(ZERO)
9D012DCC  34432DC0   LHU V0, 11712(V1)
9D012DCE      2DC0   ANDI V1, A0, 0x80
9D012DD0  0040000C   INS V0, ZERO, 0, 1
9D012DD4  38432DC0   SH V0, 11712(V1)
9D012DD6      2DC0   ANDI V1, A0, 0x80
128:                     TRISCbits.TRISC1=0;         //pin 4 RESET (ili9341), C1
9D012DD8  41A3BF80   LUI V1, 0xBF80
9D012DDA  BF803443   LDC1 F28, 13379(ZERO)
9D012DDC  34432DC0   LHU V0, 11712(V1)
9D012DDE      2DC0   ANDI V1, A0, 0x80
9D012DE0  0040084C   INS V0, ZERO, 1, 1
9D012DE2      084C   LBU S0, 12(A0)
9D012DE4  38432DC0   SH V0, 11712(V1)
9D012DE6      2DC0   ANDI V1, A0, 0x80
129:                     TRISCbits.TRISC2=0;         //pin 5 CS (ili9341), C2
9D012DE8  41A3BF80   LUI V1, 0xBF80
9D012DEA  BF803443   LDC1 F28, 13379(ZERO)
9D012DEC  34432DC0   LHU V0, 11712(V1)
9D012DEE      2DC0   ANDI V1, A0, 0x80
9D012DF0  0040108C   INS V0, ZERO, 2, 1
9D012DF2  108C3843   ADDI A0, T4, 14403
9D012DF4  38432DC0   SH V0, 11712(V1)
9D012DF6      2DC0   ANDI V1, A0, 0x80
130:                     
131:                     //TOUCH: CS signal TouchPad
132:                     TRISAbits.TRISA3=0;         //pin 8 CS (XPT2046), RA3
9D012DF8  41A3BF80   LUI V1, 0xBF80
9D012DFA  BF803443   LDC1 F28, 13379(ZERO)
9D012DFC  34432BC0   LHU V0, 11200(V1)
9D012DFE      2BC0   LHU A3, 0(A0)
9D012E00  004018CC   INS V0, ZERO, 3, 1
9D012E02  18CC3843   SB A2, 14403(T4)
9D012E04  38432BC0   SH V0, 11200(V1)
9D012E06      2BC0   LHU A3, 0(A0)
133:                     //LATAbits.LATA3=1;
134:                     
135:                     //CLK, SDO
136:                     RPOR1bits.RP8R=9;           //pin 1 SPI2CLK  RP12,
9D012E08  41A3BF80   LUI V1, 0xBF80
9D012E0A  BF80FC43   LDC1 F28, -957(ZERO)
9D012E0C  FC432B20   LW V0, 11040(V1)
9D012E0E      2B20   LHU A2, 0(V0)
9D012E10      EE09   LI A0, 9
9D012E12  0044E60C   INS V0, A0, 24, 5
9D012E16  F8432B20   SW V0, 11040(V1)
9D012E18      2B20   LHU A2, 0(V0)
137:                     RPOR2bits.RP9R=8;           //pin 2 SPI2DO   RP13,
9D012E1A  41A3BF80   LUI V1, 0xBF80
9D012E1C  BF80FC43   LDC1 F28, -957(ZERO)
9D012E1E  FC432B30   LW V0, 11056(V1)
9D012E20      2B30   LHU A2, 0(V1)
9D012E22      EE08   LI A0, 8
9D012E24  0044200C   INS V0, A0, 0, 5
9D012E28  F8432B30   SW V0, 11056(V1)
9D012E2A      2B30   LHU A2, 0(V1)
138:                     
139:                     //SDI
140:                     TRISBbits.TRISB4=1;
9D012E2C  41A3BF80   LUI V1, 0xBF80
9D012E2E  BF803443   LDC1 F28, 13379(ZERO)
9D012E30  34432CC0   LHU V0, 11456(V1)
9D012E32      2CC0   ANDI S1, A0, 0x80
9D012E34      EE01   LI A0, 1
9D012E36  0044210C   INS V0, A0, 4, 1
9D012E38  210C3843   ASET 0, -1981(T4)
9D012E3A  38432CC0   SH V0, 11456(V1)
9D012E3C      2CC0   ANDI S1, A0, 0x80
141:                     LATBbits.LATB4=1;
9D012E3E  41A3BF80   LUI V1, 0xBF80
9D012E40  BF803443   LDC1 F28, 13379(ZERO)
9D012E42  34432CE0   LHU V0, 11488(V1)
9D012E44      2CE0   ANDI S1, A2, 0x80
9D012E46      EE01   LI A0, 1
9D012E48  0044210C   INS V0, A0, 4, 1
9D012E4A  210C3843   ASET 0, -1981(T4)
9D012E4C  38432CE0   SH V0, 11488(V1)
9D012E4E      2CE0   ANDI S1, A2, 0x80
142:                     RPINR11bits.SDI2R=0b01010;  //pin 9 SPI2DI  RP10, (RB4)
9D012E50  41A3BF80   LUI V1, 0xBF80
9D012E52  BF80FC43   LDC1 F28, -957(ZERO)
9D012E54  FC432AC0   LW V0, 10944(V1)
9D012E56      2AC0   LHU A1, 0(A0)
9D012E58      EE0A   LI A0, 10
9D012E5A  0044200C   INS V0, A0, 0, 5
9D012E5E  F8432AC0   SW V0, 10944(V1)
9D012E60      2AC0   LHU A1, 0(A0)
143:                     
144:                     //RA4, TouchPad penirq
145:                     TRISAbits.TRISA4=1;
9D012E62  41A3BF80   LUI V1, 0xBF80
9D012E64  BF803443   LDC1 F28, 13379(ZERO)
9D012E66  34432BC0   LHU V0, 11200(V1)
9D012E68      2BC0   LHU A3, 0(A0)
9D012E6A      EE01   LI A0, 1
9D012E6C  0044210C   INS V0, A0, 4, 1
9D012E6E  210C3843   ASET 0, -1981(T4)
9D012E70  38432BC0   SH V0, 11200(V1)
9D012E72      2BC0   LHU A3, 0(A0)
146:                     LATAbits.LATA4=1;
9D012E74  41A3BF80   LUI V1, 0xBF80
9D012E76  BF803443   LDC1 F28, 13379(ZERO)
9D012E78  34432BE0   LHU V0, 11232(V1)
9D012E7A      2BE0   LHU A3, 0(A2)
9D012E7C      EE01   LI A0, 1
9D012E7E  0044210C   INS V0, A0, 4, 1
9D012E80  210C3843   ASET 0, -1981(T4)
9D012E82  38432BE0   SH V0, 11232(V1)
9D012E84      2BE0   LHU A3, 0(A2)
147:                     
148:                     // </editor-fold>
149:                 
150:                     // <editor-fold defaultstate="collapsed" desc="I2C2, MM 36pin">
151:                     //pin
152:                     //1  SDA        display (pin se nastavi automaticky, pri zapnuti I2C2 modulu)
153:                     //2  CLK        display (pin se nastavi automaticky, pri zapnuti I2C2 modulu)
154:                     //4  C1 - RESET display
155:                     
156:                     TRISCbits.TRISC1=0;         //pin 4 RESET (ili9341), C1
9D012E86  41A3BF80   LUI V1, 0xBF80
9D012E88  BF803443   LDC1 F28, 13379(ZERO)
9D012E8A  34432DC0   LHU V0, 11712(V1)
9D012E8C      2DC0   ANDI V1, A0, 0x80
9D012E8E  0040084C   INS V0, ZERO, 1, 1
9D012E90      084C   LBU S0, 12(A0)
9D012E92  38432DC0   SH V0, 11712(V1)
9D012E94      2DC0   ANDI V1, A0, 0x80
157:                     
158:                     // </editor-fold>
159:                 
160:                     
161:                     //setPortDigOut(PORTC_BASE, BIT0);        //nefunguje???
162:                     
163:                 #endif    
164:                     
165:                 }
9D012E96      0FBE   MOVE SP, S8
9D012E98      4BC1   LW S8, 4(SP)
9D012E9A      4C05   ADDIU SP, SP, 8
9D012E9C      45BF   JRC RA
9D012E9E      0C00   NOP
166:                 
167:                 void initInterrupt()
168:                 {
9D012EA0      4FF5   ADDIU SP, SP, -24
9D012EA2      CBE5   SW RA, 20(SP)
9D012EA4      CBC4   SW S8, 16(SP)
9D012EA6      0FDD   MOVE S8, SP
169:                 #ifdef PIC32MZ
170:                 
171:                 #endif
172:                 
173:                 #ifdef PIC32MM
174:                     
175:                     //nepouziva c/c++ interrupt vector
176:                     //fn.S obsahuje tabulku se skoky do interrupt fci, po skonceni provede ERET 
177:                     //tabulka vektoru je nezavisla na EBASE (na rozdil od dokumentace), vzdy zacina na x09D00 0200
178:                     //v tabulce je pouze skok do fn.S funkce (vlozi compilator prikazem napr.: extern void __attribute__((vector(21))) iVector21();)
179:                     //vector spacing je 8 bytes, multivector
180:                     //vsechny ILP pouzivaji SRS[1]
181:                     //setSrsValue() zajisti, ze SRS[1] gp a sp budou nastaveny na pouziti v c/c++ kodu
182:                     //SRS[1] ma vlastni zasobnik (512 Bytes), gp je nastaveno jako v SRS[0]
183:                     
184:                     
185:                     //nastavi vychozi hodnoty GP a SP pro SRS[1]
186:                     //var gp_value obsahuje hodnotu pro GP
187:                     //vat sp_srs1_top obsahuje hodnotu pro SP
188:                     setSrsValue();
9D012EA8  76808328   JALS setSrsValue
9D012EAC      0C00   NOP
189:                     
190:                     //Multivector, spacing 8 bytes, IPL 1-7 pouziva SRS[1]
191:                     //Neobsahuje EI, STATUS.EI zustava 0 (interrupt disable)
192:                     setInterrupt();
9D012EAE  76808356   JALS setInterrupt
9D012EB2      0C00   NOP
193:                      
194:                 #endif        
195:                         
196:                 }
9D012EB4      0FBE   MOVE SP, S8
---  d:/bos/bos/main.c  ---------------------------------------------------------------------------------
1:                   //#include <xc.h>
2:                   #include <sys/appio.h>
3:                   #include <stdio.h>
4:                   #include <stdlib.h>
5:                   #include <p32xxxx.h>
6:                   
7:                   #include <xc.h>
8:                   #include <stdio.h>
9:                   #include <stdlib.h>
10:                  
11:                  #include "globals.h"
12:                  #include "main.h"
13:                  #include "asm.h"
14:                  
15:                  //#include "fnc.h"
16:                  //#include "graphics.h"                 //display modul
17:                  //#include "disp1306a.h"
18:                  //#include "spi.h"
19:                  //#include "i2c.h"
20:                  //#include "timer.h"
21:                  //#include "pwm.h"
22:                  //#include "usb_device_mm.h"
23:                  //#include "test_driver_a.h"
24:                  //#include "disp9341.h"
25:                  
26:                  
27:                  // <editor-fold defaultstate="collapsed" desc="extern, add user app start function here">
28:                  //define extern functions
29:                  //user app start function add here, 
30:                  //and update main fn bellow, step 6. run apps
31:                  
32:                  //user apps
33:                  //app1
34:                  extern void m1_start();
35:                  //app2
36:                  extern void m2_start();
37:                  //app3
38:                  extern void m3_start();
39:                  
40:                  //system
41:                  //touch module
42:                  #ifdef TOUCHPAD_XPT2046_INIT 
43:                      extern void touchXpt2046_start(); 
44:                  #endif
45:                  
46:                  // </editor-fold>
47:                  
48:                  // <editor-fold defaultstate="collapsed" desc="OS vars">
49:                      
50:                  /*
51:                   * OBSAZENI RAM od nejvyssi adresy
52:                   * a).os
53:                   * b).os_stack
54:                   * c)zbytek RAM 0x8000 0000 ... &stack_area-4
55:                   * 
56:                   * sekce .os je ma nejvyssich adresach v RAM
57:                   * obsahuje 
58:                   * 3.ballast
59:                   * 2.ostatni os vars        //nad proc_t
60:                   * 1.proc_t                 //zacatek oblasti
61:                   * 
62:                   * sekce .os_stack 
63:                   * volna oblast
64:                   * stack applikaci
65:                   * stack os modulu (protoze os moduly se spusti prvni)                  //nas interrupt stack
66:                   * interrupt stack (jeden, nebo sedm, velikost kazdeho SRS_STACK_SIZE)  //zacatek oblasti
67:                   */
68:                                              //proccee_table                 other vars + ballast
69:                  #define     OS_DATA_SIZE    ((PROC_T_ISIZE * PROC_T_CAPA) + 64)     //velikost .os
70:                  #define     OS_DATA_BASE    ((RAM_BASE + RAM_SIZE) - OS_DATA_SIZE)                      //adresa .os
71:                  
72:                  //process table    
73:                  uint proc_t[(PROC_T_ISIZE / 4) * PROC_T_CAPA] __section(".os") __at(OS_DATA_BASE);      
74:                  //stack_list pro pouziti pri allocStack, stack pro kazdy proces je alokovan ve volne RAM
75:                  //kazda polozka (32-bit) definuje velikost jednoho stacku
76:                  //int stack_list[PROC_T_CAPA] __section(".os");                  
77:                  
78:                  //.os vars 
79:                  uint* proc_t_pos    __section(".os") = 0;
80:                  uint* proc_t_max    __section(".os") = 0;
81:                  char proc_t_count   __section(".os") = 0;
82:                  
83:                  //ballast zajistuje, aby sekce .os byla plna, jinak kompilator vlozi za .os jeste sekci .data
84:                  //velikost ballast = 64 - vars.size (zarovnano na word)
85:                  char ballast[52]    __section(".os");
86:                  
87:                  
88:                  //.os_stack je oblast RAM tesne pod .os, stack ma definovanou velikost STACK_SIZE
89:                  #define     STACK_DATA_BASE (OS_DATA_BASE - STACK_SIZE)     
90:                  char stack_area[STACK_SIZE] __at(STACK_DATA_BASE) __section(".os_stack");
91:                  //char x[200000];
92:                  
93:                  // <editor-fold defaultstate="collapsed" desc="Stack Size Compiler warning">
94:                  #ifdef  PIC32MM
95:                  //PIC32MM jeden zasobnik pro vsechny interrupt level
96:                  #define     STACK_MINIMUM   ((PROC_T_CAPA * 1024) + (1 * SRS_STACK_SIZE))      
97:                  #endif
98:                  
99:                  #ifdef  PIC32MZ
100:                 //PIC32MZ kazdy interrupt level ma svuj zasobnik
101:                 #define     STACK_MINIMUM   ((PROC_T_CAPA * 1024) + (7 * SRS_STACK_SIZE))      
102:                 #endif
103:                 
104:                 #if (STACK_SIZE < STACK_MINIMUM)
105:                 #warning Definition of STACK_SIZE is too small! Please, check STACK_SIZE in def.h
106:                 #endif
107:                 // </editor-fold>
108:                 
109:                 // </editor-fold>
110:                 
111:                 
112:                 //global fn
113:                 void main() 
114:                 {
9D011AE8      4FF5   ADDIU SP, SP, -24
9D011AEA      CBE5   SW RA, 20(SP)
9D011AEC      CBC4   SW S8, 16(SP)
9D011AEE      0FDD   MOVE S8, SP
115:                     
116:                     //startup
117:                     //1. set basic (clock...) --------------------------------------------------
118:                     // <editor-fold defaultstate="collapsed" desc="clock">
119:                     setClock(); 
9D011AF0  76808EF6   JALS setClock
9D011AF2      8EF6   BEQZ A1, 0x9D011AE0
9D011AF4      0C00   NOP
120:                     // </editor-fold>
121:                 
122:                     //2. set safe mode ---------------------------------------------------------
123:                     // <editor-fold defaultstate="collapsed" desc="safe mode">
124:                 #ifdef SAFE_PROCESS    
125:                     cpuTimer_init();
126:                 #endif
127:                     // </editor-fold>
128:                 
129:                     //3. init system -----------------------------------------------------------
130:                     // <editor-fold defaultstate="collapsed" desc="system init">
131:                     system_init(); //init interrupt (ale zustane DI), nastav SRS1, ...
9D011AF6  76808E7C   JALS system_init
9D011AF8      8E7C   BEQZ A0, 0x9D011AF2
9D011AFA      0C00   NOP
132:                     timer1_init(); //timer1 1/100s, je-li definovano RTC, nastavi RTC modul na datum 1/1/2000
9D011AFC  76800000   JALS timer1_init
9D011AFE  00000C00   SSNOP
9D011B00      0C00   NOP
133:                     periph_init(); //provede vychozi nastaveni periferii, prideluje IO piny
9D011B02  76809672   JALS periph_init
9D011B04  96720C00   BEQ S2, S3, 0x9D013308
9D011B06      0C00   NOP
134:                 
135:                     clearProcTable(); 
9D011B08  76807F02   JALS clearProcTable
9D011B0C      0C00   NOP
136:                     // </editor-fold>
137:                     
138:                     //4. init system drivers ---------------------------------------------------
139:                     // <editor-fold defaultstate="collapsed" desc="drivers">
140:                 
141:                 #if (defined SPI1_INIT || defined SPI2_INIT || defined SPI3_INIT)    
142:                     spi_init();
9D011B0E  7680704C   JALS spi_init
9D011B10  704C0C00   XORI V0, T4, 3072
9D011B12      0C00   NOP
143:                 #endif
144:                 
145:                 #if (defined I2C1_INIT || defined I2C2_INIT || defined I2C3_INIT)    
146:                     i2c_init();
9D011B14  76808910   JALS i2c_init
9D011B16      8910   SB V0, 0(S1)
9D011B18      0C00   NOP
147:                 #endif    
148:                 
149:                 #ifdef ADC_SCAN_INIT    
150:                     adcScan_init();
9D011B1A  768093E4   JALS adcScan_init
9D011B1C  93E40C00   SLTI RA, A0, 3072
9D011B1E      0C00   NOP
151:                 #endif
152:                 
153:                 #ifdef PWM_INIT    
154:                     pwm_init();
9D011B20  76809836   JALS pwm_init
9D011B22  98360C00   SWC1 F1, 3072(S6)
9D011B24      0C00   NOP
155:                 #endif  
156:                 
157:                 #ifdef USB_DEVICE_INIT
158:                     usbDevice_init();
9D011B26  76807A3A   JALS usbDevice_init
9D011B28  7A3A0C00   ADDIUPC A0, 15216640
9D011B2A      0C00   NOP
159:                 #endif    
160:                 
161:                     //testDriver_init();
162:                     enableInterrupt(); //provede EI
9D011B2C  7680836C   JALS enableInterrupt
9D011B30      0C00   NOP
163:                     globalsBeforeProcess(); //inicializuje displej, touchpad, ...
9D011B32  768099D4   JALS globalsBeforeProcess
9D011B34  99D40C00   SWC1 F14, 3072(S4)
9D011B36      0C00   NOP
164:                     
165:                     // </editor-fold>
166:                 
167:                     //5. run system modules ----------------------------------------------------
168:                     // <editor-fold defaultstate="collapsed" desc="run module, apps">
169:                 #ifdef TOUCHPAD_XPT2046_INIT    
170:                     //modul touchpad XPT2046
171:                     reg_process((int*) touchXpt2046_start, 1024);
9D011B38  41A29D01   LUI V0, 0x9D01
9D011B3A  9D013082   LWC1 F8, 12418(AT)
9D011B3C  3082D5F1   ADDIU A0, V0, -10767
9D011B3E  D5F130A0   J 0x9BE26140
9D011B40  30A00400   ADDIU A1, ZERO, 1024
9D011B42      0400   ADDU S0, S0, S0
9D011B44  76808DD0   JALS reg_process
9D011B46      8DD0   BEQZ V1, main
9D011B48      0C00   NOP
172:                 #endif    
173:                 
174:                 
175:                     //6. run user apps --------------------------------------------------------------
176:                     //To run user app, modify this section. Use reg_process(int* app_start_fn_address, int stack_size)
177:                     //The start fn of app, must be declared in extern section above
178:                     //Check the maximum number of threads, please
179:                 
180:                     reg_process((int*) &m1_start, 1024);
9D011B4A  41A29D01   LUI V0, 0x9D01
9D011B4C  9D013082   LWC1 F8, 12418(AT)
9D011B4E  30822A5D   ADDIU A0, V0, 10845
9D011B50      2A5D   LHU A0, 26(A1)
9D011B52  30A00400   ADDIU A1, ZERO, 1024
9D011B54      0400   ADDU S0, S0, S0
9D011B56  76808DD0   JALS reg_process
9D011B58      8DD0   BEQZ V1, 0x9D011AFA
9D011B5A      0C00   NOP
181:                     reg_process((int*) &m2_start, 1024);
9D011B5C  41A29D01   LUI V0, 0x9D01
9D011B5E  9D013082   LWC1 F8, 12418(AT)
9D011B60  30820CE9   ADDIU A0, V0, 3305
9D011B62      0CE9   MOVE A3, T1
9D011B64  30A00400   ADDIU A1, ZERO, 1024
9D011B66      0400   ADDU S0, S0, S0
9D011B68  76808DD0   JALS reg_process
9D011B6A      8DD0   BEQZ V1, 0x9D011B0C
9D011B6C      0C00   NOP
182:                     reg_process((int*) &m3_start, 1024);
9D011B6E  41A29D01   LUI V0, 0x9D01
9D011B70  9D013082   LWC1 F8, 12418(AT)
9D011B72  30823569   ADDIU A0, V0, 13673
9D011B74  356930A0   LHU T3, 12448(T1)
9D011B76  30A00400   ADDIU A1, ZERO, 1024
9D011B78      0400   ADDU S0, S0, S0
9D011B7A  76808DD0   JALS reg_process
9D011B7C      8DD0   BEQZ V1, 0x9D011B1E
9D011B7E      0C00   NOP
183:                 
184:                     //reg_process((int*)&disp9341a_start, 1024);
185:                     //reg_process((int*)&disp1306a_start, 1024);
186:                     //reg_process((int*)&ubtn_start, 512);          //dve tlacitka A2, A3
187:                     //reg_process((int*)&m2, 1024);
188:                     //reg_process((int*)&m3, 1024);
189:                     
190:                     // </editor-fold>
191:                 
192:                     //6. start multitasking ----------------------------------------------------
193:                     // <editor-fold defaultstate="collapsed" desc="start os">
194:                     DBINIT();
195:                     DBPRINTF("Test");
196:                     globalsAfterProcess();
9D011B80  768099E4   JALS globalsAfterProcess
9D011B82  99E40C00   SWC1 F15, 3072(A0)
9D011B84      0C00   NOP
197:                     SYSTEM_STATUS.Threading = 1;
9D011B86  345C8094   LHU V0, -32620(GP)
9D011B8A      ED81   LI V1, 1
9D011B8C  0043000C   INS V0, V1, 0, 1
9D011B90  385C8094   SH V0, -32620(GP)
198:                     startEvents(); 
9D011B94  76807FCE   JALS startEvents
9D011B98      0C00   NOP
199:                     // </editor-fold>
200:                 
201:                     
202:                     
203:                     while(1)
204:                     {
205:                         
206:                     }
9D011B9A      CFFF   B 0x9D011B9A
9D011B9C      0C00   NOP
9D011B9E      0C00   NOP
207:                 }
208:                 
209:                 //local fn
210:                 static char reg_process(int* start_addr, int stack_size)
211:                 {
9D011BA0      4FE9   ADDIU SP, SP, -48
9D011BA2      CBEB   SW RA, 44(SP)
9D011BA4      CBCA   SW S8, 40(SP)
9D011BA6      CA09   SW S0, 36(SP)
9D011BA8      0FDD   MOVE S8, SP
9D011BAA  F89E0030   SW A0, 48(S8)
9D011BAE  F8BE0034   SW A1, 52(S8)
212:                     //prvede registraci procesu v proc_t
213:                     //vlozi do proc_t adresu start fce a vychozi hodnotu pro stack(top adresa)
214:                     //vraci ID procesu, nebo -1 pri chybe
215:                     
216:                     //test, zda je volne misto v proc_t
217:                     if(proc_t_count >= PROC_T_CAPA) { return -1; } 
9D011BB2  41A28000   LUI V0, 0x8000
9D011BB6  14427FC8   LBU V0, 32712(V0)
9D011BBA  B0420008   SLTIU V0, V0, 8
9D011BBE  40A20004   BNEZC V0, 0x9D011BCA
9D011BC0  00043040   SRL ZERO, A0, 6
9D011BC2  304000FF   ADDIU V0, ZERO, 255
9D011BC4  00FFCC57   BREAK
9D011BC6      CC57   B 0x9D011C76
9D011BC8      0C00   NOP
218:                     
219:                     char id=getFreeProcessID();
9D011BCA  76808E42   JALS getFreeProcessID
9D011BCC      8E42   BEQZ A0, 0x9D011B52
9D011BCE      0C00   NOP
9D011BD0  185E0010   SB V0, 16(S8)
220:                     int* tab=proc_t + ((proc_t_count) * (PROC_T_ISIZE/4));      //adresa polozky proc_t
9D011BD4  41A28000   LUI V0, 0x8000
9D011BD8  14427FC8   LBU V0, 32712(V0)
9D011BDC      0C82   MOVE A0, V0
9D011BDE      0C64   MOVE V1, A0
9D011BE0      2534   SLL V0, V1, 2
9D011BE2      0C62   MOVE V1, V0
9D011BE4      2534   SLL V0, V1, 2
9D011BE6      0535   SUBU V0, V0, V1
9D011BE8      0545   SUBU V0, V0, A0
9D011BEA      2526   SLL V0, V0, 3
9D011BEC      0C62   MOVE V1, V0
9D011BEE  41A28000   LUI V0, 0x8000
9D011BF2  30427D00   ADDIU V0, V0, 32000
9D011BF6      0526   ADDU V0, V1, V0
9D011BF8  F85E0014   SW V0, 20(S8)
221:                     proc_t_count++;
9D011BFC  41A28000   LUI V0, 0x8000
9D011C00  14427FC8   LBU V0, 32712(V0)
9D011C04      6D20   ADDIU V0, V0, 1
9D011C06      2DAD   ANDI V1, V0, 0xFF
9D011C08  41A28000   LUI V0, 0x8000
9D011C0C  18627FC8   SB V1, 32712(V0)
222:                     
223:                     int ret=allocStack(stack_size, tab);                       //nastavuje SP, START_SP a BASE_SP
9D011C10  FC9E0034   LW A0, 52(S8)
9D011C14  FCBE0014   LW A1, 20(S8)
9D011C16  00147680   OR T6, S4, ZERO
9D011C18  76807F16   JALS allocStack
9D011C1C      0C00   NOP
9D011C1E  F85E0018   SW V0, 24(S8)
224:                     if(ret==0)
9D011C22  FC5E0018   LW V0, 24(S8)
9D011C26  40A20024   BNEZC V0, 0x9D011C72
225:                     {
226:                         //ok, stack allocated
227:                         tab[TH_T_ID]=id;
9D011C2A  147E0010   LBU V1, 16(S8)
9D011C2E  FC5E0014   LW V0, 20(S8)
9D011C30  0014E9A0   SUB SP, S4, ZERO
9D011C32      E9A0   SW V1, 0(V0)
228:                         tab[TH_T_RA]=(int)start_addr;
9D011C34  FC5E0014   LW V0, 20(S8)
9D011C38  30420054   ADDIU V0, V0, 84
9D011C3C  FC7E0030   LW V1, 48(S8)
9D011C3E  0030E9A0   SUB SP, S0, AT
9D011C40      E9A0   SW V1, 0(V0)
229:                         tab[TH_T_GP]=getGP();
9D011C42  FC5E0014   LW V0, 20(S8)
9D011C46  32020048   ADDIU S0, V0, 72
9D011C48  00487680   OR T6, T0, V0
9D011C4A  76808022   JALS getGP
9D011C4E      0C00   NOP
9D011C50      E900   SW V0, 0(S0)
230:                     
231:                         tab[TH_T_START_ADDR]=(int)start_addr;                   //START_ADDR pro pripad restartu app
9D011C52  FC5E0014   LW V0, 20(S8)
9D011C56      6D22   ADDIU V0, V0, 4
9D011C58  FC7E0030   LW V1, 48(S8)
9D011C5A  0030E9A0   SUB SP, S0, AT
9D011C5C      E9A0   SW V1, 0(V0)
232:                     
233:                         proc_t_max=tab;
9D011C5E  41A28000   LUI V0, 0x8000
9D011C62  FC7E0014   LW V1, 20(S8)
9D011C66  F8627FC4   SW V1, 32708(V0)
234:                     
235:                         return id;
9D011C6A  145E0010   LBU V0, 16(S8)
9D011C6E      CC03   B 0x9D011C76
9D011C70      0C00   NOP
236:                     }
237:                     else
238:                     {
239:                         //reg_process error!
240:                         while(1)
241:                         {
242:                             //os is stopped
243:                         }
9D011C72      CFFF   B 0x9D011C72
9D011C74      0C00   NOP
244:                     }
245:                 }
9D011C76      0FBE   MOVE SP, S8
9D011C78      4BEB   LW RA, 44(SP)
9D011C7A      4BCA   LW S8, 40(SP)
9D011C7C      4A09   LW S0, 36(SP)
9D011C7E      4C19   ADDIU SP, SP, 48
9D011C80      45BF   JRC RA
9D011C82      0C00   NOP
246:                 
247:                 static char getFreeProcessID()
248:                 {
9D011C84      4FF9   ADDIU SP, SP, -16
9D011C86      CBC3   SW S8, 12(SP)
9D011C88      0FDD   MOVE S8, SP
249:                     //v proc_t musi byt alespon jedno volne misto
250:                     //prvni nulova hodnota ID znamena konec platnych polozek (volne polozky pouze na konci tabulky)
251:                     char* proc_t_bytes=(char*)proc_t;
9D011C8A  41A28000   LUI V0, 0x8000
9D011C8E  30427D00   ADDIU V0, V0, 32000
9D011C92  F85E0000   SW V0, 0(S8)
252:                     
253:                     char id=1;
9D011C96      ED01   LI V0, 1
9D011C98  185E0004   SB V0, 4(S8)
254:                     while(1)
255:                     {
256:                         char exist_id=proc_t_bytes[0];
9D011C9C  FC5E0000   LW V0, 0(S8)
9D011C9E  00000920   ADD AT, ZERO, ZERO
9D011CA0      0920   LBU V0, 0(V0)
9D011CA2  185E0005   SB V0, 5(S8)
257:                         if(id==exist_id)
9D011CA6  147E0004   LBU V1, 4(S8)
9D011CAA  145E0005   LBU V0, 5(S8)
9D011CAE  B443000E   BNE V1, V0, 0x9D011CCE
9D011CB0  000E0C00   SLL ZERO, T6, 1
9D011CB2      0C00   NOP
258:                         {
259:                             //nasel stejne ID, cele znova
260:                             id++;                                   //nove id
9D011CB4  145E0004   LBU V0, 4(S8)
9D011CB6  00046D20   ADD T5, A0, ZERO
9D011CB8      6D20   ADDIU V0, V0, 1
9D011CBA  185E0004   SB V0, 4(S8)
261:                             proc_t_bytes=(char*)proc_t;             //nastav zacatek proc_table
9D011CBE  41A28000   LUI V0, 0x8000
9D011CC2  30427D00   ADDIU V0, V0, 32000
9D011CC6  F85E0000   SW V0, 0(S8)
262:                         }
263:                         else if(exist_id==0)
9D011CCE  145E0005   LBU V0, 5(S8)
9D011CD2  40A20002   BNEZC V0, 0x9D011CDA
264:                         {
265:                             //nasel konec tabulky, pouzije ID
266:                             break;
9D011CD6      CC09   B 0x9D011CEA
9D011CD8      0C00   NOP
267:                         }
268:                         else
269:                         {
270:                             //jdi na dalsi polozku
271:                             proc_t_bytes += PROC_T_ISIZE;
9D011CDA  FC5E0000   LW V0, 0(S8)
9D011CDE  30420058   ADDIU V0, V0, 88
9D011CE2  F85E0000   SW V0, 0(S8)
272:                         }
273:                     }
9D011CCA      CFE8   B 0x9D011C9C
9D011CCC      0C00   NOP
9D011CE6      CFDA   B 0x9D011C9C
9D011CE8      0C00   NOP
274:                     
275:                     return id;
9D011CEA  145E0004   LBU V0, 4(S8)
276:                 }
9D011CEE      0FBE   MOVE SP, S8
9D011CF0      4BC3   LW S8, 12(SP)
9D011CF2      4C09   ADDIU SP, SP, 16
9D011CF4      45BF   JRC RA
9D011CF6      0C00   NOP
277:                 
278:                 static void system_init()
279:                 {
9D011CF8      4FF5   ADDIU SP, SP, -24
9D011CFA      CBE5   SW RA, 20(SP)
9D011CFC      CBC4   SW S8, 16(SP)
9D011CFE      0FDD   MOVE S8, SP
280:                     //nastavuje SRS[GP+SP], Multivector, ...
281:                     //zatim nepovoli interrupt (EI)
282:                 
283:                 #ifdef PIC32MM
284:                     
285:                     //char* sp_srs1 = stack_interrupt_srs1 + _SRS1_STACK_SIZE - 4;
286:                     
287:                     //nastavi vychozi hodnoty GP a SP pro SRS[1], SRS[1-7]
288:                     //nastav GP SRS[1-7] na stejnou hodnotu, jako SRS[0]
289:                     //nastav SP SRS[1-7] (zasobnik pro interrupt, dolni cast stack_area) 
290:                     setSrsValue2(); //sp_srs1);
9D011D00  76808338   JALS setSrsValue2
9D011D04      0C00   NOP
291:                 
292:                     //Multivector, spacing 8 bytes, IPL 1-7 pouziva SRS[1]
293:                     //Neobsahuje EI, STATUS.EI zustava 0 (interrupt disable)
294:                     setInterrupt();
9D011D06  76808356   JALS setInterrupt
9D011D0A      0C00   NOP
295:                     
296:                 #endif    
297:                     
298:                 #ifdef PIC32MZ
299:                 
300:                 #endif    
301:                     
302:                 }
9D011D0C      0FBE   MOVE SP, S8
9D011D0E      4BE5   LW RA, 20(SP)
9D011D10      4BC4   LW S8, 16(SP)
9D011D12      4C0D   ADDIU SP, SP, 24
9D011D14      45BF   JRC RA
9D011D16      0C00   NOP
303:                 
304:                 static void blick()
305:                 {
9D011D18      4FF9   ADDIU SP, SP, -16
9D011D1A      CBC3   SW S8, 12(SP)
9D011D1C      0FDD   MOVE S8, SP
306:                     //RB5, RB7, RC3
307:                     
308:                     LATA = 0xFFFF;
9D011D1E  41A2BF80   LUI V0, 0xBF80
9D011D20  BF805060   LDC1 F28, 20576(ZERO)
9D011D22  5060FFFF   ORI V1, ZERO, -1
9D011D24  FFFFF862   LW RA, -1950(RA)
9D011D26  F8622BE0   SW V1, 11232(V0)
9D011D28      2BE0   LHU A3, 0(A2)
309:                     LATB = 0xFFFF;
9D011D2A  41A2BF80   LUI V0, 0xBF80
9D011D2C  BF805060   LDC1 F28, 20576(ZERO)
9D011D2E  5060FFFF   ORI V1, ZERO, -1
9D011D30  FFFFF862   LW RA, -1950(RA)
9D011D32  F8622CE0   SW V1, 11488(V0)
9D011D34      2CE0   ANDI S1, A2, 0x80
310:                     LATC = 0xFFFF;
9D011D36  41A2BF80   LUI V0, 0xBF80
9D011D38  BF805060   LDC1 F28, 20576(ZERO)
9D011D3A  5060FFFF   ORI V1, ZERO, -1
9D011D3C  FFFFF862   LW RA, -1950(RA)
9D011D3E  F8622DE0   SW V1, 11744(V0)
9D011D40      2DE0   ANDI V1, A2, 0x80
311:                     
312:                     ANSELA=0;
9D011D42  41A2BF80   LUI V0, 0xBF80
9D011D44  BF80F802   LDC1 F28, -2046(ZERO)
9D011D46  F8022BB0   SW ZERO, 11184(V0)
9D011D48      2BB0   LHU A3, 0(V1)
313:                     ANSELB=0;
9D011D4A  41A2BF80   LUI V0, 0xBF80
9D011D4C  BF80F802   LDC1 F28, -2046(ZERO)
9D011D4E  F8022CB0   SW ZERO, 11440(V0)
9D011D50      2CB0   ANDI S1, V1, 0x80
314:                     ANSELC=0;
9D011D52  41A2BF80   LUI V0, 0xBF80
9D011D54  BF80F802   LDC1 F28, -2046(ZERO)
9D011D56  F8022DB0   SW ZERO, 11696(V0)
9D011D58      2DB0   ANDI V1, V1, 0x80
315:                 
316:                     TRISBbits.TRISB5=0;     //LED   pin 14
9D011D5A  41A3BF80   LUI V1, 0xBF80
9D011D5C  BF803443   LDC1 F28, 13379(ZERO)
9D011D5E  34432CC0   LHU V0, 11456(V1)
9D011D60      2CC0   ANDI S1, A0, 0x80
9D011D62  0040294C   INS V0, ZERO, 5, 1
9D011D64      294C   LHU V0, 24(A0)
9D011D66  38432CC0   SH V0, 11456(V1)
9D011D68      2CC0   ANDI S1, A0, 0x80
317:                     TRISBbits.TRISB7=0;
9D011D6A  41A3BF80   LUI V1, 0xBF80
9D011D6C  BF803443   LDC1 F28, 13379(ZERO)
9D011D6E  34432CC0   LHU V0, 11456(V1)
9D011D70      2CC0   ANDI S1, A0, 0x80
9D011D72  004039CC   INS V0, ZERO, 7, 1
9D011D74  39CC3843   SH T6, 14403(T4)
9D011D76  38432CC0   SH V0, 11456(V1)
9D011D78      2CC0   ANDI S1, A0, 0x80
318:                     TRISCbits.TRISC3=0;
9D011D7A  41A3BF80   LUI V1, 0xBF80
9D011D7C  BF803443   LDC1 F28, 13379(ZERO)
9D011D7E  34432DC0   LHU V0, 11712(V1)
9D011D80      2DC0   ANDI V1, A0, 0x80
9D011D82  004018CC   INS V0, ZERO, 3, 1
9D011D84  18CC3843   SB A2, 14403(T4)
9D011D86  38432DC0   SH V0, 11712(V1)
9D011D88      2DC0   ANDI V1, A0, 0x80
319:                     
320:                     LATBINV=0b10100000;
9D011D8A  41A2BF80   LUI V0, 0xBF80
9D011D8C  BF803060   LDC1 F28, 12384(ZERO)
9D011D8E  306000A0   ADDIU V1, ZERO, 160
9D011D92  F8622CEC   SW V1, 11500(V0)
9D011D94      2CEC   ANDI S1, A2, 0x40
321:                     LATCINV=0b1000;
9D011D96  41A2BF80   LUI V0, 0xBF80
9D011D98  BF80ED88   LDC1 F28, -4728(ZERO)
9D011D9A      ED88   LI V1, 8
9D011D9C  F8622DEC   SW V1, 11756(V0)
9D011D9E      2DEC   ANDI V1, A2, 0x40
322:                     
323:                     while(1)
324:                     {
325:                         int a, b;
326:                         for(a=0; a<1500000; a++)
9D011DA0  F81E0000   SW ZERO, 0(S8)
9D011DA4      CC0B   B 0x9D011DBC
9D011DA6      0C00   NOP
9D011DB2  FC5E0000   LW V0, 0(S8)
9D011DB4  00006D20   ADD T5, ZERO, ZERO
9D011DB6      6D20   ADDIU V0, V0, 1
9D011DB8  F85E0000   SW V0, 0(S8)
9D011DBC  FC7E0000   LW V1, 0(S8)
9D011DC0  41A20016   LUI V0, 0x16
9D011DC4  5042E360   ORI V0, V0, -7328
9D011DC8  00431350   SLT V0, V1, V0
9D011DCA  135040A2   ADDI K0, S0, 16546
9D011DCC  40A2FFEC   BNEZC V0, 0x9D011DA8
9D011DCE  FFEC41A2   LW RA, 16802(T4)
327:                         {
328:                             b=a+1;
9D011DA8  FC5E0000   LW V0, 0(S8)
9D011DAA  00006D20   ADD T5, ZERO, ZERO
9D011DAC      6D20   ADDIU V0, V0, 1
9D011DAE  F85E0004   SW V0, 4(S8)
329:                         }
330:                         
331:                         LATBINV=0b10100000;
9D011DD0  41A2BF80   LUI V0, 0xBF80
9D011DD2  BF803060   LDC1 F28, 12384(ZERO)
9D011DD4  306000A0   ADDIU V1, ZERO, 160
9D011DD8  F8622CEC   SW V1, 11500(V0)
9D011DDA      2CEC   ANDI S1, A2, 0x40
332:                         LATCINV=0b1000;
9D011DDC  41A2BF80   LUI V0, 0xBF80
9D011DDE  BF80ED88   LDC1 F28, -4728(ZERO)
9D011DE0      ED88   LI V1, 8
9D011DE2  F8622DEC   SW V1, 11756(V0)
9D011DE4      2DEC   ANDI V1, A2, 0x40
333:                     }
9D011DE6      CFDC   B 0x9D011DA0
9D011DE8      0C00   NOP
9D011DEA      0C00   NOP
334:                     
335:                 }
336:                 
337:                 static void setClock()
338:                 {
9D011DEC      4FB0   ADDIU SP, SP, -8
9D011DEE      CBC1   SW S8, 4(SP)
9D011DF0      0FDD   MOVE S8, SP
339:                     //PIC32MM0256, nsatveni pro pouziti FRC(interni) 8MHz, pres system PLL (PLLODIV=96MHz)
340:                     //1.Nastavi PLLMULT (f pro USB musi byt 96/2 MHz)
341:                     //2.Nastavi REFCLK (f pro SPI, UART, apod... 48MHz) 
342:                     //3.Nastavi SYSCLK a PBCLK (SYSCLK pro CPU, PBCLK pro preriph, 24MHz) (PLLODIV = /4)
343:                     
344:                     //SYSKEY unlock
345:                     SYSKEY = 0xAA996655; 
9D011DF2  41A2BF80   LUI V0, 0xBF80
9D011DF4  BF8041A3   LDC1 F28, 16803(ZERO)
9D011DF6  41A3AA99   LUI V1, 0xAA99
9D011DF8      AA99   SH A1, 18(S1)
9D011DFA  50636655   ORI V1, V1, 26197
9D011DFC      6655   LW A0, -172(GP)
9D011DFE  F8623670   SW V1, 13936(V0)
9D011E00  367041A2   LHU S3, 16802(S0)
346:                     SYSKEY = 0x556699AA;
9D011E02  41A2BF80   LUI V0, 0xBF80
9D011E04  BF8041A3   LDC1 F28, 16803(ZERO)
9D011E06  41A35566   LUI V1, 0x5566
9D011E0A  506399AA   ORI V1, V1, -26198
9D011E0C  99AAF862   SWC1 F13, -1950(T2)
9D011E0E  F8623670   SW V1, 13936(V0)
9D011E10  367041A3   LHU S3, 16803(S0)
347:                     
348:                     //nastaveni pro POSC Q=12MHz: SPLLCONbits.PLLMULT = 0x4 (externi krystal 12 MHz)
349:                     //natsaveni pro FRC     8MHz: SPLLCONbits.PLLMULT = 0x6 (podle doc. by melo byt 0x5)
350:                     
351:                     SPLLCONbits.PLLMULT=0x6;        // x 12 (8x12=96 MHz) USB
9D011E12  41A3BF80   LUI V1, 0xBF80
9D011E14  BF80FC43   LDC1 F28, -957(ZERO)
9D011E16  FC4326A0   LW V0, 9888(V1)
9D011E18      26A0   SLL A1, V0, 8
9D011E1A      EE06   LI A0, 6
9D011E1C  0044B40C   INS V0, A0, 16, 7
9D011E1E  B40CF843   BNE T4, ZERO, 0x9D010EA8
9D011E20  F84326A0   SW V0, 9888(V1)
9D011E22      26A0   SLL A1, V0, 8
352:                     SPLLCONbits.PLLODIV=0x2;        // / 4  (96/4=24 MHz) CPU
9D011E24  41A3BF80   LUI V1, 0xBF80
9D011E26  BF80FC43   LDC1 F28, -957(ZERO)
9D011E28  FC4326A0   LW V0, 9888(V1)
9D011E2A      26A0   SLL A1, V0, 8
9D011E2C      EE02   LI A0, 2
9D011E2E  0044D60C   INS V0, A0, 24, 3
9D011E30  D60CF843   J 0x9C19F086
9D011E32  F84326A0   SW V0, 9888(V1)
9D011E34      26A0   SLL A1, V0, 8
353:                     
354:                     //SYSKEY force lock
355:                     SYSKEY = 0x00000000;            
9D011E36  41A2BF80   LUI V0, 0xBF80
9D011E38  BF80F802   LDC1 F28, -2046(ZERO)
9D011E3A  F8023670   SW ZERO, 13936(V0)
9D011E3C  36700C00   LHU S3, 3072(S0)
356:                     
357:                     //ceka na dokonceni
358:                     while(REFO1CONbits.ACTIVE==1)
9D011E3E      0C00   NOP
9D011E40  41A2BF80   LUI V0, 0xBF80
9D011E42  BF80FC42   LDC1 F28, -958(ZERO)
9D011E44  FC422720   LW V0, 10016(V0)
9D011E46      2720   SLL A2, V0, 8
9D011E48  D0420100   ANDI V0, V0, 256
9D011E4C  40A2FFF8   BNEZC V0, 0x9D011E40
9D011E4E  FFF841A3   LW RA, 16803(T8)
359:                     { }
360:                     
361:                     //nastaveni REFCLK pro SPI, UART,...
362:                     REFO1CONbits.ROSEL=7;                   //input SPLL (96MHz)
9D011E50  41A3BF80   LUI V1, 0xBF80
9D011E52  BF80FC43   LDC1 F28, -957(ZERO)
9D011E54  FC432720   LW V0, 10016(V1)
9D011E56      2720   SLL A2, V0, 8
9D011E58      EE07   LI A0, 7
9D011E5A  0044180C   INS V0, A0, 0, 4
9D011E5C  180CF843   SB ZERO, -1981(T4)
9D011E5E  F8432720   SW V0, 10016(V1)
9D011E60      2720   SLL A2, V0, 8
363:                     //na vstupu REFCLK je / 2, f=48MHz
364:                     REFO1CONbits.RODIV=0;                   //RODIV / 1, pouzije freq. 48MHz
9D011E62  41A3BF80   LUI V1, 0xBF80
9D011E64  BF80FC43   LDC1 F28, -957(ZERO)
9D011E66  FC432720   LW V0, 10016(V1)
9D011E68      2720   SLL A2, V0, 8
9D011E6A  0040F40C   INS V0, ZERO, 16, 15
9D011E6C  F40CF843   JAL 0x9819F086
9D011E6E  F8432720   SW V0, 10016(V1)
9D011E70      2720   SLL A2, V0, 8
365:                 
366:                     //trim     
367:                     REFO1TRIMbits.ROTRIM=0;
9D011E72  41A3BF80   LUI V1, 0xBF80
9D011E74  BF80FC43   LDC1 F28, -957(ZERO)
9D011E76  FC432730   LW V0, 10032(V1)
9D011E78      2730   SLL A2, V1, 8
9D011E7A  0040FDCC   INS V0, ZERO, 23, 9
9D011E7C  FDCCF843   LW T6, -1981(T4)
9D011E7E  F8432730   SW V0, 10032(V1)
9D011E80      2730   SLL A2, V1, 8
368:                     REFO1CONbits.ON=1;
9D011E82  41A3BF80   LUI V1, 0xBF80
9D011E84  BF80FC43   LDC1 F28, -957(ZERO)
9D011E86  FC432720   LW V0, 10016(V1)
9D011E88      2720   SLL A2, V0, 8
9D011E8A      EE01   LI A0, 1
9D011E8C  00447BCC   INS V0, A0, 15, 1
9D011E8E  7BCCF843   ADDIUPC A3, 20177164
9D011E90  F8432720   SW V0, 10016(V1)
9D011E92      2720   SLL A2, V0, 8
369:                 }
9D011E94      0FBE   MOVE SP, S8
370:                 
371:                 #ifdef SAFE_PROCESS 
372:                 
373:                 static inline void cpuTimer_init()
374:                 {
375:                     //Inicializuje interrupt Cpu Timer, nastavi Compare na max. hodnotu 0xFFFFFFFF 
376:                     //je pouzit k preruseni procesu, pokud bezi dele nez je povoleno, je-li definovano SAFE_PROCESS 
377:                     
378:                     //$9=CP0_COUNT, $11=CP0_COMPARE
379:                     asm("li	    $2, 0xFFFFFFFF");       //v0=0xFFFFFFFF
380:                     asm("mtc0   $2, $11");              //CP0_COMPARE=v0
381:                     asm("ehb");
382:                     asm("mtc0   $0, $9");               //CP0_COUNT=0 (zero)
383:                     asm("ehb");
384:                     
385:                 #ifdef PIC32MM
386:                     //Core Timer interrupt param
387:                     IPC0bits.CTIP=1;        //Priority=1
388:                     IPC0bits.CTIS=0;        //Subpriority=0
389:                     IFS0bits.CTIF=0;        //Flag=0
390:                     IEC0bits.CTIE=1;        //Enable=1
391:                 #endif    
392:                     
393:                 }
394:                 
395:                 #endif
---  d:/bos/bos/i2c.c  ----------------------------------------------------------------------------------
1:                   #include <xc.h>
2:                   #include <stdio.h>
3:                   #include <stdlib.h>
4:                   #include "globals.h"
5:                   #include "i2c.h"
6:                   /*
7:                    * autor JR
8:                    * verze 1.0
9:                    * I2C driver pro procesory rady PIC32MM
10:                   */
11:                  
12:                  
13:                  #if (defined I2C1_INIT || defined I2C2_INIT || defined I2C3_INIT) && (defined PIC32MM)
14:                  
15:                  #define I2C1_DISABLE_MASTER_INTERRUPT   IEC2CLR=0x002
16:                  #define I2C1_ENABLE_MASTER_INTERRUPT    IEC2SET=0x002
17:                  #define I2C1_DISABLE_SLAVE_INTERRUPT    IEC2CLR=0x001
18:                  #define I2C1_ENABLE_SLAVE_INTERRUPT     IEC2SET=0x001
19:                  #define I2C1_DISABLE_BUS_INTERRUPT      IEC2CLR=0x004
20:                  #define I2C1_ENABLE_BUS_INTERRUPT       IEC2SET=0x004
21:                  
22:                  #define I2C2_DISABLE_MASTER_INTERRUPT   IEC2CLR=0x020
23:                  #define I2C2_ENABLE_MASTER_INTERRUPT    IEC2SET=0x020
24:                  #define I2C2_DISABLE_SLAVE_INTERRUPT    IEC2CLR=0x010
25:                  #define I2C2_ENABLE_SLAVE_INTERRUPT     IEC2SET=0x010
26:                  #define I2C2_DISABLE_BUS_INTERRUPT      IEC2CLR=0x040
27:                  #define I2C2_ENABLE_BUS_INTERRUPT       IEC2SET=0x040
28:                  
29:                  #define I2C3_DISABLE_MASTER_INTERRUPT   IEC2CLR=0x100
30:                  #define I2C3_ENABLE_MASTER_INTERRUPT    IEC2SET=0x100
31:                  #define I2C3_DISABLE_SLAVE_INTERRUPT    IEC2CLR=0x080
32:                  #define I2C3_ENABLE_SLAVE_INTERRUPT     IEC2SET=0x080
33:                  #define I2C3_DISABLE_BUS_INTERRUPT      IEC2CLR=0x200
34:                  #define I2C3_ENABLE_BUS_INTERRUPT       IEC2SET=0x200
35:                  
36:                  
37:                  //local var
38:                  void (*_finish)(int);
39:                  
40:                  I2CControl s1={ NULL, NULL, NULL, 0, 0, 0, 0, 0 };
41:                  I2CControl s2={ NULL, NULL, NULL, 0, 0, 0, 0, 0 };   
42:                  I2CControl s3={ NULL, NULL, NULL, 0, 0, 0, 0, 0 }; 
43:                  I2CControl* i2cStruct[]={&s1, &s2, &s3};
44:                  
45:                  void i2c_init()
46:                  {
9D011220      4FB0   ADDIU SP, SP, -8
9D011222      CBC1   SW S8, 4(SP)
9D011224      0FDD   MOVE S8, SP
47:                      
48:                  #ifdef I2C1_INIT    
49:                      
50:                      I2C1CON=0;                  //off, reset
9D011226  41A2BF80   LUI V0, 0xBF80
9D011228  BF80F802   LDC1 F28, -2046(ZERO)
9D01122A  F8021500   SW ZERO, 5376(V0)
9D01122C  150041A3   LBU T0, 16803(ZERO)
51:                      
52:                      IPC16bits.I2C1MIP=1;
9D01122E  41A3BF81   LUI V1, 0xBF81
9D011230  BF81FC43   LDC1 F28, -957(AT)
9D011232  FC43F240   LW V0, -3520(V1)
9D011234  F240EE01   JALX 0x9903B804
9D011236      EE01   LI A0, 1
9D011238  0044A48C   INS V0, A0, 18, 3
9D01123C  F843F240   SW V0, -3520(V1)
9D01123E  F24041A3   JALX 0x9901068C
53:                      IPC16bits.I2C1MIS=0;
9D011240  41A3BF81   LUI V1, 0xBF81
9D011242  BF81FC43   LDC1 F28, -957(AT)
9D011244  FC43F240   LW V0, -3520(V1)
9D011246  F2400040   JALX 0x99000100
9D011248  00408C0C   INS V0, ZERO, 16, 2
9D01124A      8C0C   BEQZ S0, 0x9D011264
9D01124C  F843F240   SW V0, -3520(V1)
9D01124E  F24041A3   JALX 0x9901068C
54:                      IPC16bits.I2C1SIP=1;
9D011250  41A3BF81   LUI V1, 0xBF81
9D011252  BF81FC43   LDC1 F28, -957(AT)
9D011254  FC43F240   LW V0, -3520(V1)
9D011256  F240EE01   JALX 0x9903B804
9D011258      EE01   LI A0, 1
9D01125A  0044628C   INS V0, A0, 10, 3
9D01125E  F843F240   SW V0, -3520(V1)
9D011260  F24041A3   JALX 0x9901068C
55:                      IPC16bits.I2C1SIS=0;
9D011262  41A3BF81   LUI V1, 0xBF81
9D011264  BF81FC43   LDC1 F28, -957(AT)
9D011266  FC43F240   LW V0, -3520(V1)
9D011268  F2400040   JALX 0x99000100
9D01126A  00404A0C   INS V0, ZERO, 8, 2
9D01126C      4A0C   LW S0, 48(SP)
9D01126E  F843F240   SW V0, -3520(V1)
9D011270  F24041A3   JALX 0x9901068C
56:                      IPC16bits.I2C1BCIP=1;
9D011272  41A3BF81   LUI V1, 0xBF81
9D011274  BF81FC43   LDC1 F28, -957(AT)
9D011276  FC43F240   LW V0, -3520(V1)
9D011278  F240EE01   JALX 0x9903B804
9D01127A      EE01   LI A0, 1
9D01127C  0044E68C   INS V0, A0, 26, 3
9D011280  F843F240   SW V0, -3520(V1)
9D011282  F24041A3   JALX 0x9901068C
57:                      IPC16bits.I2C1BCIS=0;
9D011284  41A3BF81   LUI V1, 0xBF81
9D011286  BF81FC43   LDC1 F28, -957(AT)
9D011288  FC43F240   LW V0, -3520(V1)
9D01128A  F2400040   JALX 0x99000100
9D01128C  0040CE0C   INS V0, ZERO, 24, 2
9D01128E      CE0C   B 0x9D010EA8
9D011290  F843F240   SW V0, -3520(V1)
9D011292  F24041A2   JALX 0x99010688
58:                      
59:                      I2C1BRG=0xC;                //CPU 20MHz, bus 400kHz
9D011294  41A2BF80   LUI V0, 0xBF80
9D011296  BF80ED8C   LDC1 F28, -4724(ZERO)
9D011298      ED8C   LI V1, 12
9D01129A  F8621540   SW V1, 5440(V0)
9D01129C  154041A3   LBU T2, 16803(ZERO)
60:                      I2C1CONbits.ON=1;
9D01129E  41A3BF80   LUI V1, 0xBF80
9D0112A0  BF80FC43   LDC1 F28, -957(ZERO)
9D0112A2  FC431500   LW V0, 5376(V1)
9D0112A4  1500EE01   LBU T0, -4607(ZERO)
9D0112A6      EE01   LI A0, 1
9D0112A8  00447BCC   INS V0, A0, 15, 1
9D0112AA  7BCCF843   ADDIUPC A3, 20177164
9D0112AC  F8431500   SW V0, 5376(V1)
9D0112AE  15000FBE   LBU T0, 4030(ZERO)
61:                      
62:                  #endif    
63:                      
64:                  #ifdef I2C2_INIT    
65:                      
66:                      I2C2CON=0;                  //off, reset
67:                      
68:                      IPC17bits.I2C2MIP=1;        //master interrupt
69:                      IPC17bits.I2C2MIS=0;
70:                      IPC17bits.I2C2SIP=1;        //slave interrupt
71:                      IPC17bits.I2C2SIS=0;
72:                      IPC17bits.I2C2BCIP=1;       //bus interrupt
73:                      IPC17bits.I2C2BCIS=0;
74:                      
75:                      I2C2BRG=0xC;                //CPU-24MHz ... min. 0xB, CPU-8MHz ... min 0x5
76:                      I2C2CONbits.ON=1;
77:                      
78:                  #endif     
79:                      
80:                  #ifdef I2C3_INIT    
81:                      
82:                      I2C3CON=0;                  //off, reset
83:                      
84:                      IPC18bits.I2C3MIP=1;
85:                      IPC18bits.I2C3MIS=0;
86:                      IPC17bits.I2C3SIP=1;
87:                      IPC17bits.I2C3SIS=0;
88:                      IPC18bits.I2C3BCIP=1;
89:                      IPC18bits.I2C3BCIS=0;
90:                      
91:                      I2C3BRG=0xC;              //CPU 20MHz, bus 400kHz
92:                      I2C3CONbits.ON=1;
93:                      
94:                  #endif        
95:                      
96:                  }
9D0112B0      0FBE   MOVE SP, S8
9D0112B2      4BC1   LW S8, 4(SP)
9D0112B4      4C05   ADDIU SP, SP, 8
9D0112B6      45BF   JRC RA
97:                  
98:                  char i2c_getUsed(int index)
99:                  {
9D0112B8      4FB0   ADDIU SP, SP, -8
9D0112BA      CBC1   SW S8, 4(SP)
9D0112BC      0FDD   MOVE S8, SP
9D0112BE  F89E0008   SW A0, 8(S8)
100:                     //used definuje, zda nejaky proces pouziva I2C, nebo zda je volne
101:                     return i2cStruct[index]->used;
9D0112C2  41A28000   LUI V0, 0x8000
9D0112C6  FC7E0008   LW V1, 8(S8)
9D0112CA      25B4   SLL V1, V1, 2
9D0112CC  30420BA8   ADDIU V0, V0, 2984
9D0112CE      0BA8   LBU A3, 8(V0)
9D0112D0      0526   ADDU V0, V1, V0
9D0112D2      6920   LW V0, 0(V0)
9D0112D4  1442000F   LBU V0, 15(V0)
102:                 }
9D0112D8      0FBE   MOVE SP, S8
9D0112DA      4BC1   LW S8, 4(SP)
9D0112DC      4C05   ADDIU SP, SP, 8
9D0112DE      45BF   JRC RA
103:                 
104:                 char i2c_Process(char index, char wait)
105:                 {
9D0112E0      4FF5   ADDIU SP, SP, -24
9D0112E2      CBE5   SW RA, 20(SP)
9D0112E4      CBC4   SW S8, 16(SP)
9D0112E6      0FDD   MOVE S8, SP
9D0112E8      0C64   MOVE V1, A0
9D0112EA      0C45   MOVE V0, A1
9D0112EC  187E0018   SB V1, 24(S8)
9D0112F0  185E001C   SB V0, 28(S8)
106:                     //vraci SPI_STATE.SENDING=probiha vysilani bufferu, SPI_STATE.FINISHED=vysilani dokonceno
107:                     //nastavuje SPI automaticky
108:                     
109:                     while(1)
110:                     {
111:                         if(i2cStruct[index]->process == SPI_STATE.FINISHED)
9D0112F4  147E0018   LBU V1, 24(S8)
9D0112F8  41A28000   LUI V0, 0x8000
9D0112FC      25B4   SLL V1, V1, 2
9D0112FE  30420BA8   ADDIU V0, V0, 2984
9D011300      0BA8   LBU A3, 8(V0)
9D011302      0526   ADDU V0, V1, V0
9D011304      6920   LW V0, 0(V0)
9D011306  14620010   LBU V1, 16(V0)
9D011308  00100C40   SRL ZERO, S0, 1
9D01130A      0C40   MOVE V0, ZERO
9D01130C  B4430004   BNE V1, V0, 0x9D011318
9D01130E  00040C00   SLL ZERO, A0, 1
9D011310      0C00   NOP
112:                         {
113:                             return SPI_STATE.FINISHED;
9D011312      0C40   MOVE V0, ZERO
9D011314      CC0D   B 0x9D011330
9D011316      0C00   NOP
114:                         }
115:                         
116:                         //vysilani neni dokonceno
117:                         if(wait==0) { return SPI_STATE.SENDING; }
9D011318  145E001C   LBU V0, 28(S8)
9D01131C  40A20003   BNEZC V0, 0x9D011326
9D011320      ED01   LI V0, 1
9D011322      CC06   B 0x9D011330
9D011324      0C00   NOP
118:                         doEvents();
9D011326  76807F8E   JALS doEvents
9D01132A      0C00   NOP
119:                     }
9D01132C      CFE3   B 0x9D0112F4
9D01132E      0C00   NOP
120:                     
121:                     return i2cStruct[index]->process;
122:                 }
9D011330      0FBE   MOVE SP, S8
9D011332      4BE5   LW RA, 20(SP)
9D011334      4BC4   LW S8, 16(SP)
9D011336      4C0D   ADDIU SP, SP, 24
9D011338      45BF   JRC RA
9D01133A      0C00   NOP
123:                 
124:                 void i2c_Free(int index)
125:                 {
9D01133C      4FF5   ADDIU SP, SP, -24
9D01133E      CBE5   SW RA, 20(SP)
9D011340      CBC4   SW S8, 16(SP)
9D011342      0FDD   MOVE S8, SP
9D011344  F89E0018   SW A0, 24(S8)
126:                     //pokud jeste probiha vysilani dat
127:                     //ceka na dokonceni, protoze po spi_free se vetsinou vola setCS>1
128:                     //takze by data nebyla prijata 
129:                     
130:                     while(i2cStruct[index]->process == SPI_STATE.SENDING)
9D011348      CC04   B 0x9D011352
9D01134A      0C00   NOP
9D011352  41A28000   LUI V0, 0x8000
9D011356  FC7E0018   LW V1, 24(S8)
9D01135A      25B4   SLL V1, V1, 2
9D01135C  30420BA8   ADDIU V0, V0, 2984
9D01135E      0BA8   LBU A3, 8(V0)
9D011360      0526   ADDU V0, V1, V0
9D011362      6920   LW V0, 0(V0)
9D011364  14620010   LBU V1, 16(V0)
9D011368      ED01   LI V0, 1
9D01136A  9443FFEF   BEQ V1, V0, 0x9D01134C
9D01136C  FFEF0C00   LW RA, 3072(T7)
9D01136E      0C00   NOP
131:                     {
132:                         //jeste probiha vysilani
133:                         doEvents();
9D01134C  76807F8E   JALS doEvents
9D011350      0C00   NOP
134:                     }
135:                     i2cStruct[index]->used=SPI_STATE.EMPTY;
9D011370  41A28000   LUI V0, 0x8000
9D011374  FC7E0018   LW V1, 24(S8)
9D011378      25B4   SLL V1, V1, 2
9D01137A  30420BA8   ADDIU V0, V0, 2984
9D01137C      0BA8   LBU A3, 8(V0)
9D01137E      0526   ADDU V0, V1, V0
9D011380      6920   LW V0, 0(V0)
9D011382      0C60   MOVE V1, ZERO
9D011384      89AF   SB V1, 15(V0)
136:                 }
9D011386      0FBE   MOVE SP, S8
9D011388      4BE5   LW RA, 20(SP)
9D01138A      4BC4   LW S8, 16(SP)
9D01138C      4C0D   ADDIU SP, SP, 24
9D01138E      45BF   JRC RA
137:                 
138:                 char i2c_Use(char index, char wait, void* finish)
139:                 {
9D011390      4FF5   ADDIU SP, SP, -24
9D011392      CBE5   SW RA, 20(SP)
9D011394      CBC4   SW S8, 16(SP)
9D011396      0FDD   MOVE S8, SP
9D011398      0C64   MOVE V1, A0
9D01139A      0C45   MOVE V0, A1
9D01139C  F8DE0020   SW A2, 32(S8)
9D0113A0  187E0018   SB V1, 24(S8)
9D0113A4  185E001C   SB V0, 28(S8)
140:                     //je-li i2c volne, nastavi SPI_STATE.USED a vraci 1 (true)
141:                     //neni-li volne 
142:                     //a) pri wait==1 ceka (doEvents) na uvolneni
143:                     //b) pri wait==0 vraci 0 (obsazeno jinym procesem)
144:                     
145:                     while(1)
146:                     {
147:                         if((i2cStruct[index]->used == SPI_STATE.EMPTY) && (i2cStruct[index]->process == SPI_STATE.FINISHED))
9D0113A8  147E0018   LBU V1, 24(S8)
9D0113AC  41A28000   LUI V0, 0x8000
9D0113B0      25B4   SLL V1, V1, 2
9D0113B2  30420BA8   ADDIU V0, V0, 2984
9D0113B4      0BA8   LBU A3, 8(V0)
9D0113B6      0526   ADDU V0, V1, V0
9D0113B8      6920   LW V0, 0(V0)
9D0113BA  1462000F   LBU V1, 15(V0)
9D0113BC  000F0C40   SRL ZERO, T7, 1
9D0113BE      0C40   MOVE V0, ZERO
9D0113C0  B443002A   BNE V1, V0, 0x9D011418
9D0113C2  002A0C00   SLL AT, T2, 1
9D0113C4      0C00   NOP
9D0113C6  147E0018   LBU V1, 24(S8)
9D0113CA  41A28000   LUI V0, 0x8000
9D0113CE      25B4   SLL V1, V1, 2
9D0113D0  30420BA8   ADDIU V0, V0, 2984
9D0113D2      0BA8   LBU A3, 8(V0)
9D0113D4      0526   ADDU V0, V1, V0
9D0113D6      6920   LW V0, 0(V0)
9D0113D8  14620010   LBU V1, 16(V0)
9D0113DA  00100C40   SRL ZERO, S0, 1
9D0113DC      0C40   MOVE V0, ZERO
9D0113DE  B443001B   BNE V1, V0, 0x9D011418
9D0113E0  001B0C00   SLL ZERO, K1, 1
9D0113E2      0C00   NOP
148:                         {
149:                             i2cStruct[index]->used=SPI_STATE.USED;
9D0113E4  147E0018   LBU V1, 24(S8)
9D0113E8  41A28000   LUI V0, 0x8000
9D0113EC      25B4   SLL V1, V1, 2
9D0113EE  30420BA8   ADDIU V0, V0, 2984
9D0113F0      0BA8   LBU A3, 8(V0)
9D0113F2      0526   ADDU V0, V1, V0
9D0113F4      6920   LW V0, 0(V0)
9D0113F6      ED81   LI V1, 1
9D0113F8      89AF   SB V1, 15(V0)
150:                             i2cStruct[index]->finishFn=finish;
9D0113FA  147E0018   LBU V1, 24(S8)
9D0113FE  41A28000   LUI V0, 0x8000
9D011402      25B4   SLL V1, V1, 2
9D011404  30420BA8   ADDIU V0, V0, 2984
9D011406      0BA8   LBU A3, 8(V0)
9D011408      0526   ADDU V0, V1, V0
9D01140A      6920   LW V0, 0(V0)
9D01140C  FC7E0020   LW V1, 32(S8)
9D011410      E9A2   SW V1, 8(V0)
151:                             //i2cStruct[index]->eventFn=event;
152:                             return 1;
9D011412      ED01   LI V0, 1
9D011414      CC0D   B 0x9D011430
9D011416      0C00   NOP
153:                         }
154:                         
155:                         if(wait==0) { return 0; }
9D011418  145E001C   LBU V0, 28(S8)
9D01141C  40A20003   BNEZC V0, 0x9D011426
9D01141E  00030C40   SRL ZERO, V1, 1
9D011420      0C40   MOVE V0, ZERO
9D011422      CC06   B 0x9D011430
9D011424      0C00   NOP
156:                         
157:                         doEvents();
9D011426  76807F8E   JALS doEvents
9D01142A      0C00   NOP
158:                     }
9D01142C      CFBD   B 0x9D0113A8
9D01142E      0C00   NOP
159:                 }
9D011430      0FBE   MOVE SP, S8
9D011432      4BE5   LW RA, 20(SP)
9D011434      4BC4   LW S8, 16(SP)
9D011436      4C0D   ADDIU SP, SP, 24
9D011438      45BF   JRC RA
9D01143A      0C00   NOP
160:                 
161:                 void i2c_WriteDE(int index, char* buffer, int len, int addr)
162:                 {
9D01143C      4FF5   ADDIU SP, SP, -24
9D01143E      CBE5   SW RA, 20(SP)
9D011440      CBC4   SW S8, 16(SP)
9D011442      0FDD   MOVE S8, SP
9D011444  F89E0018   SW A0, 24(S8)
9D011448  F8BE001C   SW A1, 28(S8)
9D01144C  F8DE0020   SW A2, 32(S8)
9D011450  F8FE0024   SW A3, 36(S8)
163:                     //pokud probiha vysilani, vola doEvents, ceka na dokonceni
164:                     while(i2cStruct[index]->process != SPI_STATE.FINISHED)
9D011454      CC04   B 0x9D01145E
9D011456      0C00   NOP
9D01145E  41A28000   LUI V0, 0x8000
9D011462  FC7E0018   LW V1, 24(S8)
9D011466      25B4   SLL V1, V1, 2
9D011468  30420BA8   ADDIU V0, V0, 2984
9D01146A      0BA8   LBU A3, 8(V0)
9D01146C      0526   ADDU V0, V1, V0
9D01146E      6920   LW V0, 0(V0)
9D011470  14620010   LBU V1, 16(V0)
9D011472  00100C40   SRL ZERO, S0, 1
9D011474      0C40   MOVE V0, ZERO
9D011476  B443FFEF   BNE V1, V0, 0x9D011458
9D011478  FFEF0C00   LW RA, 3072(T7)
9D01147A      0C00   NOP
165:                     {
166:                         doEvents();
9D011458  76807F8E   JALS doEvents
9D01145C      0C00   NOP
167:                     }
168:                     
169:                     i2c_Write(index, buffer, len, addr);
9D01147C  FC9E0018   LW A0, 24(S8)
9D011480  FCBE001C   LW A1, 28(S8)
9D011484  FCDE0020   LW A2, 32(S8)
9D011488  FCFE0024   LW A3, 36(S8)
9D01148A  00247680   OR T6, A0, AT
9D01148C  76808A4E   JALS i2c_Write
9D01148E      8A4E   SB A0, 14(A0)
9D011490      0C00   NOP
170:                 }
9D011492      0FBE   MOVE SP, S8
9D011494      4BE5   LW RA, 20(SP)
9D011496      4BC4   LW S8, 16(SP)
9D011498      4C0D   ADDIU SP, SP, 24
9D01149A      45BF   JRC RA
171:                 
172:                 void i2c_Write(int index, char* buffer, int len, int addr)
173:                 {
9D01149C      4FF5   ADDIU SP, SP, -24
9D01149E      CBE5   SW RA, 20(SP)
9D0114A0      CBC4   SW S8, 16(SP)
9D0114A2      0FDD   MOVE S8, SP
9D0114A4  F89E0018   SW A0, 24(S8)
9D0114A8  F8BE001C   SW A1, 28(S8)
9D0114AC  F8DE0020   SW A2, 32(S8)
9D0114B0  F8FE0024   SW A3, 36(S8)
174:                     //addr je adresa slave (bez posunuti b0, pred odeslanim bude posunuta vlevo a do b0 se doplni 0=W, nebo 1=R)
175:                     i2cStruct[index]->tx_buffer=buffer;
9D0114B4  41A28000   LUI V0, 0x8000
9D0114B8  FC7E0018   LW V1, 24(S8)
9D0114BC      25B4   SLL V1, V1, 2
9D0114BE  30420BA8   ADDIU V0, V0, 2984
9D0114C0      0BA8   LBU A3, 8(V0)
9D0114C2      0526   ADDU V0, V1, V0
9D0114C4      6920   LW V0, 0(V0)
9D0114C6  FC7E001C   LW V1, 28(S8)
9D0114C8  001CE9A0   SUB SP, GP, ZERO
9D0114CA      E9A0   SW V1, 0(V0)
176:                     i2cStruct[index]->len=len;
9D0114CC  41A28000   LUI V0, 0x8000
9D0114D0  FC7E0018   LW V1, 24(S8)
9D0114D4      25B4   SLL V1, V1, 2
9D0114D6  30420BA8   ADDIU V0, V0, 2984
9D0114D8      0BA8   LBU A3, 8(V0)
9D0114DA      0526   ADDU V0, V1, V0
9D0114DC      6920   LW V0, 0(V0)
9D0114DE  FC7E0020   LW V1, 32(S8)
9D0114E2  00633B3C   SEH V1, V1
9D0114E4  3B3CA9A6   SH T9, -22106(GP)
9D0114E6      A9A6   SH V1, 12(V0)
177:                     i2cStruct[index]->address=addr;
9D0114E8  41A28000   LUI V0, 0x8000
9D0114EC  FC7E0018   LW V1, 24(S8)
9D0114F0      25B4   SLL V1, V1, 2
9D0114F2  30420BA8   ADDIU V0, V0, 2984
9D0114F4      0BA8   LBU A3, 8(V0)
9D0114F6      0526   ADDU V0, V1, V0
9D0114F8      6920   LW V0, 0(V0)
9D0114FA  FC7E0024   LW V1, 36(S8)
9D0114FC  00242DBD   REPL.PH A1, 0x24
9D0114FE      2DBD   ANDI V1, V1, 0xFF
9D011500      89AE   SB V1, 14(V0)
178:                     i2cStruct[index]->error=0;
9D011502  41A28000   LUI V0, 0x8000
9D011506  FC7E0018   LW V1, 24(S8)
9D01150A      25B4   SLL V1, V1, 2
9D01150C  30420BA8   ADDIU V0, V0, 2984
9D01150E      0BA8   LBU A3, 8(V0)
9D011510      0526   ADDU V0, V1, V0
9D011512      6920   LW V0, 0(V0)
9D011514  18020011   SB ZERO, 17(V0)
179:                     i2cStruct[index]->process=SPI_STATE.SENDING;
9D011518  41A28000   LUI V0, 0x8000
9D01151C  FC7E0018   LW V1, 24(S8)
9D011520      25B4   SLL V1, V1, 2
9D011522  30420BA8   ADDIU V0, V0, 2984
9D011524      0BA8   LBU A3, 8(V0)
9D011526      0526   ADDU V0, V1, V0
9D011528      6920   LW V0, 0(V0)
9D01152A      ED81   LI V1, 1
9D01152C  18620010   SB V1, 16(V0)
180:                     i2cStruct[index]->internalState=0;
9D011530  41A28000   LUI V0, 0x8000
9D011534  FC7E0018   LW V1, 24(S8)
9D011538      25B4   SLL V1, V1, 2
9D01153A  30420BA8   ADDIU V0, V0, 2984
9D01153C      0BA8   LBU A3, 8(V0)
9D01153E      0526   ADDU V0, V1, V0
9D011540      6920   LW V0, 0(V0)
9D011542  18020012   SB ZERO, 18(V0)
181:                     
182:                     if(index==0)
9D011546  FC5E0018   LW V0, 24(S8)
9D01154A  40A20003   BNEZC V0, 0x9D011554
9D01154C  00037680   OR T6, V1, ZERO
183:                     { 
184:                 #ifdef I2C1_INIT        
185:                         i2c1_MasterInterrupt(); 
9D01154E  76808AB0   JALS i2c1_MasterInterrupt
9D011550      8AB0   SB A1, 0(V1)
9D011552      0C00   NOP
186:                 #endif        
187:                     }
188:                     else if (index==1) 
189:                     { 
190:                 #ifdef I2C2_INIT        
191:                         i2c2_MasterInterrupt(); 
192:                 #endif        
193:                     }
194:                     else if (index==2) 
195:                     { 
196:                 #ifdef I2C3_INIT        
197:                         i2c3_MasterInterrupt(); 
198:                 #endif        
199:                     }
200:                 }
9D011554      0FBE   MOVE SP, S8
9D011556      4BE5   LW RA, 20(SP)
9D011558      4BC4   LW S8, 16(SP)
9D01155A      4C0D   ADDIU SP, SP, 24
9D01155C      45BF   JRC RA
9D01155E      0C00   NOP
201:                 
202:                 
203:                 #ifdef I2C1_INIT
204:                 
205:                 void i2c1_MasterInterrupt()
206:                 {
9D011560      4FF1   ADDIU SP, SP, -32
9D011562      CBE7   SW RA, 28(SP)
9D011564      CBC6   SW S8, 24(SP)
9D011566      0FDD   MOVE S8, SP
207:                    I2CControl* ctl = i2cStruct[0];
9D011568  41A28000   LUI V0, 0x8000
9D01156C  FC420BA8   LW V0, 2984(V0)
9D01156E      0BA8   LBU A3, 8(V0)
9D011570  F85E0010   SW V0, 16(S8)
9D011572  00100C00   SLL ZERO, S0, 1
208:                     
209:                     //Nevim proc, ale interrupt nastava drive, nez je TFB nulovan (novy zapis do I2C2TRN je mozny az po nulovani TFB)
210:                     //to same plati pro TRSTAT
211:                     while(I2C1STATbits.TRSTAT==1 || I2C1STATbits.TBF==1)
9D011574      0C00   NOP
9D011576  41A2BF80   LUI V0, 0xBF80
9D011578  BF80FC42   LDC1 F28, -958(ZERO)
9D01157A  FC421510   LW V0, 5392(V0)
9D01157C  1510D042   LBU T0, -12222(S0)
9D01157E  D0424000   ANDI V0, V0, 16384
9D011580  400040A2   BLTZ ZERO, 0x9D0196C8
9D011582  40A2FFF8   BNEZC V0, 0x9D011576
9D011584  FFF841A2   LW RA, 16802(T8)
9D011586  41A2BF80   LUI V0, 0xBF80
9D011588  BF80FC42   LDC1 F28, -958(ZERO)
9D01158A  FC421510   LW V0, 5392(V0)
9D01158C  15102D21   LBU T0, 11553(S0)
9D01158E      2D21   ANDI V0, V0, 0x1
9D011590  40A2FFF1   BNEZC V0, 0x9D011576
9D011592  FFF1FC5E   LW RA, -930(S1)
212:                     {
213:                         
214:                     }
215:                     
216:                     if(ctl->internalState==0)
9D011594  FC5E0010   LW V0, 16(S8)
9D011598  14420012   LBU V0, 18(V0)
9D01159C  40A20027   BNEZC V0, 0x9D0115EE
217:                     {
218:                         //SEN, start signal
219:                         I2C1_ENABLE_MASTER_INTERRUPT;
9D0115A0  41A2BF81   LUI V0, 0xBF81
9D0115A2  BF81ED82   LDC1 F28, -4734(AT)
9D0115A4      ED82   LI V1, 2
9D0115A6  F862F0E8   SW V1, -3864(V0)
9D0115A8  F0E841A2   JALX 0x9BA10688
220:                         
221:                         if(I2C1STATbits.S==1)
9D0115AA  41A2BF80   LUI V0, 0xBF80
9D0115AC  BF80FC42   LDC1 F28, -958(ZERO)
9D0115AE  FC421510   LW V0, 5392(V0)
9D0115B0  15102D26   LBU T0, 11558(S0)
9D0115B2      2D26   ANDI V0, V0, 0x8
9D0115B4  40E2000B   BEQZC V0, 0x9D0115CE
222:                         {
223:                             //nyni by melo byt vzdy S=0
224:                             //nevim proc, ale nekdy po odeslani END nastane na sbernici START stav
225:                             //proto musi byt odeslano END
226:                             I2C1CONbits.PEN=1;
9D0115B8  41A3BF80   LUI V1, 0xBF80
9D0115BA  BF80FC43   LDC1 F28, -957(ZERO)
9D0115BC  FC431500   LW V0, 5376(V1)
9D0115BE  1500EE01   LBU T0, -4607(ZERO)
9D0115C0      EE01   LI A0, 1
9D0115C2  0044108C   INS V0, A0, 2, 1
9D0115C4  108CF843   ADDI A0, T4, -1981
9D0115C6  F8431500   SW V0, 5376(V1)
9D0115C8  1500CC80   LBU T0, -13184(ZERO)
227:                             return;
9D0115CA      CC80   B 0x9D0116CC
9D0115CC      0C00   NOP
228:                         }
229:                         else
230:                         {
231:                             I2C1CONbits.SEN=1;
9D0115CE  41A3BF80   LUI V1, 0xBF80
9D0115D0  BF80FC43   LDC1 F28, -957(ZERO)
9D0115D2  FC431500   LW V0, 5376(V1)
9D0115D4  1500EE01   LBU T0, -4607(ZERO)
9D0115D6      EE01   LI A0, 1
9D0115D8  0044000C   INS V0, A0, 0, 1
9D0115DC  F8431500   SW V0, 5376(V1)
9D0115DE  1500FC5E   LBU T0, -930(ZERO)
232:                             ctl->internalState=1;
9D0115E0  FC5E0010   LW V0, 16(S8)
9D0115E4      ED81   LI V1, 1
9D0115E6  18620012   SB V1, 18(V0)
233:                             return;
9D0115EA      CC70   B 0x9D0116CC
9D0115EC      0C00   NOP
234:                         }
235:                     }
236:                     else if(ctl->internalState==1)
9D0115EE  FC5E0010   LW V0, 16(S8)
9D0115F2  14620012   LBU V1, 18(V0)
9D0115F6      ED01   LI V0, 1
9D0115F8  B4430011   BNE V1, V0, 0x9D01161E
9D0115FA  00110C00   SLL ZERO, S1, 1
9D0115FC      0C00   NOP
237:                     {
238:                         //Tx address byte (7-bit)
239:                         //char ad=ctl->address << 1;
240:                         I2C1TRN=(ctl->address << 1);           //b0=0, write
9D0115FE  FC5E0010   LW V0, 16(S8)
9D011602      092E   LBU V0, 14(V0)
9D011604      2522   SLL V0, V0, 1
9D011606      0C62   MOVE V1, V0
9D011608  41A2BF80   LUI V0, 0xBF80
9D01160A  BF80F862   LDC1 F28, -1950(ZERO)
9D01160C  F8621550   SW V1, 5456(V0)
9D01160E  1550FC5E   LBU T2, -930(S0)
241:                         
242:                         ctl->internalState=2;
9D011610  FC5E0010   LW V0, 16(S8)
9D011614      ED82   LI V1, 2
9D011616  18620012   SB V1, 18(V0)
9D011618  0012CC58   MOVZ T9, S2, ZERO
243:                         return;
9D01161A      CC58   B 0x9D0116CC
9D01161C      0C00   NOP
244:                     }
245:                     else if(ctl->internalState==2)
9D01161E  FC5E0010   LW V0, 16(S8)
9D011622  14620012   LBU V1, 18(V0)
9D011626      ED02   LI V0, 2
9D011628  B443002F   BNE V1, V0, 0x9D01168A
9D01162A  002F0C00   SLL AT, T7, 1
9D01162C      0C00   NOP
246:                     {
247:                         if(I2C1STATbits.ACKSTAT==1)
9D01162E  41A2BF80   LUI V0, 0xBF80
9D011630  BF80FC42   LDC1 F28, -958(ZERO)
9D011632  FC421510   LW V0, 5392(V0)
9D011634  15102D2E   LBU T0, 11566(S0)
9D011636      2D2E   ANDI V0, V0, 0x8000
9D011638  40E20015   BEQZC V0, 0x9D011666
248:                         {
249:                             //chyba, slave odpovedel NACK
250:                             ctl->error=1;
9D01163C  FC5E0010   LW V0, 16(S8)
9D011640      ED81   LI V1, 1
9D011642  18620011   SB V1, 17(V0)
251:                             I2C1CONbits.PEN=1;                  //PEN
9D011646  41A3BF80   LUI V1, 0xBF80
9D011648  BF80FC43   LDC1 F28, -957(ZERO)
9D01164A  FC431500   LW V0, 5376(V1)
9D01164C  1500EE01   LBU T0, -4607(ZERO)
9D01164E      EE01   LI A0, 1
9D011650  0044108C   INS V0, A0, 2, 1
9D011652  108CF843   ADDI A0, T4, -1981
9D011654  F8431500   SW V0, 5376(V1)
9D011656  1500FC5E   LBU T0, -930(ZERO)
252:                             ctl->internalState=3;
9D011658  FC5E0010   LW V0, 16(S8)
9D01165C      ED83   LI V1, 3
9D01165E  18620012   SB V1, 18(V0)
253:                             return;
9D011662      CC34   B 0x9D0116CC
9D011664      0C00   NOP
254:                         }
255:                           
256:                         //dalsi byte
257:                         I2C1TRN=*ctl->tx_buffer;
9D011666  FC5E0010   LW V0, 16(S8)
9D011668  00106920   ADD T5, S0, ZERO
9D01166A      6920   LW V0, 0(V0)
9D01166C      0920   LBU V0, 0(V0)
9D01166E      0C62   MOVE V1, V0
9D011670  41A2BF80   LUI V0, 0xBF80
9D011672  BF80F862   LDC1 F28, -1950(ZERO)
9D011674  F8621550   SW V1, 5456(V0)
9D011676  1550FC5E   LBU T2, -930(S0)
258:                         ctl->tx_buffer++;  
9D011678  FC5E0010   LW V0, 16(S8)
9D01167A  00106920   ADD T5, S0, ZERO
9D01167C      6920   LW V0, 0(V0)
9D01167E      6DA0   ADDIU V1, V0, 1
9D011680  FC5E0010   LW V0, 16(S8)
9D011682  0010E9A0   SUB SP, S0, ZERO
9D011684      E9A0   SW V1, 0(V0)
259:                         return;
9D011686      CC22   B 0x9D0116CC
9D011688      0C00   NOP
260:                     }
261:                     else if (ctl->internalState==3)
9D01168A  FC5E0010   LW V0, 16(S8)
9D01168E  14620012   LBU V1, 18(V0)
9D011692      ED03   LI V0, 3
9D011694  B443001A   BNE V1, V0, 0x9D0116CC
9D011696  001A0C00   SLL ZERO, K0, 1
9D011698      0C00   NOP
262:                     {
263:                         //after PEN, ukonceni prenosu
264:                         I2C1_DISABLE_MASTER_INTERRUPT;
9D01169A  41A2BF81   LUI V0, 0xBF81
9D01169C  BF81ED82   LDC1 F28, -4734(AT)
9D01169E      ED82   LI V1, 2
9D0116A0  F862F0E4   SW V1, -3868(V0)
9D0116A2  F0E4FC5E   JALX 0x9B93F178
265:                         
266:                         if(ctl->finishFn != NULL)
9D0116A4  FC5E0010   LW V0, 16(S8)
9D0116A8      6922   LW V0, 8(V0)
9D0116AA  40E2000E   BEQZC V0, 0x9D0116CA
267:                         {
268:                             _finish=ctl->finishFn;
9D0116AE  FC5E0010   LW V0, 16(S8)
9D0116B2      6922   LW V0, 8(V0)
9D0116B4  F85C8098   SW V0, -32616(GP)
269:                             _finish(ctl->used);
9D0116B8  FC5C8098   LW V0, -32616(GP)
9D0116BC  FC7E0010   LW V1, 16(S8)
9D0116C0  1463000F   LBU V1, 15(V1)
9D0116C4      0C83   MOVE A0, V1
9D0116C6      45E2   JALRS16 V0
9D0116C8      0C00   NOP
270:                         }
271:                         return;
9D0116CA      0C00   NOP
272:                     }    
273:                 }
9D0116CC      0FBE   MOVE SP, S8
9D0116CE      4BE7   LW RA, 28(SP)
9D0116D0      4BC6   LW S8, 24(SP)
9D0116D2      4C11   ADDIU SP, SP, 32
9D0116D4      45BF   JRC RA
9D0116D6      0C00   NOP
274:                 
275:                 void i2c1_SlaveInterrupt()
276:                 {
9D0116D8      4FB0   ADDIU SP, SP, -8
9D0116DA      CBC1   SW S8, 4(SP)
9D0116DC      0FDD   MOVE S8, SP
277:                     return;
9D0116DE      0C00   NOP
278:                 }
9D0116E0      0FBE   MOVE SP, S8
9D0116E2      4BC1   LW S8, 4(SP)
9D0116E4      4C05   ADDIU SP, SP, 8
9D0116E6      45BF   JRC RA
279:                 
280:                 void i2c1_BusInterrupt()
281:                 {
9D0116E8      4FB0   ADDIU SP, SP, -8
9D0116EA      CBC1   SW S8, 4(SP)
9D0116EC      0FDD   MOVE S8, SP
282:                     return;
9D0116EE      0C00   NOP
283:                 }
9D0116F0      0FBE   MOVE SP, S8
284:                 
285:                 #endif
286:                 
287:                 #ifdef I2C2_INIT
288:                 
289:                 void i2c2_MasterInterrupt()
290:                 {
291:                     I2CControl* ctl = i2cStruct[1];
292:                     
293:                     //Nevim proc, ale interrupt nastava drive, nez je TFB nulovan (novy zapis do I2C2TRN je mozny az po nulovani TFB)
294:                     //to same plati pro TRSTAT
295:                     while(I2C2STATbits.TRSTAT==1 || I2C2STATbits.TBF==1)
296:                     {
297:                         
298:                     }
299:                     
300:                     if(ctl->internalState == 0)
301:                     {
302:                         //SEN, start signal
303:                         I2C2_ENABLE_MASTER_INTERRUPT;
304:                         
305:                         if(I2C2STATbits.S==1)
306:                         {
307:                             //nyni by melo byt vzdy S=0
308:                             //nevim proc, ale nekdy po odeslani END nastane na sbernici START stav
309:                             //proto musi byt odeslano END
310:                             I2C2CONbits.PEN=1;
311:                             return;
312:                         }
313:                         else
314:                         {
315:                             I2C2CONbits.SEN=1;
316:                             ctl->internalState=1;
317:                             return;
318:                         }
319:                     }
320:                     else if(ctl->internalState == 1)
321:                     {
322:                         //Tx address byte (7-bit)
323:                         //char ad=ctl->address << 1;
324:                         I2C2TRN=(ctl->address << 1);           //b0=0, write
325:                         
326:                         ctl->internalState = 2;
327:                         return;
328:                     }
329:                     else if(ctl->internalState == 2)
330:                     {
331:                         //vysilani dat
332:                         if(I2C2STATbits.ACKSTAT==1)
333:                         {
334:                             //chyba, slave odpovedel NACK
335:                             ctl->error=1;
336:                             I2C2CONbits.PEN=1;                  //PEN
337:                             ctl->internalState=3;
338:                             return;
339:                         }
340:                         
341:                         if(ctl->len > 0)
342:                         {
343:                             //dalsi byte z bufferu
344:                             I2C2TRN=*ctl->tx_buffer;
345:                             ctl->tx_buffer++;  
346:                             ctl->len--;
347:                             return;            
348:                         }
349:                         else
350:                         {
351:                             //konec, vse odeslano
352:                             I2C2CONbits.PEN=1;                  //PEN
353:                             ctl->internalState=3;
354:                             return;
355:                         }
356:                     }
357:                     else if (ctl->internalState == 3)
358:                     {
359:                         //after PEN, ukonceni prenosu
360:                         I2C2_DISABLE_MASTER_INTERRUPT;
361:                         
362:                         if(ctl->finishFn != NULL)
363:                         {
364:                             _finish=ctl->finishFn;
365:                             _finish(ctl->used);
366:                         }
367:                         
368:                         ctl->process=SPI_STATE.FINISHED;
369:                         return;
370:                     }    
371:                 }
372:                 
373:                 void i2c2_SlaveInterrupt()
374:                 {
375:                     return;
376:                 }
377:                 
378:                 void i2c2_BusInterrupt()
379:                 {
380:                     return;
381:                 }
382:                 
383:                 #endif
384:                 
385:                 #ifdef I2C3_INIT
386:                 
387:                 void i2c3_MasterInterrupt()
388:                 {
389:                     I2CControl* ctl = i2cStruct[2];
390:                     
391:                     //Nevim proc, ale interrupt nastava drive, nez je TFB nulovan (novy zapis do I2C2TRN je mozny az po nulovani TFB)
392:                     //to same plati pro TRSTAT
393:                     while(I2C3STATbits.TRSTAT==1 || I2C3STATbits.TBF==1)
394:                     {
395:                         
396:                     }
397:                     
398:                     if(ctl->internalState == 0)
399:                     {
400:                         //SEN, start signal
401:                         I2C3_ENABLE_MASTER_INTERRUPT;
402:                         
403:                         if(I2C3STATbits.S==1)
404:                         {
405:                             //nyni by melo byt vzdy S=0
406:                             //nevim proc, ale nekdy po odeslani END nastane na sbernici START stav
407:                             //proto musi byt odeslano END
408:                             I2C3CONbits.PEN=1;
409:                             return;
410:                         }
411:                         else
412:                         {
413:                             I2C3CONbits.SEN=1;
414:                             ctl->internalState=1;
415:                             return;
416:                         }
417:                     }
418:                     else if(ctl->internalState == 1)
419:                     {
420:                         //Tx address byte (7-bit)
421:                         //char ad=ctl->address << 1;
422:                         I2C3TRN=(ctl->address << 1);           //b0=0, write
423:                         
424:                         ctl->internalState=2;
425:                         return;
426:                     }
427:                     else if(ctl->internalState == 2)
428:                     {
429:                         if(I2C3STATbits.ACKSTAT==1)
430:                         {
431:                             //chyba, slave odpovedel NACK
432:                             ctl->error=1;
433:                             I2C3CONbits.PEN=1;                  //PEN
434:                             ctl->internalState=3;
435:                             return;
436:                         }
437:                         if(ctl->internalState == ctl->len)
438:                         {
439:                             //konec, vse odeslano
440:                             I2C3CONbits.PEN=1;                  //PEN
441:                             ctl->internalState=3;
442:                             return;
443:                         }
444:                         
445:                         //dalsi byte
446:                         I2C3TRN=*ctl->tx_buffer;
447:                         ctl->tx_buffer++;  
448:                         return;
449:                     }
450:                     else if (ctl->internalState==3)
451:                     {
452:                         //after PEN, ukonceni prenosu
453:                         I2C3_DISABLE_MASTER_INTERRUPT;
454:                         
455:                         if(ctl->finishFn != NULL)
456:                         {
457:                             _finish=ctl->finishFn;
458:                             _finish(ctl->used);
459:                         }
460:                         return;
461:                     }    
462:                 }
463:                 
464:                 void i2c3_SlaveInterrupt()
465:                 {
466:                     return;
467:                 }
468:                 
469:                 void i2c3_BusInterrupt()
470:                 {
471:                     return;
472:                 }
473:                 
474:                 #endif
475:                 
476:                 #endif //(I2C)
---  d:/bos/bos/graphics_hl.c  --------------------------------------------------------------------------
1:                   //Graphics High Level - obsahuje graficke fce vyssi urovne
2:                   #include <xc.h>
3:                   #include <stdio.h>
4:                   #include <stdlib.h>
5:                   #include "graphics_hl.h"
6:                   #include "def.h"
7:                   #include "graphics.h"
8:                   
9:                   
10:                  
11:                  #ifdef DISP1306
12:                  //fce pro displej SSD1306
13:                  
14:                  void disp1306_drawHBar8(int index, int nop, int x, int y, int val)
15:                  {
9D013744      4FB0   ADDIU SP, SP, -8
9D013746      CBC1   SW S8, 4(SP)
9D013748      0FDD   MOVE S8, SP
9D01374A  F89E0008   SW A0, 8(S8)
9D01374E  F8BE000C   SW A1, 12(S8)
9D013752  F8DE0010   SW A2, 16(S8)
9D013756  F8FE0014   SW A3, 20(S8)
16:                      //nop = pocet pozic ukazatele (std=20), nepocita prvni a posledni image [ a ]
17:                      //val = pocet aktivnich pozic
18:                      //width=(nop+2) x 4 (std=88px)
19:                      
20:                  #define     BAR_ITEM_WIDTH      4
21:                      /*
22:                      char* left=displayGetImageData(index, 1);
23:                      char* mid_empty=displayGetImageData(index, 2);
24:                      char* mid_full=displayGetImageData(index, 3);
25:                      char* right=displayGetImageData(index, 4);
26:                      
27:                      //char page=y/8;
28:                      
29:                      //vynaze prostor uvnitr
30:                      //fillRect(index, x, y, x+7+(nop*BAR_ITEM_WIDTH), y, 0x0);
31:                      
32:                      int a;
33:                      char* img;
34:                      
35:                      for(a=0; a<(nop+2); a++)
36:                      {
37:                          
38:                          if(a==0){img=left;}                 //prvni
39:                          else if(a==nop+1){img=right;}       //posledni
40:                          else
41:                          {
42:                              if(val>=a){img=mid_full;}       //obsah plny
43:                              else {img=mid_empty;}           //obsah prazdny
44:                          }
45:                          
46:                          drawImage(index, img, x, y);
47:                          x+=BAR_ITEM_WIDTH;
48:                      }
49:                      */
50:                  }
9D01375A      0FBE   MOVE SP, S8
9D01375C      4BC1   LW S8, 4(SP)
9D01375E      4C05   ADDIU SP, SP, 8
9D013760      45BF   JRC RA
9D013762      0C00   NOP
51:                  
52:                  void disp1306_drawHBar16(int index, int nop, int x, int y, int val)
53:                  {
9D013764      4FB0   ADDIU SP, SP, -8
9D013766      CBC1   SW S8, 4(SP)
9D013768      0FDD   MOVE S8, SP
9D01376A  F89E0008   SW A0, 8(S8)
9D01376E  F8BE000C   SW A1, 12(S8)
9D013772  F8DE0010   SW A2, 16(S8)
9D013776  F8FE0014   SW A3, 20(S8)
54:                      //nop = pocet pozic ukazatele (std=20), nepocita prvni a posledni image
55:                      //val = pocet aktivnich pozic
56:                      //width=(nop+2) x 4 (std=88px)
57:                      
58:                  #define     BAR_ITEM_WIDTH      4
59:                      
60:                      /*
61:                        
62:                      char* left=displayGetImageData(index, 6);
63:                      char* mid_empty=displayGetImageData(index, 7);
64:                      char* mid_full=displayGetImageData(index, 8);
65:                      char* right=displayGetImageData(index, 9);
66:                      
67:                      //vynaze prostor uvnitr
68:                      //fillRect(index, x, y, x+7+(nop*BAR_ITEM_WIDTH), y+15, 0x0);
69:                      
70:                      
71:                      int a;
72:                      char* img;
73:                      
74:                      for(a=0; a<(nop+2); a++)
75:                      {
76:                          
77:                          if(a==0){img=left;}                 //prvni (levy kraj)
78:                          else if(a==nop+1){img=right;}       //posledni (pravy kraj)
79:                          else
80:                          {
81:                              if(val>=a){img=mid_full;}       //obsah, plny
82:                              else {img=mid_empty;}           //obsah, prazdny
83:                          }
84:                          
85:                          drawImage(index, img, x, y);
86:                          x+=BAR_ITEM_WIDTH;
87:                      }
88:                      
89:                      */
90:                  }
9D01377A      0FBE   MOVE SP, S8
9D01377C      4BC1   LW S8, 4(SP)
9D01377E      4C05   ADDIU SP, SP, 8
9D013780      45BF   JRC RA
9D013782      0C00   NOP
91:                  
92:                  void disp1306_drawBattery(int index, int x, int y, int state)
93:                  {
9D013784      4FB0   ADDIU SP, SP, -8
9D013786      CBC1   SW S8, 4(SP)
9D013788      0FDD   MOVE S8, SP
9D01378A  F89E0008   SW A0, 8(S8)
9D01378E  F8BE000C   SW A1, 12(S8)
9D013792  F8DE0010   SW A2, 16(S8)
9D013796  F8FE0014   SW A3, 20(S8)
94:                      //state 0-5 = charge (obsah 0-5 obdelniku)
95:                      //state  -1 = discharge (sipka)
96:                      
97:                      /*
98:                      
99:                      char* img=displayGetImageData(index, 10);       //battery
100:                     drawImage(index, img, x, y);
101:                     
102:                     //vynaze prostor uvnitr
103:                     fillRect(index, x+2, y+8, x+38, y+23, 0x0);
104:                     
105:                     
106:                     if(state==-1)
107:                     {
108:                         img=displayGetImageData(index, 12);         //sipka
109:                         drawImage(index, img, x+15, y+8);
110:                     }
111:                     if(state==0)
112:                     {
113:                         //prazdna 
114:                     }
115:                     else
116:                     {
117:                         if(state>5) { state=5; }
118:                         int akx=x+4;
119:                         img=displayGetImageData(index, 11);         //obdelnik
120:                         
121:                         while(state>0)
122:                         {
123:                             drawImage(index, img, akx, y+8);
124:                             state--;
125:                             akx+=7;
126:                         }
127:                     }
128:                     
129:                     */
130:                     
131:                     
132:                 }
9D01379A      0FBE   MOVE SP, S8
9D01379C      4BC1   LW S8, 4(SP)
9D01379E      4C05   ADDIU SP, SP, 8
9D0137A0      45BF   JRC RA
9D0137A2      0C00   NOP
133:                 
134:                 void disp1306_drawScale8(int index, int x, int y)
135:                 {
9D0137A4      4FB0   ADDIU SP, SP, -8
9D0137A6      CBC1   SW S8, 4(SP)
9D0137A8      0FDD   MOVE S8, SP
9D0137AA  F89E0008   SW A0, 8(S8)
9D0137AE  F8BE000C   SW A1, 12(S8)
9D0137B2  F8DE0010   SW A2, 16(S8)
136:                     /*
137:                     //x=0 (stupnice pres celou sirku displeje)
138:                     char* left=displayGetImageData(index, 15);              //levy kraj
139:                     char* mids=displayGetImageData(index, 16);              //stred maly
140:                     char* midb=displayGetImageData(index, 17);              //stred velky
141:                     char* right=displayGetImageData(index, 18);             //konec (prazdny obdelnik)
142:                     
143:                     //char* img;
144:                     drawImage(index, left, 0, y);
145:                     
146:                     drawImage(index, mids, 4, y);
147:                     drawImage(index, mids, 10, y);
148:                     drawImage(index, mids, 16, y);
149:                     drawImage(index, mids, 22, y);
150:                     drawImage(index, midb, 28, y);
151:                     
152:                     drawImage(index, mids, 34, y);
153:                     drawImage(index, mids, 40, y);
154:                     drawImage(index, mids, 46, y);
155:                     drawImage(index, mids, 52, y);
156:                     drawImage(index, midb, 58, y);
157:                 
158:                     drawImage(index, mids, 64, y);
159:                     drawImage(index, mids, 70, y);
160:                     drawImage(index, mids, 76, y);
161:                     drawImage(index, mids, 82, y);
162:                     drawImage(index, midb, 88, y);
163:                     
164:                     drawImage(index, mids, 94, y);
165:                     drawImage(index, mids, 100, y);
166:                     drawImage(index, mids, 106, y);
167:                     drawImage(index, mids, 112, y);
168:                     drawImage(index, midb, 118, y);    
169:                     
170:                     drawImage(index, right, 124, y);
171:                     
172:                     */
173:                   
174:                 }
9D0137B6      0FBE   MOVE SP, S8
175:                 
176:                 #endif
---  d:/bos/bos/graphics.c  -----------------------------------------------------------------------------
1:                   //Graphics obsahuje zakladni graficke fce, vola primo fce driveru
2:                   #include <xc.h>
3:                   #include <stdio.h>
4:                   #include <stdlib.h>
5:                   #include "globals.h"
6:                   #include "graphics.h"
7:                   
8:                   
9:                   #ifdef USE_GRAPHICS
10:                  
11:                  static DISPLAY* disp;
12:                  static PORT_INFO* pinfo;
13:                  
14:                  static void drawCircle(short x, short y, short r, short color);
15:                  static void drawBox(short x1, short y1, short x2, short y2, short w, short color);
16:                  //static void print(char* text);
17:                  
18:                  //void (*_drv)(DISPLAY*);
19:                      //_drv=drv;
20:                      //_drv(&g->display);
21:                      //g->display.selectPort(pi);
22:                      //g->initDisplay=g->display.initDisplay;
23:                  
24:                  void setGraphics(GRAPHICS* g,  DISPLAY* d, PORT_INFO* pi)
25:                  {
9D01307C      4FF5   ADDIU SP, SP, -24
9D01307E      CBE5   SW RA, 20(SP)
9D013080      CBC4   SW S8, 16(SP)
9D013082      0FDD   MOVE S8, SP
9D013084  F89E0018   SW A0, 24(S8)
9D013088  F8BE001C   SW A1, 28(S8)
9D01308C  F8DE0020   SW A2, 32(S8)
26:                      
27:                      disp=d;
9D013090  FC5E001C   LW V0, 28(S8)
9D013094  F85C8074   SW V0, -32652(GP)
28:                      pinfo=pi;
9D013098  FC5E0020   LW V0, 32(S8)
9D01309C  F85C8078   SW V0, -32648(GP)
29:                      
30:                      d->selectPort(pinfo, disp);
9D0130A0  FC5E001C   LW V0, 28(S8)
9D0130A2  001C6920   ADD T5, GP, ZERO
9D0130A4      6920   LW V0, 0(V0)
9D0130A6  FC9C8078   LW A0, -32648(GP)
9D0130AA  FC7C8074   LW V1, -32652(GP)
9D0130AE      0CA3   MOVE A1, V1
9D0130B0      45E2   JALRS16 V0
9D0130B2      0C00   NOP
31:                      
32:                      //fce graphics
33:                      g->drawCircle=&drawCircle;
9D0130B4  FC5E0018   LW V0, 24(S8)
9D0130B8  41A39D01   LUI V1, 0x9D01
9D0130BA  9D013063   LWC1 F8, 12387(AT)
9D0130BC  3063313D   ADDIU V1, V1, 12605
9D0130BE  313DE9A0   ADDIU T1, SP, -5728
9D0130C0      E9A0   SW V1, 0(V0)
34:                      g->drawBox=&drawBox;
9D0130C2  FC5E0018   LW V0, 24(S8)
9D0130C6  41A39D01   LUI V1, 0x9D01
9D0130C8  9D013063   LWC1 F8, 12387(AT)
9D0130CA  30633165   ADDIU V1, V1, 12645
9D0130CC  3165E9A1   ADDIU T3, A1, -5727
9D0130CE      E9A1   SW V1, 4(V0)
35:                      //g->print=&print;
36:                      
37:                      //fce driveru
38:                      g->drawString=d->drawString;
9D0130D0  FC5E001C   LW V0, 28(S8)
9D0130D4      69A2   LW V1, 8(V0)
9D0130D6  FC5E0018   LW V0, 24(S8)
9D0130DA      E9A2   SW V1, 8(V0)
39:                      g->fillBox=d->fillBox;
9D0130DC  FC5E001C   LW V0, 28(S8)
9D0130E0      69A3   LW V1, 12(V0)
9D0130E2  FC5E0018   LW V0, 24(S8)
9D0130E6      E9A3   SW V1, 12(V0)
40:                      g->drawLine=d->drawLine;
9D0130E8  FC5E001C   LW V0, 28(S8)
9D0130EC      69A4   LW V1, 16(V0)
9D0130EE  FC5E0018   LW V0, 24(S8)
9D0130F2      E9A4   SW V1, 16(V0)
41:                      g->drawImage=d->drawImage;
9D0130F4  FC5E001C   LW V0, 28(S8)
9D0130F6  001C69A5   LWX T5, ZERO(GP)
9D0130F8      69A5   LW V1, 20(V0)
9D0130FA  FC5E0018   LW V0, 24(S8)
9D0130FC  0018E9A5   LWX SP, ZERO(T8)
9D0130FE      E9A5   SW V1, 20(V0)
42:                      g->drawPoint=d->drawPoint;
9D013100  FC5E001C   LW V0, 28(S8)
9D013104      69A6   LW V1, 24(V0)
9D013106  FC5E0018   LW V0, 24(S8)
9D01310A      E9A6   SW V1, 24(V0)
43:                      g->print=d->print;
9D01310C  FC5E001C   LW V0, 28(S8)
9D01310E  001C69A7   BREAK
9D013110      69A7   LW V1, 28(V0)
9D013112  FC5E0018   LW V0, 24(S8)
9D013114  0018E9A7   BREAK
9D013116      E9A7   SW V1, 28(V0)
44:                      
45:                      g->clear=d->clear;
9D013118  FC5E001C   LW V0, 28(S8)
9D01311C      69A8   LW V1, 32(V0)
9D01311E  FC5E0018   LW V0, 24(S8)
9D013122      E9A8   SW V1, 32(V0)
46:                      g->textWidth=d->textWidth;
9D013124  FC5E001C   LW V0, 28(S8)
9D013126  001C69AC   EXT ZERO, GP, 6, 14
9D013128      69AC   LW V1, 48(V0)
9D01312A  FC5E0018   LW V0, 24(S8)
9D01312E      E9A9   SW V1, 36(V0)
47:                  }
9D013130      0FBE   MOVE SP, S8
9D013132      4BE5   LW RA, 20(SP)
9D013134      4BC4   LW S8, 16(SP)
9D013136      4C0D   ADDIU SP, SP, 24
9D013138      45BF   JRC RA
9D01313A      0C00   NOP
48:                  
49:                  static void drawCircle(short x, short y, short r, short color)
50:                  {
9D01313C      4FB0   ADDIU SP, SP, -8
9D01313E      CBC1   SW S8, 4(SP)
9D013140      0FDD   MOVE S8, SP
9D013142      0D04   MOVE T0, A0
9D013144      0C85   MOVE A0, A1
9D013146      0C66   MOVE V1, A2
9D013148      0C47   MOVE V0, A3
9D01314A  391E0008   SH T0, 8(S8)
9D01314E  389E000C   SH A0, 12(S8)
9D013152  387E0010   SH V1, 16(S8)
9D013156  385E0014   SH V0, 20(S8)
51:                      //disp->draw...
52:                      //disp->fillBox(x, y, x+200, y+100, RGB16(31,63,31));
53:                      //disp->drawLine(x, y, x+200, y+100, 1, RGB16(0,63,0));
54:                      //disp->drawLine(x, y+100, x+200, y, 1, RGB16(0,63,0));
55:                      
56:                      
57:                  }
9D01315A      0FBE   MOVE SP, S8
9D01315C      4BC1   LW S8, 4(SP)
9D01315E      4C05   ADDIU SP, SP, 8
9D013160      45BF   JRC RA
9D013162      0C00   NOP
58:                  
59:                  static void drawBox(short x1, short y1, short x2, short y2, short w, short color)
60:                  {
9D013164      4FF1   ADDIU SP, SP, -32
9D013166      CBE7   SW RA, 28(SP)
9D013168      CBC6   SW S8, 24(SP)
9D01316A      0FDD   MOVE S8, SP
9D01316C      0D04   MOVE T0, A0
9D01316E      0C85   MOVE A0, A1
9D013170      0C66   MOVE V1, A2
9D013172      0C47   MOVE V0, A3
9D013174  391E0020   SH T0, 32(S8)
9D013178  389E0024   SH A0, 36(S8)
9D01317C  387E0028   SH V1, 40(S8)
9D013180  385E002C   SH V0, 44(S8)
61:                      disp->drawLine(x1, y1, x2, y1, w, color);
9D013184  FC5C8074   LW V0, -32652(GP)
9D013188      6924   LW V0, 16(V0)
9D01318A  3C9E0020   LH A0, 32(S8)
9D01318E  3CBE0024   LH A1, 36(S8)
9D013192  3CDE0028   LH A2, 40(S8)
9D013196  3C7E0024   LH V1, 36(S8)
9D01319A  3CFE0030   LH A3, 48(S8)
9D01319E      C8E4   SW A3, 16(SP)
9D0131A0  3CFE0034   LH A3, 52(S8)
9D0131A4      C8E5   SW A3, 20(SP)
9D0131A6      0CE3   MOVE A3, V1
9D0131A8      45E2   JALRS16 V0
9D0131AA      0C00   NOP
62:                      disp->drawLine(x2, y1, x2, y2, w, color);
9D0131AC  FC5C8074   LW V0, -32652(GP)
9D0131B0      6924   LW V0, 16(V0)
9D0131B2  3C9E0028   LH A0, 40(S8)
9D0131B6  3CBE0024   LH A1, 36(S8)
9D0131BA  3CDE0028   LH A2, 40(S8)
9D0131BE  3C7E002C   LH V1, 44(S8)
9D0131C2  3CFE0030   LH A3, 48(S8)
9D0131C6      C8E4   SW A3, 16(SP)
9D0131C8  3CFE0034   LH A3, 52(S8)
9D0131CC      C8E5   SW A3, 20(SP)
9D0131CE      0CE3   MOVE A3, V1
9D0131D0      45E2   JALRS16 V0
9D0131D2      0C00   NOP
63:                      disp->drawLine(x2, y2, x1, y2, w, color);
9D0131D4  FC5C8074   LW V0, -32652(GP)
9D0131D8      6924   LW V0, 16(V0)
9D0131DA  3C9E0028   LH A0, 40(S8)
9D0131DE  3CBE002C   LH A1, 44(S8)
9D0131E2  3CDE0020   LH A2, 32(S8)
9D0131E6  3C7E002C   LH V1, 44(S8)
9D0131EA  3CFE0030   LH A3, 48(S8)
9D0131EE      C8E4   SW A3, 16(SP)
9D0131F0  3CFE0034   LH A3, 52(S8)
9D0131F4      C8E5   SW A3, 20(SP)
9D0131F6      0CE3   MOVE A3, V1
9D0131F8      45E2   JALRS16 V0
9D0131FA      0C00   NOP
64:                      disp->drawLine(x1, y2, x1, y1, w, color);    
9D0131FC  FC5C8074   LW V0, -32652(GP)
9D013200      6924   LW V0, 16(V0)
9D013202  3C9E0020   LH A0, 32(S8)
9D013206  3CBE002C   LH A1, 44(S8)
9D01320A  3CDE0020   LH A2, 32(S8)
9D01320E  3C7E0024   LH V1, 36(S8)
9D013212  3CFE0030   LH A3, 48(S8)
9D013216      C8E4   SW A3, 16(SP)
9D013218  3CFE0034   LH A3, 52(S8)
9D01321C      C8E5   SW A3, 20(SP)
9D01321E      0CE3   MOVE A3, V1
9D013220      45E2   JALRS16 V0
9D013222      0C00   NOP
65:                      
66:                  }
9D013224      0FBE   MOVE SP, S8
67:                  
68:                  #endif
69:                  
70:                  
71:                  /*
72:                  //iface, zajisti volani spravne fce
73:                  //vola modul, ktery ovlada displej podle indexu displeje
74:                  
75:                  //definuje fce pro kazdy displayIndex [0-7]
76:                  //kazdy displej muze mit vlastni driver, tzn. ze mohou byt pouzity ruzne displeje soucasne 
77:                  void (*_drawText)(int, char*, int, int, int);
78:                  const void* func_drawText[]={     &disp1306a_drawText,      NULL, NULL, NULL, NULL, NULL, NULL, NULL };
79:                  
80:                  void (*_drawString)(int, char*, int, int, int);
81:                  const void* func_drawString[]={   &disp1306a_drawString,    NULL, NULL, NULL, NULL, NULL, NULL, NULL };
82:                  
83:                  void (*_print)(int, char*);
84:                  const void* func_print[]={        &disp1306a_print,         NULL, NULL, NULL, NULL, NULL, NULL, NULL};
85:                  
86:                  void (*_drawImage)(int, char*, int, int);
87:                  const void* func_drawImage[]={    &disp1306a_drawImage,     NULL, NULL, NULL, NULL, NULL, NULL, NULL };
88:                  
89:                  void (*_fillRect)(int, int, int, int, int, int);
90:                  const void* func_fillRect[]={     &disp1306a_fillRect,     NULL, NULL, NULL, NULL, NULL, NULL, NULL };
91:                  
92:                  void (*_clear)(int);
93:                  const void* func_clear[]={        &disp1306a_clear,         NULL, NULL, NULL, NULL, NULL, NULL, NULL};
94:                  
95:                  void (*_setContrast)(int, int);
96:                  const void* func_setContrast[]={  &disp1306a_setContrast,   NULL, NULL, NULL, NULL, NULL, NULL, NULL};
97:                  
98:                  void (*_sleep)(int);
99:                  const void* func_sleep[]={        &disp1306a_sleep,         NULL, NULL, NULL, NULL, NULL, NULL, NULL};
100:                 
101:                 void (*_resume)(int);
102:                 const void* func_resume[]={       &disp1306a_resume,        NULL, NULL, NULL, NULL, NULL, NULL, NULL};
103:                 
104:                 int (*_getReady)(int);
105:                 const void* func_getReady[]={     &disp1306a_getReady,      NULL, NULL, NULL, NULL, NULL, NULL, NULL};
106:                 
107:                 char* (*_getImageData)(int);
108:                 const void* func_getImageData[]={ &disp1306a_getImageData,  NULL, NULL, NULL, NULL, NULL, NULL, NULL};
109:                 
110:                 int (*_getWidth)(int);
111:                 const void* func_getWidth[]={     &disp1306a_getWidth,      NULL, NULL, NULL, NULL, NULL, NULL, NULL};
112:                 
113:                 int (*_getHeight)(int);
114:                 const void* func_getHeight[]={    &disp1306a_getHeight,      NULL, NULL, NULL, NULL, NULL, NULL, NULL};
115:                 
116:                 
117:                 void drawText(int index, char* string, int col, int row, int font)
118:                 {
119:                     //vypis v txt rezimu (sloupec, radek)
120:                     _drawText=func_drawText[index];
121:                     _drawText(index, string, col, row, font);
122:                 }
123:                 
124:                 void drawString(int index, char* string, int x, int y, int font)
125:                 {
126:                     //vypis na zadanou pozici x, y
127:                     _drawString=func_drawString[index];
128:                     _drawString(index, string, x, y, font);    
129:                 }
130:                 
131:                 void printString(int index, char* string)
132:                 {
133:                     //vypis na dalsi radek (console)
134:                     _print=func_print[index];
135:                     _print(index, string);
136:                 }
137:                 
138:                 void drawImage(int index, char* img, int x, int y)
139:                 {
140:                     //kresli image na pozici x, y
141:                     _drawImage=func_drawImage[index];
142:                     _drawImage(index, img, x, y);    
143:                 }
144:                 
145:                 void fillRect(int index, int x1, int y1, int x2, int y2, int color)
146:                 {
147:                     //vyplni zadany obdelnik barvou color
148:                     _fillRect=func_fillRect[index];
149:                     _fillRect(index, x1, y1, x2, y2, color);
150:                 }
151:                 
152:                 void displayClear(int index)
153:                 {
154:                     //vymaze cely displej
155:                     _clear=func_clear[index];
156:                     _clear(index);
157:                 }
158:                 
159:                 void displaySetContrast(int index, int val)
160:                 {
161:                     _setContrast=func_setContrast[index];
162:                     _setContrast(index, val);
163:                 }
164:                 
165:                 void displaySleep(int index)
166:                 {
167:                     _sleep=func_sleep[index];
168:                     _sleep(index);
169:                 }
170:                 
171:                 void displayResume(int index)
172:                 {
173:                     _resume=func_resume[index];
174:                     _resume(index);
175:                 }
176:                 
177:                 int displayGetReady(int index)
178:                 {
179:                     _getReady=func_getReady[index];
180:                     _getReady(index);
181:                 }
182:                 
183:                 char* displayGetImageData(int index, int id)
184:                 {
185:                     _getImageData=func_getImageData[index];
186:                     _getImageData(id);
187:                 }
188:                 
189:                 int displayGetWidth(int index)
190:                 {
191:                     _getWidth=func_getWidth[index];
192:                     _getWidth(index);
193:                 }
194:                 
195:                 int displayGetHeight(int index)
196:                 {
197:                     _getHeight=func_getHeight[index];
198:                     _getHeight(index);
199:                 }
200:                 
201:                 */
---  d:/bos/bos/globals.c  ------------------------------------------------------------------------------
1:                   #include <xc.h>
2:                   #include <stdio.h>
3:                   #include <stdlib.h>
4:                   #include "globals.h"
5:                   
6:                   #ifdef USE_SYSTEMFONT_ARIAL 
7:                       #include "font_arial.h"
8:                       IMAGE_SRC fontSys;
9:                   #endif
10:                      
11:                  #ifdef USE_SYSTEMFONT_FIXEDx
12:                      #include "font_fixed1306.h"
13:                      IMAGE_SRC fontSys;
14:                  #endif    
15:                  
16:                  #ifdef USE_GRAPHICS
17:                  //global vars
18:                  GRAPHICS graphics;
19:                  DISPLAY dispSys;
20:                  PORT_INFO pinfo_dispSys;
21:                  
22:                  //local fce
23:                  static void initDispSys();
24:                  
25:                  static void initDispSys()
26:                  {
9D013230      4FF5   ADDIU SP, SP, -24
9D013232      CBE5   SW RA, 20(SP)
9D013234      CBC4   SW S8, 16(SP)
9D013236      0FDD   MOVE S8, SP
27:                      //Inicializuje systemovy display
28:                      
29:                      //definuje jinou colorMap (system obsahuje std colorMap (B/W), ktera se automaticky nastavi v IMAGE_SRC fci setFontSrc/setImageSrc)
30:                      //loadColorMap(cmap);
31:                  
32:                      //nastaveni konkretniho displeje (ili9341/SPI)
33:                      
34:                  #ifdef SYSDISPLAY_9341SPI    
35:                      //<editor-fold defaultstate="collapsed" desc="PortWriter, pin set, driver">
36:                      //pin configuration C2=CS, C1=RESET, C0=DC
37:                      pinfo_dispSys.cs_portBase = PORTC_BASE;             //CS
38:                      pinfo_dispSys.cs_pin = BIT2;
39:                      pinfo_dispSys.reset_portBase = PORTC_BASE;          //RESET
40:                      pinfo_dispSys.reset_pin = BIT1;
41:                      pinfo_dispSys.dc_portBase = PORTC_BASE;             //DC
42:                      pinfo_dispSys.dc_pin = BIT0;
43:                      pinfo_dispSys.busMode = BUS_MODE._8bit;             //8-bit mode
44:                      pinfo_dispSys.directMode = 1;                       //direct mode
45:                  
46:                      //v pinfo_dispSys nastavi fce pro vysilani dat na pozadovany port SPI, PMP, ...
47:                      portWriter_init(&pinfo_dispSys, PERIPH_TYPE.spi, 1); //SPI[1]=SPI2
48:                      
49:                      //v dispSys nastavi fce driveru disp9341 
50:                      disp9341_driver(&dispSys);                    
51:                      // </editor-fold>
52:                  #endif
53:                      
54:                  #ifdef SYSDISPLAY_1306SPI
55:                      //<editor-fold defaultstate="collapsed" desc="PortWriter, pin set, driver">
56:                      //pin configuration C2=CS, C1=RESET, C0=DC
57:                      pinfo_dispSys.cs_portBase = PORTC_BASE;             //CS
9D013238  41A28000   LUI V0, 0x8000
9D01323C  30420730   ADDIU V0, V0, 1840
9D01323E      0730   ADDU A2, S0, V1
9D013240  41A3BF80   LUI V1, 0xBF80
9D013242  BF805063   LDC1 F28, 20579(ZERO)
9D013244  50632DB0   ORI V1, V1, 11696
9D013246      2DB0   ANDI V1, V1, 0x80
9D013248      E9A9   SW V1, 36(V0)
58:                      pinfo_dispSys.cs_pin = BIT2;
9D01324A  41A28000   LUI V0, 0x8000
9D01324E  30420730   ADDIU V0, V0, 1840
9D013250      0730   ADDU A2, S0, V1
9D013252      ED84   LI V1, 4
9D013254      E9AA   SW V1, 40(V0)
59:                      pinfo_dispSys.reset_portBase = PORTC_BASE;          //RESET
9D013256  41A28000   LUI V0, 0x8000
9D01325A  30420730   ADDIU V0, V0, 1840
9D01325C      0730   ADDU A2, S0, V1
9D01325E  41A3BF80   LUI V1, 0xBF80
9D013260  BF805063   LDC1 F28, 20579(ZERO)
9D013262  50632DB0   ORI V1, V1, 11696
9D013264      2DB0   ANDI V1, V1, 0x80
9D013266      E9AB   SW V1, 44(V0)
60:                      pinfo_dispSys.reset_pin = BIT1;
9D013268  41A28000   LUI V0, 0x8000
9D01326C  30420730   ADDIU V0, V0, 1840
9D01326E      0730   ADDU A2, S0, V1
9D013270      ED82   LI V1, 2
9D013272      E9AC   SW V1, 48(V0)
61:                      pinfo_dispSys.dc_portBase = PORTC_BASE;             //DC
9D013274  41A28000   LUI V0, 0x8000
9D013278  30420730   ADDIU V0, V0, 1840
9D01327A      0730   ADDU A2, S0, V1
9D01327C  41A3BF80   LUI V1, 0xBF80
9D01327E  BF805063   LDC1 F28, 20579(ZERO)
9D013280  50632DB0   ORI V1, V1, 11696
9D013282      2DB0   ANDI V1, V1, 0x80
9D013284      E9AD   SW V1, 52(V0)
62:                      pinfo_dispSys.dc_pin = BIT0;
9D013286  41A28000   LUI V0, 0x8000
9D01328A  30420730   ADDIU V0, V0, 1840
9D01328C      0730   ADDU A2, S0, V1
9D01328E      ED81   LI V1, 1
9D013290      E9AE   SW V1, 56(V0)
63:                      pinfo_dispSys.busMode = BUS_MODE._8bit;             //8-bit mode
9D013292      0C60   MOVE V1, ZERO
9D013294  41A28000   LUI V0, 0x8000
9D013298  30420730   ADDIU V0, V0, 1840
9D01329A      0730   ADDU A2, S0, V1
9D01329C  1862003E   SB V1, 62(V0)
64:                      pinfo_dispSys.directMode = 1;                       //direct mode
9D0132A0  41A28000   LUI V0, 0x8000
9D0132A4  30420730   ADDIU V0, V0, 1840
9D0132A6      0730   ADDU A2, S0, V1
9D0132A8      ED81   LI V1, 1
9D0132AA  1862003D   SB V1, 61(V0)
9D0132AC  003D0C40   SRL AT, SP, 1
65:                  
66:                      //v pinfo_dispSys nastavi fce pro vysilani dat na pozadovany port SPI, PMP, ...
67:                      portWriter_init(&pinfo_dispSys, PERIPH_TYPE.spi, 1); //SPI[1]=SPI2
9D0132AE      0C40   MOVE V0, ZERO
9D0132B0  41A38000   LUI V1, 0x8000
9D0132B4  30830730   ADDIU A0, V1, 1840
9D0132B6      0730   ADDU A2, S0, V1
9D0132B8      0CA2   MOVE A1, V0
9D0132BA      EF01   LI A2, 1
9D0132BC  76809262   JALS portWriter_init
9D0132BE  92620C00   SLTI S3, V0, 3072
9D0132C0      0C00   NOP
68:                      
69:                      //v dispSys nastavi fce driveru disp9341 
70:                      disp1306_driver(&dispSys);                    
9D0132C2  41A28000   LUI V0, 0x8000
9D0132C6  308206E8   ADDIU A0, V0, 1768
9D0132C8      06E8   ADDU A1, A0, A2
9D0132CA  76805F6C   JALS disp1306_driver
9D0132CE      0C00   NOP
71:                      // </editor-fold>
72:                  #endif    
73:                      
74:                      //pro vsechny typy displeju
75:                      
76:                      // <editor-fold defaultstate="collapsed" desc="init displeje, aktivuje Graphics, init font">
77:                      //inicializuje display
78:                      dispSys.initDisplay(&pinfo_dispSys);            
9D0132D0  41A28000   LUI V0, 0x8000
9D0132D4  304206E8   ADDIU V0, V0, 1768
9D0132D6      06E8   ADDU A1, A0, A2
9D0132D8      6921   LW V0, 4(V0)
9D0132DA  41A38000   LUI V1, 0x8000
9D0132DE  30830730   ADDIU A0, V1, 1840
9D0132E0      0730   ADDU A2, S0, V1
9D0132E2      45E2   JALRS16 V0
9D0132E4      0C00   NOP
79:                      
80:                      //nastavi fce Graphics na strukturu dispSys, vystup Graphics jde na dispSys
81:                      setGraphics(&graphics, &dispSys, &pinfo_dispSys); 
9D0132E6  41A28000   LUI V0, 0x8000
9D0132EA  308206C0   ADDIU A0, V0, 1728
9D0132EC      06C0   ADDU A1, S0, A0
9D0132EE  41A28000   LUI V0, 0x8000
9D0132F2  30A206E8   ADDIU A1, V0, 1768
9D0132F4      06E8   ADDU A1, A0, A2
9D0132F6  41A28000   LUI V0, 0x8000
9D0132FA  30C20730   ADDIU A2, V0, 1840
9D0132FC      0730   ADDU A2, S0, V1
9D0132FE  7680983E   JALS setGraphics
9D013300  983E0C00   SWC1 F1, 3072(S8)
9D013302      0C00   NOP
82:                      
83:                      //init system font (pouziva font_sys v souboru font_sys.h)
84:                  #ifdef USE_SYSTEMFONT_ARIAL     
85:                      setFontSrc(&font_arial18, &fontSys);
86:                      fontSys.foreColor=RGB16(0, 63, 0);
87:                  #endif    
88:                      
89:                  #ifdef USE_SYSTEMFONT_FIXEDx
90:                      setFontSrc(&font_fixed16x, &fontSys);
9D013304  41A29D00   LUI V0, 0x9D00
9D013306  9D003082   LWC1 F8, 12418(ZERO)
9D013308  30820580   ADDIU A0, V0, 1408
9D01330A      0580   ADDU V1, S0, S0
9D01330C  41A28000   LUI V0, 0x8000
9D013310  30A207B8   ADDIU A1, V0, 1976
9D013312      07B8   ADDU A3, A0, V1
9D013314  768077C2   JALS setFontSrc
9D013316  77C20C00   JALS 0x9F841800
9D013318      0C00   NOP
91:                      fontSys.foreColor=RGB16(31, 63, 31);
9D01331A      EE1F   LI A0, 31
9D01331C      EEBF   LI A1, 63
9D01331E      EF1F   LI A2, 31
9D013320  768078E2   JALS RGB16
9D013322  78E20C00   ADDIUPC AT, 25702400
9D013324      0C00   NOP
9D013326  00623B3C   SEH V1, V0
9D013328  3B3C41A2   SH T9, 16802(GP)
9D01332A  41A28000   LUI V0, 0x8000
9D01332E  304207B8   ADDIU V0, V0, 1976
9D013330      07B8   ADDU A3, A0, V1
9D013332  38620030   SH V1, 48(V0)
92:                  #endif    
93:                      // </editor-fold>
94:                  
95:                      //cls
96:                      graphics.clear(COLOR.Black);    
9D013336  41A28000   LUI V0, 0x8000
9D01333A  304206C0   ADDIU V0, V0, 1728
9D01333C      06C0   ADDU A1, S0, A0
9D01333E      6928   LW V0, 32(V0)
9D013340      0C60   MOVE V1, ZERO
9D013342      0C83   MOVE A0, V1
9D013344      45E2   JALRS16 V0
9D013346      0C00   NOP
97:                  }
9D013348      0FBE   MOVE SP, S8
9D01334A      4BE5   LW RA, 20(SP)
9D01334C      4BC4   LW S8, 16(SP)
9D01334E      4C0D   ADDIU SP, SP, 24
9D013350      45BF   JRC RA
9D013352      0C00   NOP
98:                  
99:                  #endif
100:                 
101:                 #ifdef USE_TOUCHPAD
102:                 //global vars
103:                 PORT_INFO pInfo_touchSys;
104:                 
105:                 //local fce
106:                 static void initTouchSys();
107:                 
108:                 static void initTouchSys()
109:                 {
9D013354      4FF5   ADDIU SP, SP, -24
9D013356      CBE5   SW RA, 20(SP)
9D013358      CBC4   SW S8, 16(SP)
9D01335A      0FDD   MOVE S8, SP
110:                     //CS=RA3, pin 8
111:                     pInfo_touchSys.cs_portBase = PORTA_BASE;                    //CS
9D01335C  41A28000   LUI V0, 0x8000
9D013360  30420774   ADDIU V0, V0, 1908
9D013362      0774   ADDU A2, V0, A3
9D013364  41A3BF80   LUI V1, 0xBF80
9D013366  BF805063   LDC1 F28, 20579(ZERO)
9D013368  50632BB0   ORI V1, V1, 11184
9D01336A      2BB0   LHU A3, 0(V1)
9D01336C      E9A9   SW V1, 36(V0)
112:                     pInfo_touchSys.cs_pin = BIT3;
9D01336E  41A28000   LUI V0, 0x8000
9D013372  30420774   ADDIU V0, V0, 1908
9D013374      0774   ADDU A2, V0, A3
9D013376      ED88   LI V1, 8
9D013378      E9AA   SW V1, 40(V0)
113:                     pInfo_touchSys.busMode = BUS_MODE._8bit;                    //8-bit mode
9D01337A      0C60   MOVE V1, ZERO
9D01337C  41A28000   LUI V0, 0x8000
9D013380  30420774   ADDIU V0, V0, 1908
9D013382      0774   ADDU A2, V0, A3
9D013384  1862003E   SB V1, 62(V0)
9D013386  003E0C40   SRL AT, S8, 1
114:                     portWriter_init(&pInfo_touchSys, PERIPH_TYPE.spi, 1);       //pinfo obsahuje fce pro vysilani dat na pozadovany port SPI, PMP, ...
9D013388      0C40   MOVE V0, ZERO
9D01338A  41A38000   LUI V1, 0x8000
9D01338E  30830774   ADDIU A0, V1, 1908
9D013390      0774   ADDU A2, V0, A3
9D013392      0CA2   MOVE A1, V0
9D013394      EF01   LI A2, 1
9D013396  76809262   JALS portWriter_init
9D013398  92620C00   SLTI S3, V0, 3072
9D01339A      0C00   NOP
115:                 }
9D01339C      0FBE   MOVE SP, S8
9D01339E      4BE5   LW RA, 20(SP)
9D0133A0      4BC4   LW S8, 16(SP)
9D0133A2      4C0D   ADDIU SP, SP, 24
9D0133A4      45BF   JRC RA
9D0133A6      0C00   NOP
116:                 
117:                 #endif
118:                 
119:                 void globalsBeforeProcess()
120:                 {
9D0133A8      4FF5   ADDIU SP, SP, -24
9D0133AA      CBE5   SW RA, 20(SP)
9D0133AC      CBC4   SW S8, 16(SP)
9D0133AE      0FDD   MOVE S8, SP
121:                     //tato fce se vola jako inicializace systemu, tesne pred prvnim spustenim (registraci) procesu
122:                     
123:                 #ifdef USE_GRAPHICS    
124:                     initDispSys();
9D0133B0  76809918   JALS initDispSys
9D0133B2  99180C00   SWC1 F8, 3072(T8)
9D0133B4      0C00   NOP
125:                 #endif    
126:                     
127:                 #ifdef USE_TOUCHPAD     
128:                     initTouchSys();
9D0133B6  768099AA   JALS initTouchSys
9D0133B8  99AA0C00   SWC1 F13, 3072(T2)
9D0133BA      0C00   NOP
129:                 #endif
130:                     
131:                 }
9D0133BC      0FBE   MOVE SP, S8
9D0133BE      4BE5   LW RA, 20(SP)
9D0133C0      4BC4   LW S8, 16(SP)
9D0133C2      4C0D   ADDIU SP, SP, 24
9D0133C4      45BF   JRC RA
9D0133C6      0C00   NOP
132:                 
133:                 void globalsAfterProcess()
134:                 {
9D0133C8      4FB0   ADDIU SP, SP, -8
9D0133CA      CBC1   SW S8, 4(SP)
9D0133CC      0FDD   MOVE S8, SP
135:                     //tato fce se vola jako inicializace systemu, tesne po registraci vsech procesu, ale pred prvnim spustenim procesu
136:                 }
9D0133CE      0FBE   MOVE SP, S8
---  d:/bos/bos/fnc.c  ----------------------------------------------------------------------------------
1:                   #include <xc.h>
2:                   #include <stdio.h>
3:                   #include <stdarg.h>
4:                   #include <stdlib.h>
5:                   #include "fnc.h"
6:                   #include "asm.h"
7:                   #include "def.h"
8:                   #include "graphics.h"
9:                   
10:                  void pauseEvent2(int ms)
11:                  {
9D010784      4FF1   ADDIU SP, SP, -32
9D010786      CBE7   SW RA, 28(SP)
9D010788      CBC6   SW S8, 24(SP)
9D01078A      0FDD   MOVE S8, SP
9D01078C  F89E0020   SW A0, 32(S8)
12:                      int a;
13:                      ms/=10;
9D010790  FC5E0020   LW V0, 32(S8)
9D010794  41A36666   LUI V1, 0x6666
9D010796      6666   LW A0, -104(GP)
9D010798  50636667   ORI V1, V1, 26215
9D01079A      6667   LW A0, -100(GP)
9D01079C  00628B3C   MULT V0, V1
9D01079E      8B3C   SB A2, 12(V1)
9D0107A0      4603   MFHI V1
9D0107A2  00631080   SRA V1, V1, 2
9D0107A4  10800042   ADDI A0, ZERO, 66
9D0107A6  0042F880   SRA V0, V0, 31
9D0107A8  F8800527   SW A0, 1319(ZERO)
9D0107AA      0527   SUBU V0, V1, V0
9D0107AC  F85E0020   SW V0, 32(S8)
14:                      
15:                      for(a=0; a<ms; a++)
9D0107B0  F81E0010   SW ZERO, 16(S8)
9D0107B4      CC09   B 0x9D0107C8
9D0107B6      0C00   NOP
9D0107BE  FC5E0010   LW V0, 16(S8)
9D0107C0  00106D20   ADD T5, S0, ZERO
9D0107C2      6D20   ADDIU V0, V0, 1
9D0107C4  F85E0010   SW V0, 16(S8)
9D0107C8  FC7E0010   LW V1, 16(S8)
9D0107CC  FC5E0020   LW V0, 32(S8)
9D0107D0  00431350   SLT V0, V1, V0
9D0107D2  135040A2   ADDI K0, S0, 16546
9D0107D4  40A2FFF0   BNEZC V0, 0x9D0107B8
9D0107D6  FFF00FBE   LW RA, 4030(S0)
16:                      {
17:                          doEvents();
9D0107B8  76807F8E   JALS doEvents
9D0107BC      0C00   NOP
18:                      }
19:                  }
9D0107D8      0FBE   MOVE SP, S8
9D0107DA      4BE7   LW RA, 28(SP)
9D0107DC      4BC6   LW S8, 24(SP)
9D0107DE      4C11   ADDIU SP, SP, 32
9D0107E0      45BF   JRC RA
9D0107E2      0C00   NOP
20:                  
21:                  int createString(char* buffer, int buffer_len, char* a, ...)
22:                  {
9D0107E4      4FF1   ADDIU SP, SP, -32
9D0107E6      CBE7   SW RA, 28(SP)
9D0107E8      CBC6   SW S8, 24(SP)
9D0107EA      0FDD   MOVE S8, SP
9D0107EC  F89E0020   SW A0, 32(S8)
9D0107F0  F8BE0024   SW A1, 36(S8)
9D0107F4  F8FE002C   SW A3, 44(S8)
9D0107F8  F8DE0028   SW A2, 40(S8)
23:                      //predpoklada, ze buffer je prazdny (presto na prvni pozici vlozi 0x0)
24:                      //do buferu vlozi (spoji) zadane stringy a[0] - a[x]
25:                      //kazdy string a[0]-a[x] musi byt zakonceny /0
26:                      //pokud celkova delka presahne buffer_len, bude zkraceno (posledni znak bude \0)
27:                      
28:                      int ret=0x1;
9D0107FC      ED01   LI V0, 1
9D0107FE  F85E0010   SW V0, 16(S8)
29:                      buffer[0]=0x0;                              //prazdny buffer
9D010802  FC5E0020   LW V0, 32(S8)
9D010806      8820   SB S0, 0(V0)
30:                      va_list argList;                            //seznam argumentu
31:                      va_start ( argList, a );                    //a
9D010808  305E002C   ADDIU V0, S8, 44
9D01080C  F85E0014   SW V0, 20(S8)
9D01080E  0014CC17   BREAK
32:                      
33:                      /*
34:                      for (;;) 
35:                      {
36:                          char* t = va_arg( argList, char* );
37:                          ret &= concat(buffer, t, buffer_len);
38:                          ret=1;
39:                          
40:                       //Do something with t 
41:                      }
42:                      */
43:                      
44:                      
45:                      while(a != NULL)
9D010810      CC17   B 0x9D010840
9D010812      0C00   NOP
9D010840  FC5E0028   LW V0, 40(S8)
9D010844  40A2FFE6   BNEZC V0, 0x9D010814
9D010846  FFE6FC5E   LW RA, -930(A2)
46:                      {
47:                          ret &= concat(buffer, a, buffer_len);
9D010814  FC9E0020   LW A0, 32(S8)
9D010818  FCBE0028   LW A1, 40(S8)
9D01081C  FCDE0024   LW A2, 36(S8)
9D01081E  00247680   OR T6, A0, AT
9D010820  76808031   JALS concat
9D010824      0C00   NOP
9D010826  FC7E0010   LW V1, 16(S8)
9D01082A      4493   AND16 V0, V1
9D01082C  F85E0010   SW V0, 16(S8)
48:                          a=va_arg ( argList, char* );            //a=dalsi argument (...)
9D010830  FC5E0014   LW V0, 20(S8)
9D010834      6DA2   ADDIU V1, V0, 4
9D010836  F87E0014   SW V1, 20(S8)
9D010838  00146920   ADD T5, S4, ZERO
9D01083A      6920   LW V0, 0(V0)
9D01083C  F85E0028   SW V0, 40(S8)
49:                      }
50:                      
51:                      va_end(argList);
52:                      
53:                      return ret;
9D010848  FC5E0010   LW V0, 16(S8)
54:                  }
9D01084C      0FBE   MOVE SP, S8
9D01084E      4BE7   LW RA, 28(SP)
9D010850      4BC6   LW S8, 24(SP)
9D010852      4C11   ADDIU SP, SP, 32
9D010854      45BF   JRC RA
9D010856      0C00   NOP
55:                  
56:                  void createStringStruct(stringCreator sc)
57:                  {
9D010858      4FF5   ADDIU SP, SP, -24
9D01085A      CBE5   SW RA, 20(SP)
9D01085C      CBC4   SW S8, 16(SP)
9D01085E      0FDD   MOVE S8, SP
9D010860  F89E0018   SW A0, 24(S8)
9D010864  F8BE001C   SW A1, 28(S8)
9D010868  F8DE0020   SW A2, 32(S8)
9D01086C  F8FE0024   SW A3, 36(S8)
58:                      sc.result[0]=0x0;
9D010870  FC5E0018   LW V0, 24(S8)
9D010874      8820   SB S0, 0(V0)
59:                      concat(sc.result, sc.s1, sc.len);
9D010876  FC9E0018   LW A0, 24(S8)
9D01087A  FC7E0020   LW V1, 32(S8)
9D01087E  FC5E001C   LW V0, 28(S8)
9D010882      0CA3   MOVE A1, V1
9D010884      0CC2   MOVE A2, V0
9D010886  76808031   JALS concat
9D01088A      0C00   NOP
60:                      if(sc.s2!=NULL){ concat(sc.result, sc.s2, sc.len); }
9D01088C  FC5E0024   LW V0, 36(S8)
9D010890  40E2000B   BEQZC V0, 0x9D0108AA
9D010894  FC9E0018   LW A0, 24(S8)
9D010898  FC7E0024   LW V1, 36(S8)
9D01089C  FC5E001C   LW V0, 28(S8)
9D0108A0      0CA3   MOVE A1, V1
9D0108A2      0CC2   MOVE A2, V0
9D0108A4  76808031   JALS concat
9D0108A8      0C00   NOP
61:                      if(sc.s3!=NULL){ concat(sc.result, sc.s3, sc.len); }
9D0108AA  FC5E0028   LW V0, 40(S8)
9D0108AE  40E2000B   BEQZC V0, 0x9D0108C8
9D0108B2  FC9E0018   LW A0, 24(S8)
9D0108B6  FC7E0028   LW V1, 40(S8)
9D0108BA  FC5E001C   LW V0, 28(S8)
9D0108BE      0CA3   MOVE A1, V1
9D0108C0      0CC2   MOVE A2, V0
9D0108C2  76808031   JALS concat
9D0108C6      0C00   NOP
62:                      if(sc.s4!=NULL){ concat(sc.result, sc.s4, sc.len); }    
9D0108C8  FC5E002C   LW V0, 44(S8)
9D0108CC  40E2000B   BEQZC V0, 0x9D0108E6
9D0108D0  FC9E0018   LW A0, 24(S8)
9D0108D4  FC7E002C   LW V1, 44(S8)
9D0108D8  FC5E001C   LW V0, 28(S8)
9D0108DC      0CA3   MOVE A1, V1
9D0108DE      0CC2   MOVE A2, V0
9D0108E0  76808031   JALS concat
9D0108E4      0C00   NOP
63:                  }
9D0108E6      0FBE   MOVE SP, S8
9D0108E8      4BE5   LW RA, 20(SP)
9D0108EA      4BC4   LW S8, 16(SP)
9D0108EC      4C0D   ADDIU SP, SP, 24
9D0108EE      45BF   JRC RA
64:                  
65:                  int appendString(char* buffer, int buffer_len, char* a, ...)
66:                  {
9D0108F0      4FF1   ADDIU SP, SP, -32
9D0108F2      CBE7   SW RA, 28(SP)
9D0108F4      CBC6   SW S8, 24(SP)
9D0108F6      0FDD   MOVE S8, SP
9D0108F8  F89E0020   SW A0, 32(S8)
9D0108FC  F8BE0024   SW A1, 36(S8)
9D010900  F8FE002C   SW A3, 44(S8)
9D010904  F8DE0028   SW A2, 40(S8)
67:                      //buffer obsahuje data (nebo 0x0)
68:                      //k bufferu pripoji stringy a[0]-a[x]
69:                      //kazdy string a[0]-a[x] musi byt zakonceny /0
70:                      //pokud celkova delka presahne buffer_len, bude zkraceno (posledni znak bude \0)    
71:                      
72:                      int ret=0x1;
9D010908      ED01   LI V0, 1
9D01090A  F85E0010   SW V0, 16(S8)
73:                      va_list argList;                            //seznam argumentu
74:                      va_start ( argList, a );                    //a
9D01090E  305E002C   ADDIU V0, S8, 44
9D010912  F85E0014   SW V0, 20(S8)
9D010914  0014CC17   BREAK
75:                      while(a)
9D010916      CC17   B 0x9D010946
9D010918      0C00   NOP
9D010946  FC5E0028   LW V0, 40(S8)
9D01094A  40A2FFE6   BNEZC V0, 0x9D01091A
9D01094C  FFE6FC5E   LW RA, -930(A2)
76:                      {
77:                          ret &= concat(buffer, a, buffer_len);
9D01091A  FC9E0020   LW A0, 32(S8)
9D01091E  FCBE0028   LW A1, 40(S8)
9D010922  FCDE0024   LW A2, 36(S8)
9D010924  00247680   OR T6, A0, AT
9D010926  76808031   JALS concat
9D01092A      0C00   NOP
9D01092C  FC7E0010   LW V1, 16(S8)
9D010930      4493   AND16 V0, V1
9D010932  F85E0010   SW V0, 16(S8)
78:                          a=va_arg ( argList, char* );            //a=dalsi argument (...)
9D010936  FC5E0014   LW V0, 20(S8)
9D01093A      6DA2   ADDIU V1, V0, 4
9D01093C  F87E0014   SW V1, 20(S8)
9D01093E  00146920   ADD T5, S4, ZERO
9D010940      6920   LW V0, 0(V0)
9D010942  F85E0028   SW V0, 40(S8)
79:                      }
80:                      va_end(argList);
81:                      
82:                      return ret;
9D01094E  FC5E0010   LW V0, 16(S8)
83:                  }
9D010952      0FBE   MOVE SP, S8
9D010954      4BE7   LW RA, 28(SP)
9D010956      4BC6   LW S8, 24(SP)
9D010958      4C11   ADDIU SP, SP, 32
9D01095A      45BF   JRC RA
84:                  
85:                  void alignLeft(char* str, int strlen)
86:                  {
9D01095C      4FF5   ADDIU SP, SP, -24
9D01095E      CBE5   SW RA, 20(SP)
9D010960      CBC4   SW S8, 16(SP)
9D010962      0FDD   MOVE S8, SP
9D010964  F89E0018   SW A0, 24(S8)
9D010968  F8BE001C   SW A1, 28(S8)
87:                      //vyradi leve mezery, prida prave mezery, aby pocet platnych znaku byl strlen
88:                      //tzn. ze velikost char[] str musi byt o 1 vetsi
89:                      //napr.: alignLeft(num, 8)
90:                      //pred: num[9]="    1256\0"
91:                      //po:   num[9]="1256    \0"
92:                      lTrim(str, str);
9D01096C  FC9E0018   LW A0, 24(S8)
9D010970  FCBE0018   LW A1, 24(S8)
9D010972  00187680   OR T6, T8, ZERO
9D010974  76808050   JALS lTrim
9D010978      0C00   NOP
93:                      addSpace(str, strlen);
9D01097A  FC9E0018   LW A0, 24(S8)
9D01097E  FCBE001C   LW A1, 28(S8)
9D010980  001C7680   OR T6, GP, ZERO
9D010982  768080A4   JALS addSpace
9D010986      0C00   NOP
94:                  }
9D010988      0FBE   MOVE SP, S8
9D01098A      4BE5   LW RA, 20(SP)
9D01098C      4BC4   LW S8, 16(SP)
9D01098E      4C0D   ADDIU SP, SP, 24
9D010990      45BF   JRC RA
9D010992      0C00   NOP
95:                  
96:                  float roundFloat(float f, int dec)
97:                  {
9D010994      4FE9   ADDIU SP, SP, -48
9D010996      CBEB   SW RA, 44(SP)
9D010998      CBCA   SW S8, 40(SP)
9D01099A      CA09   SW S0, 36(SP)
9D01099C      0FDD   MOVE S8, SP
9D01099E  F89E0030   SW A0, 48(S8)
9D0109A2  F8BE0034   SW A1, 52(S8)
98:                      int a=dec;
9D0109A6  FC5E0034   LW V0, 52(S8)
9D0109AA  F85E0010   SW V0, 16(S8)
99:                      int n=1;
9D0109AE      ED01   LI V0, 1
9D0109B0  F85E0014   SW V0, 20(S8)
9D0109B2  0014CC0D   ADDQ_S.PH T9, S4, ZERO
100:                     while(a>0) { n*=10; a--; }
9D0109B4      CC0D   B 0x9D0109D0
9D0109B6      0C00   NOP
9D0109B8  FC5E0014   LW V0, 20(S8)
9D0109BC      2522   SLL V0, V0, 1
9D0109BE      25A4   SLL V1, V0, 2
9D0109C0      0534   ADDU V0, V0, V1
9D0109C2  F85E0014   SW V0, 20(S8)
9D0109C6  FC5E0010   LW V0, 16(S8)
9D0109CA      6D2E   ADDIU V0, V0, -1
9D0109CC  F85E0010   SW V0, 16(S8)
9D0109D0  FC5E0010   LW V0, 16(S8)
9D0109D4  40C2FFF0   BGTZ V0, 0x9D0109B8
9D0109D6  FFF00C00   LW RA, 3072(S0)
9D0109D8      0C00   NOP
101:                     
102:                     if(f>=0) { f=f*n + 0.555555; }
9D0109DA      0C80   MOVE A0, ZERO
9D0109DC  FCBE0030   LW A1, 48(S8)
9D0109DE  00307680   OR T6, S0, AT
9D0109E0  76809E3C   JALS __lesf2
9D0109E2  9E3C0C00   LWC1 F17, 3072(GP)
9D0109E4      0C00   NOP
9D0109E6  40C20019   BGTZ V0, 0x9D010A1C
9D0109E8  00190C00   SLL ZERO, T9, 1
9D0109EA      0C00   NOP
9D0109EC  FC9E0014   LW A0, 20(S8)
9D0109EE  00147680   OR T6, S4, ZERO
9D0109F0  76800090   JALS sitofp
9D0109F2  00900C00   SLL A0, S0, 1
9D0109F4      0C00   NOP
9D0109F6      0C82   MOVE A0, V0
9D0109F8  FCBE0030   LW A1, 48(S8)
9D0109FA  00307680   OR T6, S0, AT
9D0109FC  76809D88   JALS __mulsf3
9D0109FE  9D880C00   LWC1 F12, 3072(T0)
9D010A00      0C00   NOP
9D010A02      0C62   MOVE V1, V0
9D010A04  41A29D01   LUI V0, 0x9D01
9D010A06  9D010C83   LWC1 F8, 3203(AT)
9D010A08      0C83   MOVE A0, V1
9D010A0A  FCA23CC8   LW A1, 15560(V0)
9D010A0C  3CC87680   LH A2, 30336(T0)
9D010A0E  768099EC   JALS __addsf3
9D010A10  99EC0C00   SWC1 F15, 3072(T4)
9D010A12      0C00   NOP
9D010A14  F85E0030   SW V0, 48(S8)
9D010A16  0030CC17   BREAK
9D010A18      CC17   B 0x9D010A48
9D010A1A      0C00   NOP
103:                     else { f=f*n - 0.555555; }
9D010A1C  FC9E0014   LW A0, 20(S8)
9D010A1E  00147680   OR T6, S4, ZERO
9D010A20  76800090   JALS sitofp
9D010A22  00900C00   SLL A0, S0, 1
9D010A24      0C00   NOP
9D010A26      0C82   MOVE A0, V0
9D010A28  FCBE0030   LW A1, 48(S8)
9D010A2A  00307680   OR T6, S0, AT
9D010A2C  76809D88   JALS __mulsf3
9D010A2E  9D880C00   LWC1 F12, 3072(T0)
9D010A30      0C00   NOP
9D010A32      0C62   MOVE V1, V0
9D010A34  41A29D01   LUI V0, 0x9D01
9D010A36  9D010C83   LWC1 F8, 3203(AT)
9D010A38      0C83   MOVE A0, V1
9D010A3A  FCA23CC8   LW A1, 15560(V0)
9D010A3C  3CC87680   LH A2, 30336(T0)
9D010A3E  76809A4A   JALS __subsf3
9D010A40  9A4A0C00   SWC1 F18, 3072(T2)
9D010A42      0C00   NOP
9D010A44  F85E0030   SW V0, 48(S8)
104:                     int r=(int)f;
9D010A48  FC9E0030   LW A0, 48(S8)
9D010A4A  00307680   OR T6, S0, AT
9D010A4C  76809C16   JALS __fixsfsi
9D010A4E  9C160C00   LWC1 F0, 3072(S6)
9D010A50      0C00   NOP
9D010A52  F85E0018   SW V0, 24(S8)
105:                     f=(float)(r)/n;
9D010A56  FC9E0018   LW A0, 24(S8)
9D010A58  00187680   OR T6, T8, ZERO
9D010A5A  76800090   JALS sitofp
9D010A5C  00900C00   SLL A0, S0, 1
9D010A5E      0C00   NOP
9D010A60      0E02   MOVE S0, V0
9D010A62  FC9E0014   LW A0, 20(S8)
9D010A64  00147680   OR T6, S4, ZERO
9D010A66  76800090   JALS sitofp
9D010A68  00900C00   SLL A0, S0, 1
9D010A6A      0C00   NOP
9D010A6C      0C90   MOVE A0, S0
9D010A6E      0CA2   MOVE A1, V0
9D010A70  76809B14   JALS __divsf3
9D010A72  9B140C00   SWC1 F24, 3072(S4)
9D010A74      0C00   NOP
9D010A76  F85E0030   SW V0, 48(S8)
106:                 
107:                     return f;
9D010A7A  FC5E0030   LW V0, 48(S8)
108:                 }
9D010A7E      0FBE   MOVE SP, S8
9D010A80      4BEB   LW RA, 44(SP)
9D010A82      4BCA   LW S8, 40(SP)
9D010A84      4A09   LW S0, 36(SP)
9D010A86      4C19   ADDIU SP, SP, 48
9D010A88      45BF   JRC RA
9D010A8A      0C00   NOP
109:                 
110:                 void floatToString(float f, char* ret, int dec)
111:                 {
9D010A8C      4FD9   ADDIU SP, SP, -80
9D010A8E      CBF3   SW RA, 76(SP)
9D010A90      CBD2   SW S8, 72(SP)
9D010A92      CA11   SW S0, 68(SP)
9D010A94      0FDD   MOVE S8, SP
9D010A96  F89E0050   SW A0, 80(S8)
9D010A9A  F8BE0054   SW A1, 84(S8)
9D010A9E  F8DE0058   SW A2, 88(S8)
112:                     //prevede float na string (dec je max 1...9)
113:                     ///ret musi byt pole dimenzovane min. na 16 znaku (15 + \0)
114:                     
115:                     f=roundFloat(f, dec);
9D010AA2  FC9E0050   LW A0, 80(S8)
9D010AA6  FCBE0058   LW A1, 88(S8)
9D010AA8  00587680   OR T6, T8, V0
9D010AAA  768084CA   JALS roundFloat
9D010AAC      84CA   MOVEP A1, A3, S2, S0
9D010AAE      0C00   NOP
9D010AB0  F85E0050   SW V0, 80(S8)
116:                     int n=1, a=dec;
9D010AB4      ED01   LI V0, 1
9D010AB6  F85E0018   SW V0, 24(S8)
9D010ABA  FC5E0058   LW V0, 88(S8)
9D010ABE  F85E001C   SW V0, 28(S8)
9D010AC0  001CCC0D   ADDQ_S.PH T9, GP, ZERO
117:                     while(a>0) { n*=10; a--; }
9D010AC2      CC0D   B 0x9D010ADE
9D010AC4      0C00   NOP
9D010AC6  FC5E0018   LW V0, 24(S8)
9D010ACA      2522   SLL V0, V0, 1
9D010ACC      25A4   SLL V1, V0, 2
9D010ACE      0534   ADDU V0, V0, V1
9D010AD0  F85E0018   SW V0, 24(S8)
9D010AD4  FC5E001C   LW V0, 28(S8)
9D010AD8      6D2E   ADDIU V0, V0, -1
9D010ADA  F85E001C   SW V0, 28(S8)
9D010ADE  FC5E001C   LW V0, 28(S8)
9D010AE2  40C2FFF0   BGTZ V0, 0x9D010AC6
9D010AE4  FFF00C00   LW RA, 3072(S0)
9D010AE6      0C00   NOP
118:                     
119:                     int whole=f;
9D010AE8  FC9E0050   LW A0, 80(S8)
9D010AEA  00507680   OR T6, S0, V0
9D010AEC  76809C16   JALS __fixsfsi
9D010AEE  9C160C00   LWC1 F0, 3072(S6)
9D010AF0      0C00   NOP
9D010AF2  F85E0024   SW V0, 36(S8)
120:                     int decimal=(f-whole)*n; 
9D010AF6  FC9E0024   LW A0, 36(S8)
9D010AF8  00247680   OR T6, A0, AT
9D010AFA  76800090   JALS sitofp
9D010AFC  00900C00   SLL A0, S0, 1
9D010AFE      0C00   NOP
9D010B00  FC9E0050   LW A0, 80(S8)
9D010B04      0CA2   MOVE A1, V0
9D010B06  76809A4A   JALS __subsf3
9D010B08  9A4A0C00   SWC1 F18, 3072(T2)
9D010B0A      0C00   NOP
9D010B0C      0E02   MOVE S0, V0
9D010B0E  FC9E0018   LW A0, 24(S8)
9D010B10  00187680   OR T6, T8, ZERO
9D010B12  76800090   JALS sitofp
9D010B14  00900C00   SLL A0, S0, 1
9D010B16      0C00   NOP
9D010B18      0C90   MOVE A0, S0
9D010B1A      0CA2   MOVE A1, V0
9D010B1C  76809D88   JALS __mulsf3
9D010B1E  9D880C00   LWC1 F12, 3072(T0)
9D010B20      0C00   NOP
9D010B22      0C82   MOVE A0, V0
9D010B24  76809C16   JALS __fixsfsi
9D010B26  9C160C00   LWC1 F0, 3072(S6)
9D010B28      0C00   NOP
9D010B2A  F85E0020   SW V0, 32(S8)
121:                     if(decimal<0){decimal*=(-1);}
9D010B2E  FC5E0020   LW V0, 32(S8)
9D010B32  40420007   BGEZ V0, 0x9D010B44
9D010B34  00070C00   SLL ZERO, A3, 1
9D010B36      0C00   NOP
9D010B38  FC5E0020   LW V0, 32(S8)
9D010B3A  00200040   SRL AT, ZERO, 0
9D010B3C  004011D0   SUBU V0, ZERO, V0
9D010B3E  11D0F85E   ADDI T6, S0, -1954
9D010B40  F85E0020   SW V0, 32(S8)
122:                     
123:                     char p1[12];
124:                     char p2[12];
125:                     intToChar(whole, p1, 1);
9D010B44  305E0028   ADDIU V0, S8, 40
9D010B48  FC9E0024   LW A0, 36(S8)
9D010B4C      0CA2   MOVE A1, V0
9D010B4E      EF01   LI A2, 1
9D010B50  7680818A   JALS intToChar
9D010B54      0C00   NOP
126:                     intToChar(decimal, p2, dec);
9D010B56  305E0034   ADDIU V0, S8, 52
9D010B5A  FC9E0020   LW A0, 32(S8)
9D010B5E      0CA2   MOVE A1, V0
9D010B60  FCDE0058   LW A2, 88(S8)
9D010B62  00587680   OR T6, T8, V0
9D010B64  7680818A   JALS intToChar
9D010B68      0C00   NOP
127:                     createString(ret, 16, p1, ".", p2, NULL);
9D010B6A  305E0028   ADDIU V0, S8, 40
9D010B6E  307E0034   ADDIU V1, S8, 52
9D010B72      C864   SW V1, 16(SP)
9D010B74      C805   SW ZERO, 20(SP)
9D010B76  FC9E0054   LW A0, 84(S8)
9D010B78  0054EE90   OR SP, S4, V0
9D010B7A      EE90   LI A1, 16
9D010B7C      0CC2   MOVE A2, V0
9D010B7E  41A29D01   LUI V0, 0x9D01
9D010B80  9D0130E2   LWC1 F8, 12514(AT)
9D010B82  30E23CB8   ADDIU A3, V0, 15544
9D010B84  3CB87680   LH A1, 30336(T8)
9D010B86  768083F2   JALS createString
9D010B8A      0C00   NOP
128:                     
129:                     //char format[]="%1d.%01d";
130:                     //char d=48+dec;                      //zmenit cislo na pozici 6
131:                     //format[6]=d;
132:                     
133:                     //sprintf(ret, format, whole, decimal);
134:                 }
9D010B8C      0FBE   MOVE SP, S8
9D010B8E      4BF3   LW RA, 76(SP)
9D010B90      4BD2   LW S8, 72(SP)
9D010B92      4A11   LW S0, 68(SP)
9D010B94      4C29   ADDIU SP, SP, 80
9D010B96      45BF   JRC RA
135:                 
136:                 void floatToStringFormat(float f, char* ret, int w, int dec)
137:                 {
9D010B98      4FE1   ADDIU SP, SP, -64
9D010B9A      CBEF   SW RA, 60(SP)
9D010B9C      CBCE   SW S8, 56(SP)
9D010B9E      CA0D   SW S0, 52(SP)
9D010BA0      0FDD   MOVE S8, SP
9D010BA2  F89E0040   SW A0, 64(S8)
9D010BA6  F8BE0044   SW A1, 68(S8)
9D010BAA  F8DE0048   SW A2, 72(S8)
9D010BAE  F8FE004C   SW A3, 76(S8)
138:                     //prevede float na string (w = 1...9, dec = 1...9)
139:                     //w urcuje pocet mist pred des. teckou, je-li kratsi, bude pred cislem doplneno mezerami, je-li delsi, bude vysledek delsi (vypise vsechny cislice)
140:                     //des je pocet des. mist, vzdy dodrzi pocet cislic, pridava 0 na konec 
141:                     //vysledek ma vzdy stejny pocet znaku (pokud cislo neni vetsi)
142:                     
143:                     f=roundFloat(f, dec);
9D010BB2  FC9E0040   LW A0, 64(S8)
9D010BB6  FCBE004C   LW A1, 76(S8)
9D010BB8  004C7680   OR T6, T4, V0
9D010BBA  768084CA   JALS roundFloat
9D010BBC      84CA   MOVEP A1, A3, S2, S0
9D010BBE      0C00   NOP
9D010BC0  F85E0040   SW V0, 64(S8)
144:                     int n=1, a=dec;
9D010BC4      ED01   LI V0, 1
9D010BC6  F85E0010   SW V0, 16(S8)
9D010BCA  FC5E004C   LW V0, 76(S8)
9D010BCE  F85E0014   SW V0, 20(S8)
9D010BD0  0014CC0D   ADDQ_S.PH T9, S4, ZERO
145:                     while(a>0) { n*=10; a--; }
9D010BD2      CC0D   B 0x9D010BEE
9D010BD4      0C00   NOP
9D010BD6  FC5E0010   LW V0, 16(S8)
9D010BDA      2522   SLL V0, V0, 1
9D010BDC      25A4   SLL V1, V0, 2
9D010BDE      0534   ADDU V0, V0, V1
9D010BE0  F85E0010   SW V0, 16(S8)
9D010BE4  FC5E0014   LW V0, 20(S8)
9D010BE8      6D2E   ADDIU V0, V0, -1
9D010BEA  F85E0014   SW V0, 20(S8)
9D010BEE  FC5E0014   LW V0, 20(S8)
9D010BF2  40C2FFF0   BGTZ V0, 0x9D010BD6
9D010BF4  FFF00C00   LW RA, 3072(S0)
9D010BF6      0C00   NOP
146:                     
147:                     int whole=f;
9D010BF8  FC9E0040   LW A0, 64(S8)
9D010BFA  00407680   OR T6, ZERO, V0
9D010BFC  76809C16   JALS __fixsfsi
9D010BFE  9C160C00   LWC1 F0, 3072(S6)
9D010C00      0C00   NOP
9D010C02  F85E0018   SW V0, 24(S8)
148:                     int decimal=(f-whole)*n; 
9D010C06  FC9E0018   LW A0, 24(S8)
9D010C08  00187680   OR T6, T8, ZERO
9D010C0A  76800090   JALS sitofp
9D010C0C  00900C00   SLL A0, S0, 1
9D010C0E      0C00   NOP
9D010C10  FC9E0040   LW A0, 64(S8)
9D010C14      0CA2   MOVE A1, V0
9D010C16  76809A4A   JALS __subsf3
9D010C18  9A4A0C00   SWC1 F18, 3072(T2)
9D010C1A      0C00   NOP
9D010C1C      0E02   MOVE S0, V0
9D010C1E  FC9E0010   LW A0, 16(S8)
9D010C20  00107680   OR T6, S0, ZERO
9D010C22  76800090   JALS sitofp
9D010C24  00900C00   SLL A0, S0, 1
9D010C26      0C00   NOP
9D010C28      0C90   MOVE A0, S0
9D010C2A      0CA2   MOVE A1, V0
9D010C2C  76809D88   JALS __mulsf3
9D010C2E  9D880C00   LWC1 F12, 3072(T0)
9D010C30      0C00   NOP
9D010C32      0C82   MOVE A0, V0
9D010C34  76809C16   JALS __fixsfsi
9D010C36  9C160C00   LWC1 F0, 3072(S6)
9D010C38      0C00   NOP
9D010C3A  F85E001C   SW V0, 28(S8)
149:                     if(decimal<0){decimal*=(-1);}
9D010C3E  FC5E001C   LW V0, 28(S8)
9D010C42  40420007   BGEZ V0, 0x9D010C54
9D010C44  00070C00   SLL ZERO, A3, 1
9D010C46      0C00   NOP
9D010C48  FC5E001C   LW V0, 28(S8)
9D010C4A  001C0040   SRL ZERO, GP, 0
9D010C4C  004011D0   SUBU V0, ZERO, V0
9D010C4E  11D0F85E   ADDI T6, S0, -1954
9D010C50  F85E001C   SW V0, 28(S8)
150:                     
151:                 
152:                     
153:                     
154:                     char format[]="%1d.%01d";
9D010C54  41A29D01   LUI V0, 0x9D01
9D010C56  9D01FC82   LWC1 F8, -894(AT)
9D010C58  FC823CBC   LW A0, 15548(V0)
9D010C5A  3CBC3062   LH A1, 12386(GP)
9D010C5C  30623CBC   ADDIU V1, V0, 15548
9D010C5E  3CBC69B1   LH A1, 27057(GP)
9D010C60      69B1   LW V1, 4(V1)
9D010C62  F89E0024   SW A0, 36(S8)
9D010C66  F87E0028   SW V1, 40(S8)
9D010C6A  30423CBC   ADDIU V0, V0, 15548
9D010C6C  3CBC0928   LH A1, 2344(GP)
9D010C6E      0928   LBU V0, 8(V0)
9D010C70  185E002C   SB V0, 44(S8)
155:                     char x=48+w;
9D010C74  FC5E0048   LW V0, 72(S8)
9D010C76  00482D2D   PRECRQ_RS.PH.W A1, T0, V0
9D010C78      2D2D   ANDI V0, V0, 0xFF
9D010C7A  30420030   ADDIU V0, V0, 48
9D010C7E  185E0020   SB V0, 32(S8)
156:                     char y=48+dec;
9D010C82  FC5E004C   LW V0, 76(S8)
9D010C84  004C2D2D   PRECRQ_RS.PH.W A1, T4, V0
9D010C86      2D2D   ANDI V0, V0, 0xFF
9D010C88  30420030   ADDIU V0, V0, 48
9D010C8C  185E0021   SB V0, 33(S8)
157:                     format[1]=x;
9D010C90  145E0020   LBU V0, 32(S8)
9D010C94  185E0025   SB V0, 37(S8)
158:                     format[6]=y;
9D010C98  145E0021   LBU V0, 33(S8)
9D010C9C  185E002A   SB V0, 42(S8)
159:                 
160:                     
161:                     
162:                     //sprintf(ret, format, whole, decimal);
163:                 }
9D010CA0      0FBE   MOVE SP, S8
9D010CA2      4BEF   LW RA, 60(SP)
9D010CA4      4BCE   LW S8, 56(SP)
9D010CA6      4A0D   LW S0, 52(SP)
9D010CA8      4C21   ADDIU SP, SP, 64
9D010CAA      45BF   JRC RA
164:                 
165:                 void intToStringFormat(int i, char* ret, int w)
166:                 {
9D010CAC      4FF9   ADDIU SP, SP, -16
9D010CAE      CBC3   SW S8, 12(SP)
9D010CB0      0FDD   MOVE S8, SP
9D010CB2  F89E0010   SW A0, 16(S8)
9D010CB6  F8BE0014   SW A1, 20(S8)
9D010CBA  F8DE0018   SW A2, 24(S8)
167:                     //prevod int na string (w=1...9)
168:                     //vraci pocet znaku = w, pred kratsi cislo vlozi mezery, je-li delsi, vysledek je delsi nez w
169:                     
170:                     char format[]="%1d";
9D010CBE  41A20064   LUI V0, 0x64
9D010CC2  50423125   ORI V0, V0, 12581
9D010CC4  3125F85E   ADDIU T1, A1, -1954
9D010CC6  F85E0004   SW V0, 4(S8)
171:                     char x=48+w;
9D010CCA  FC5E0018   LW V0, 24(S8)
9D010CCC  00182D2D   PRECRQ_RS.PH.W A1, T8, ZERO
9D010CCE      2D2D   ANDI V0, V0, 0xFF
9D010CD0  30420030   ADDIU V0, V0, 48
9D010CD4  185E0000   SB V0, 0(S8)
172:                     format[1]=x;
9D010CD8  145E0000   LBU V0, 0(S8)
9D010CDC  185E0005   SB V0, 5(S8)
173:                 
174:                     //sprintf(ret, format, i);    
175:                 }
9D010CE0      0FBE   MOVE SP, S8
---  d:/bos/bos/disp1306.c  -----------------------------------------------------------------------------
1:                   #include <xc.h>
2:                   #include <stdio.h>
3:                   #include <stdlib.h>
4:                   #include "globals.h"
5:                   
6:                   //I2C_ADDRESS displeje je  0b0111100 a 0b0111101 (tzn. ze na jednu bus lze pripojit dva displeje. Adresu b.0 urcuje pin displeje D/C - GND nebo Vcc)
7:                   
8:                   #define USE_DISP1306
9:                   #define SW_RESET                                //je definovano, pokud je RESET signal pripojen k IO pinu. Neni-li definovano, ma HW RESET (RC obvod)
10:                  
11:                  #ifdef USE_DISP1306
12:                  //font nebo image se generuje programem lcd-image-converter
13:                  //pro ssd1306 plati toto nastaveni
14:                  //1. load image (nebo font)
15:                  //2. okno Options: Prepare: Monochrome, MainScanDirection=Left To Right, LineScanDirection=Forward, Bands=8px
16:                  //3. okno Reordering: prehodit b0>b7, b1>b6, b2>b5, b3>b4, ... 
17:                  //4. okno Options: Image: BlockSize=8bit, ByteOrder=Little Endian
18:                  //Kazdy bajt je sloupec 8 pixelu, b0=horni px, b7=dolni px. Nejprve se plni prvni radek (8 px na vysku), pak druhy radek atd...
19:                  //Tzn. ze napr. 10 bytes na jednom radku vytvori box 8(h) x 10(w) px
20:                  //https://gist.github.com/postmodern/ed6e670999f456ad9f13
21:                  
22:                  //globalni promene modulu (tzn. pri pouziti vice displeju ssd1306 jsou spolecne pro vsechny struct DISPLAY)
23:                  extern IMAGE_SRC fontSys;                       //pouziva fce print
24:                  
25:                  #define     BUFFER_SIZE      256               //min. velikost by mela byt: Width x 2 + 20 (viz. fillBox, clear)           
26:                  static char pixelsEven[BUFFER_SIZE] __attribute__((aligned(4)));
27:                  static char pixelsOdd [BUFFER_SIZE] __attribute__((aligned(4)));
28:                  static char isInitialized=0;
29:                  static char pixAB=0;
30:                  //static LINE_SRC lineSrc;
31:                  //static POINT point;
32:                  
33:                  //privatni struct pro dany displej, pri pouziti vice displeju se nastavi pri kazdem volani setGraphics
34:                  static PORT_INFO* portInfo=NULL;            
35:                  static DISPLAY* displayInfo=NULL;
36:                  
37:                  //static char Orientation=0;
38:                  static short Width=128;                         //default na vysku, fce dinit nastavi displej na sirku a upravi W a H              
39:                  static short Height=64;
40:                  
41:                  
42:                  //local void
43:                  static void selectPort(PORT_INFO* pi, void* d);
44:                  static void drawString(char* text, IMAGE_SRC* font, short x, short y);
45:                  static void fillBox(short x1, short y1, short x2, short y2, short color);
46:                  static void drawLine(short x1, short y1, short x2, short y2, short w, short color);
47:                  static void drawImage(IMAGE_SRC* da, short x, short y);
48:                  static void drawPoint(short x, short y, short color);
49:                  static short textWidth(char* text, IMAGE_SRC* font);
50:                  static void clear(short color);
51:                  static void initDisplay();
52:                  static void setOrientation(char x);
53:                  static char getOrientation();
54:                  static void setBrightness(char val);
55:                  static void controlDisplay(char on, char sleep, char bl, char inv);
56:                  static char getInitialized();
57:                  static void print(char* t);
58:                  static short getWidth();
59:                  static short getHeight();
60:                  
61:                  static void dinit();
62:                  static void writeChar(IMAGE_SRC* font, char code, short x, short y);
63:                  static int prefixSpi(char buffer[], short start_x, short end_x, short start_page, short end_page);
64:                  static int prefixI2c(char buffer[], short start_x, short end_x, short start_page, short end_page);
65:                  static void eventDC(char x);
66:                  
67:                  static char* getBuffer();
68:                  static void getPort();
69:                  static void freePort();
70:                  //static void writeBuffer(char* buff, int len, char mode);
71:                  
72:                  static void resetDisplay();
73:                  void setDCPin(char value);
74:                  static void setCSPin(char value);
75:                  static void setResetPin(char value);
76:                  
77:                  
78:                  //global
79:                  void disp1306_driver(DISPLAY* d)
80:                  {
9D00BED8      4FB0   ADDIU SP, SP, -8
9D00BEDA      CBC1   SW S8, 4(SP)
9D00BEDC      0FDD   MOVE S8, SP
9D00BEDE  F89E0008   SW A0, 8(S8)
81:                      d->selectPort=&selectPort;
9D00BEE2  FC5E0008   LW V0, 8(S8)
9D00BEE6  41A39D01   LUI V1, 0x9D01
9D00BEE8  9D013063   LWC1 F8, 12387(AT)
9D00BEEA  3063BFDD   ADDIU V1, V1, -16419
9D00BEEC  BFDDE9A0   LDC1 F30, -5728(SP)
9D00BEEE      E9A0   SW V1, 0(V0)
82:                      d->drawString=&drawString;
9D00BEF0  FC5E0008   LW V0, 8(S8)
9D00BEF4  41A39D01   LUI V1, 0x9D01
9D00BEF6  9D013063   LWC1 F8, 12387(AT)
9D00BEF8  3063C011   ADDIU V1, V1, -16367
9D00BEFC      E9A2   SW V1, 8(V0)
83:                      d->fillBox=&fillBox;
9D00BEFE  FC5E0008   LW V0, 8(S8)
9D00BF02  41A39D01   LUI V1, 0x9D01
9D00BF04  9D013063   LWC1 F8, 12387(AT)
9D00BF06  3063C0C1   ADDIU V1, V1, -16191
9D00BF0A      E9A3   SW V1, 12(V0)
84:                      d->drawLine=&drawLine;
9D00BF0C  FC5E0008   LW V0, 8(S8)
9D00BF10  41A39D01   LUI V1, 0x9D01
9D00BF12  9D013063   LWC1 F8, 12387(AT)
9D00BF14  3063C439   ADDIU V1, V1, -15303
9D00BF18      E9A4   SW V1, 16(V0)
85:                      d->drawImage=&drawImage;
9D00BF1A  FC5E0008   LW V0, 8(S8)
9D00BF1E  41A39D01   LUI V1, 0x9D01
9D00BF20  9D013063   LWC1 F8, 12387(AT)
9D00BF22  3063C461   ADDIU V1, V1, -15263
9D00BF26      E9A5   SW V1, 20(V0)
86:                      d->drawPoint=&drawPoint;
9D00BF28  FC5E0008   LW V0, 8(S8)
9D00BF2C  41A39D01   LUI V1, 0x9D01
9D00BF2E  9D013063   LWC1 F8, 12387(AT)
9D00BF30  3063C739   ADDIU V1, V1, -14535
9D00BF34      E9A6   SW V1, 24(V0)
87:                      d->textWidth=&textWidth;
9D00BF36  FC5E0008   LW V0, 8(S8)
9D00BF3A  41A39D01   LUI V1, 0x9D01
9D00BF3C  9D013063   LWC1 F8, 12387(AT)
9D00BF3E  3063C759   ADDIU V1, V1, -14503
9D00BF42      E9AC   SW V1, 48(V0)
88:                      d->print=&print;
9D00BF44  FC5E0008   LW V0, 8(S8)
9D00BF48  41A39D01   LUI V1, 0x9D01
9D00BF4A  9D013063   LWC1 F8, 12387(AT)
9D00BF4C  3063CC05   ADDIU V1, V1, -13307
9D00BF4E      CC05   B 0x9D00BF5A
9D00BF50      E9A7   SW V1, 28(V0)
89:                      d->clear=&clear;
9D00BF52  FC5E0008   LW V0, 8(S8)
9D00BF56  41A39D01   LUI V1, 0x9D01
9D00BF58  9D013063   LWC1 F8, 12387(AT)
9D00BF5A  3063C7D9   ADDIU V1, V1, -14375
9D00BF5E      E9A8   SW V1, 32(V0)
90:                      d->initDisplay=&initDisplay;
9D00BF60  FC5E0008   LW V0, 8(S8)
9D00BF64  41A39D01   LUI V1, 0x9D01
9D00BF66  9D013063   LWC1 F8, 12387(AT)
9D00BF68  3063C821   ADDIU V1, V1, -14303
9D00BF6A      C821   SW AT, 4(SP)
9D00BF6C      E9A1   SW V1, 4(V0)
91:                      d->setOrientation=&setOrientation;
9D00BF6E  FC5E0008   LW V0, 8(S8)
9D00BF72  41A39D01   LUI V1, 0x9D01
9D00BF74  9D013063   LWC1 F8, 12387(AT)
9D00BF76  3063C855   ADDIU V1, V1, -14251
9D00BF78      C855   SW V0, 84(SP)
9D00BF7A      E9A9   SW V1, 36(V0)
92:                      d->setBrightness=&setBrightness;
9D00BF7C  FC5E0008   LW V0, 8(S8)
9D00BF80  41A39D01   LUI V1, 0x9D01
9D00BF82  9D013063   LWC1 F8, 12387(AT)
9D00BF84  3063C879   ADDIU V1, V1, -14215
9D00BF86      C879   SW V1, 100(SP)
9D00BF88      E9AA   SW V1, 40(V0)
93:                      d->controlDisplay=&controlDisplay;
9D00BF8A  FC5E0008   LW V0, 8(S8)
9D00BF8E  41A39D01   LUI V1, 0x9D01
9D00BF90  9D013063   LWC1 F8, 12387(AT)
9D00BF92  3063C939   ADDIU V1, V1, -14023
9D00BF94      C939   SW T1, 100(SP)
9D00BF96      E9AB   SW V1, 44(V0)
94:                      d->getInitialized=&getInitialized;
9D00BF98  FC5E0008   LW V0, 8(S8)
9D00BF9C  41A39D01   LUI V1, 0x9D01
9D00BF9E  9D013063   LWC1 F8, 12387(AT)
9D00BFA0  3063CBF1   ADDIU V1, V1, -13327
9D00BFA2      CBF1   SW RA, 68(SP)
9D00BFA4      E9AD   SW V1, 52(V0)
95:                      d->getOrientation=&getOrientation;
9D00BFA6  FC5E0008   LW V0, 8(S8)
9D00BFAA  41A39D01   LUI V1, 0x9D01
9D00BFAC  9D013063   LWC1 F8, 12387(AT)
9D00BFAE  3063C869   ADDIU V1, V1, -14231
9D00BFB0      C869   SW V1, 36(SP)
9D00BFB2      E9AE   SW V1, 56(V0)
96:                      d->getWidth=&getWidth;
9D00BFB4  FC5E0008   LW V0, 8(S8)
9D00BFB8  41A39D01   LUI V1, 0x9D01
9D00BFBA  9D013063   LWC1 F8, 12387(AT)
9D00BFBC  3063CC99   ADDIU V1, V1, -13159
9D00BFBE      CC99   B 0x9D00C0F2
9D00BFC0      E9AF   SW V1, 60(V0)
97:                      d->getHeight=&getHeight;
9D00BFC2  FC5E0008   LW V0, 8(S8)
9D00BFC6  41A39D01   LUI V1, 0x9D01
9D00BFC8  9D013063   LWC1 F8, 12387(AT)
9D00BFCA  3063CCAD   ADDIU V1, V1, -13139
9D00BFCC      CCAD   B 0x9D00C128
9D00BFCE  F8620040   SW V1, 64(V0)
98:                  }
9D00BFD2      0FBE   MOVE SP, S8
9D00BFD4      4BC1   LW S8, 4(SP)
9D00BFD6      4C05   ADDIU SP, SP, 8
9D00BFD8      45BF   JRC RA
9D00BFDA      0C00   NOP
99:                  
100:                 
101:                 //local
102:                 static void selectPort(PORT_INFO* pi, void* d)
103:                 {
9D00BFDC      4FB0   ADDIU SP, SP, -8
9D00BFDE      CBC1   SW S8, 4(SP)
9D00BFE0      0FDD   MOVE S8, SP
9D00BFE2  F89E0008   SW A0, 8(S8)
9D00BFE6  F8BE000C   SW A1, 12(S8)
104:                     portInfo=pi;
9D00BFEA  FC5E0008   LW V0, 8(S8)
9D00BFEE  F85C804C   SW V0, -32692(GP)
105:                     portInfo->eventFn=&eventDC;
9D00BFF2  FC5C804C   LW V0, -32692(GP)
9D00BFF6  41A39D01   LUI V1, 0x9D01
9D00BFF8  9D013063   LWC1 F8, 12387(AT)
9D00BFFA  3063D495   ADDIU V1, V1, -11115
9D00BFFC  D495E9A5   J 0x992BD34A
9D00BFFE      E9A5   SW V1, 20(V0)
106:                     
107:                     displayInfo=(DISPLAY*)d;
9D00C000  FC5E000C   LW V0, 12(S8)
9D00C004  F85C8050   SW V0, -32688(GP)
108:                 }
9D00C008      0FBE   MOVE SP, S8
9D00C00A      4BC1   LW S8, 4(SP)
9D00C00C      4C05   ADDIU SP, SP, 8
9D00C00E      45BF   JRC RA
109:                 
110:                 static void drawString(char* text, IMAGE_SRC* font, short x, short y)
111:                 {
9D00C010      4FF1   ADDIU SP, SP, -32
9D00C012      CBE7   SW RA, 28(SP)
9D00C014      CBC6   SW S8, 24(SP)
9D00C016      0FDD   MOVE S8, SP
9D00C018  F89E0020   SW A0, 32(S8)
9D00C01C  F8BE0024   SW A1, 36(S8)
9D00C020      0C66   MOVE V1, A2
9D00C022      0C47   MOVE V0, A3
9D00C024  387E0028   SH V1, 40(S8)
9D00C028  385E002C   SH V0, 44(S8)
112:                     int a;
113:                     int l=strLen(text);
9D00C02C  FC9E0020   LW A0, 32(S8)
9D00C02E  00207680   OR T6, ZERO, AT
9D00C030  76808024   JALS strLen
9D00C034      0C00   NOP
9D00C036  F85E0014   SW V0, 20(S8)
114:                     
115:                     if(font==NULL) { font=&fontSys; }
9D00C03A  FC5E0024   LW V0, 36(S8)
9D00C03E  40A20006   BNEZC V0, 0x9D00C04E
9D00C042  41A28000   LUI V0, 0x8000
9D00C046  304207B8   ADDIU V0, V0, 1976
9D00C048      07B8   ADDU A3, A0, V1
9D00C04A  F85E0024   SW V0, 36(S8)
9D00C04C  00247680   OR T6, A0, AT
116:                     
117:                     getPort();
9D00C04E  76806A0E   JALS getPort
9D00C050      6A0E   LW A0, 56(S0)
9D00C052      0C00   NOP
118:                     
119:                     for(a=0; a<l; a++)
9D00C054  F81E0010   SW ZERO, 16(S8)
9D00C058      CC22   B 0x9D00C09E
9D00C05A      0C00   NOP
9D00C094  FC5E0010   LW V0, 16(S8)
9D00C096  00106D20   ADD T5, S0, ZERO
9D00C098      6D20   ADDIU V0, V0, 1
9D00C09A  F85E0010   SW V0, 16(S8)
9D00C09E  FC7E0010   LW V1, 16(S8)
9D00C0A2  FC5E0014   LW V0, 20(S8)
9D00C0A6  00431350   SLT V0, V1, V0
9D00C0A8  135040A2   ADDI K0, S0, 16546
9D00C0AA  40A2FFD7   BNEZC V0, 0x9D00C05C
9D00C0AC  FFD77680   LW S8, 30336(S7)
120:                     {
121:                         writeChar(font, text[a], x, y);
9D00C05C  FC5E0010   LW V0, 16(S8)
9D00C060  FC7E0020   LW V1, 32(S8)
9D00C064      0526   ADDU V0, V1, V0
9D00C066      0AA0   LBU A1, 0(V0)
9D00C068  3C7E0028   LH V1, 40(S8)
9D00C06C  3C5E002C   LH V0, 44(S8)
9D00C070  FC9E0024   LW A0, 36(S8)
9D00C074      0CC3   MOVE A2, V1
9D00C076      0CE2   MOVE A3, V0
9D00C078  768067D4   JALS writeChar
9D00C07A      67D4   LW A3, -176(GP)
9D00C07C      0C00   NOP
122:                         x+=font->width;
9D00C07E  FC5E0024   LW V0, 36(S8)
9D00C082  3C420004   LH V0, 4(V0)
9D00C086      2DAF   ANDI V1, V0, 0xFFFF
9D00C088  345E0028   LHU V0, 40(S8)
9D00C08C      0526   ADDU V0, V1, V0
9D00C08E      2D2F   ANDI V0, V0, 0xFFFF
9D00C090  385E0028   SH V0, 40(S8)
123:                     }
124:                     
125:                     freePort();
9D00C0AE  76806A2C   JALS freePort
9D00C0B0      6A2C   LW A0, 48(V0)
9D00C0B2      0C00   NOP
126:                     
127:                 }
9D00C0B4      0FBE   MOVE SP, S8
9D00C0B6      4BE7   LW RA, 28(SP)
9D00C0B8      4BC6   LW S8, 24(SP)
9D00C0BA      4C11   ADDIU SP, SP, 32
9D00C0BC      45BF   JRC RA
9D00C0BE      0C00   NOP
128:                 
129:                 static void fillBox(short x1, short y1, short x2, short y2, short color)
130:                 {
9D00C0C0      4FE1   ADDIU SP, SP, -64
9D00C0C2      CBEF   SW RA, 60(SP)
9D00C0C4      CBCE   SW S8, 56(SP)
9D00C0C6      0FDD   MOVE S8, SP
9D00C0C8      0D04   MOVE T0, A0
9D00C0CA      0C85   MOVE A0, A1
9D00C0CC      0C66   MOVE V1, A2
9D00C0CE      0C47   MOVE V0, A3
9D00C0D0  391E0040   SH T0, 64(S8)
9D00C0D4  389E0044   SH A0, 68(S8)
9D00C0D8  387E0048   SH V1, 72(S8)
9D00C0DC  385E004C   SH V0, 76(S8)
131:                     //plni box vzorem, dolni byte parametru color
132:                     //y musi byt delitelne 8
133:                     if((y1 % 8) != 0) { return; }
9D00C0E0  345E0044   LHU V0, 68(S8)
9D00C0E4      2D25   ANDI V0, V0, 0x7
9D00C0E6      2D2F   ANDI V0, V0, 0xFFFF
9D00C0E8  40E20002   BEQZC V0, 0x9D00C0F0
9D00C0EA  0002CDA0   SUB T9, V0, ZERO
9D00C0EC      CDA0   B 0x9D00C42E
9D00C0EE      0C00   NOP
134:                      
135:                     //x1 musi byt mensi, nez x2, to same y1 a y2
136:                     if(x1 > x2) { short x=x1; x1=x2, x2=x; }
9D00C0F0  3C7E0040   LH V1, 64(S8)
9D00C0F4  3C5E0048   LH V0, 72(S8)
9D00C0F8  00621350   SLT V0, V0, V1
9D00C0FA  135040E2   ADDI K0, S0, 16610
9D00C0FC  40E2000C   BEQZC V0, 0x9D00C118
9D00C100  345E0040   LHU V0, 64(S8)
9D00C104  385E0024   SH V0, 36(S8)
9D00C108  345E0048   LHU V0, 72(S8)
9D00C10C  385E0040   SH V0, 64(S8)
9D00C110  345E0024   LHU V0, 36(S8)
9D00C114  385E0048   SH V0, 72(S8)
137:                     if(y1 > y2) { short y=y1; y1=y2, y2=y; }  
9D00C118  3C7E0044   LH V1, 68(S8)
9D00C11C  3C5E004C   LH V0, 76(S8)
9D00C120  00621350   SLT V0, V0, V1
9D00C122  135040E2   ADDI K0, S0, 16610
9D00C124  40E2000C   BEQZC V0, 0x9D00C140
9D00C128  345E0044   LHU V0, 68(S8)
9D00C12C  385E0026   SH V0, 38(S8)
9D00C130  345E004C   LHU V0, 76(S8)
9D00C134  385E0044   SH V0, 68(S8)
9D00C138  345E0026   LHU V0, 38(S8)
9D00C13C  385E004C   SH V0, 76(S8)
138:                     
139:                     if(x1 >= Width) { return; }             //mimo, vlevo
9D00C140  3C5C801A   LH V0, -32742(GP)
9D00C144  3C7E0040   LH V1, 64(S8)
9D00C148  00431350   SLT V0, V1, V0
9D00C14A  135040A2   ADDI K0, S0, 16546
9D00C14C  40A20002   BNEZC V0, 0x9D00C154
9D00C150      CD6E   B 0x9D00C42E
9D00C152      0C00   NOP
140:                     if(x2 < 0) { return; }                  //mimo, vpravo
9D00C154  3C5E0048   LH V0, 72(S8)
9D00C158  40420003   BGEZ V0, 0x9D00C162
9D00C15A  00030C00   SLL ZERO, V1, 1
9D00C15C      0C00   NOP
9D00C15E      CD67   B 0x9D00C42E
9D00C160      0C00   NOP
141:                     if(y1 >= Height) { return; }            //mimo nahore
9D00C162  3C5C801C   LH V0, -32740(GP)
9D00C166  3C7E0044   LH V1, 68(S8)
9D00C16A  00431350   SLT V0, V1, V0
9D00C16C  135040A2   ADDI K0, S0, 16546
9D00C16E  40A20002   BNEZC V0, 0x9D00C176
9D00C170  0002CD5D   SHILO AC3, 2
9D00C172      CD5D   B 0x9D00C42E
9D00C174      0C00   NOP
142:                     if(y2 < 0) { return; }                  //mimo dole
9D00C176  3C5E004C   LH V0, 76(S8)
9D00C17A  40420003   BGEZ V0, 0x9D00C184
9D00C17C  00030C00   SLL ZERO, V1, 1
9D00C17E      0C00   NOP
9D00C180      CD56   B 0x9D00C42E
9D00C182      0C00   NOP
143:                     
144:                     if(x1 < 0){ x1=0; }
9D00C184  3C5E0040   LH V0, 64(S8)
9D00C188  40420003   BGEZ V0, 0x9D00C192
9D00C18A  00030C00   SLL ZERO, V1, 1
9D00C18C      0C00   NOP
9D00C18E  381E0040   SH ZERO, 64(S8)
145:                     if(x2 > (Width-1)) { x2=Width-1; }
9D00C192  3C7E0048   LH V1, 72(S8)
9D00C196  3C5C801A   LH V0, -32742(GP)
9D00C19A      6D2E   ADDIU V0, V0, -1
9D00C19C  00621350   SLT V0, V0, V1
9D00C19E  135040E2   ADDI K0, S0, 16610
9D00C1A0  40E20007   BEQZC V0, 0x9D00C1B2
9D00C1A4  3C5C801A   LH V0, -32742(GP)
9D00C1A8      2D2F   ANDI V0, V0, 0xFFFF
9D00C1AA      6D2E   ADDIU V0, V0, -1
9D00C1AC      2D2F   ANDI V0, V0, 0xFFFF
9D00C1AE  385E0048   SH V0, 72(S8)
146:                     if(y1 < 0) { y1=0; }
9D00C1B2  3C5E0044   LH V0, 68(S8)
9D00C1B6  40420003   BGEZ V0, 0x9D00C1C0
9D00C1B8  00030C00   SLL ZERO, V1, 1
9D00C1BA      0C00   NOP
9D00C1BC  381E0044   SH ZERO, 68(S8)
147:                     if(y2 > (Height-1)) { y2=Height-1; }
9D00C1C0  3C7E004C   LH V1, 76(S8)
9D00C1C4  3C5C801C   LH V0, -32740(GP)
9D00C1C8      6D2E   ADDIU V0, V0, -1
9D00C1CA  00621350   SLT V0, V0, V1
9D00C1CC  135040E2   ADDI K0, S0, 16610
9D00C1CE  40E20007   BEQZC V0, 0x9D00C1E0
9D00C1D2  3C5C801C   LH V0, -32740(GP)
9D00C1D6      2D2F   ANDI V0, V0, 0xFFFF
9D00C1D8      6D2E   ADDIU V0, V0, -1
9D00C1DA      2D2F   ANDI V0, V0, 0xFFFF
9D00C1DC  385E004C   SH V0, 76(S8)
9D00C1DE  004C7680   OR T6, T4, V0
148:                     
149:                     getPort();
9D00C1E0  76806A0E   JALS getPort
9D00C1E2      6A0E   LW A0, 56(S0)
9D00C1E4      0C00   NOP
150:                     
151:                     int len=0;
9D00C1E6  F81E0018   SW ZERO, 24(S8)
9D00C1E8  00187680   OR T6, T8, ZERO
152:                     char* buffer=getBuffer();
9D00C1EA  768069F4   JALS getBuffer
9D00C1EC      69F4   LW V1, 16(A3)
9D00C1EE      0C00   NOP
9D00C1F0  F85E0028   SW V0, 40(S8)
153:                     if(portInfo->periphType==PERIPH_TYPE.i2c)
9D00C1F4  FC5C804C   LW V0, -32692(GP)
9D00C1F8  14620040   LBU V1, 64(V0)
9D00C1FC      ED02   LI V0, 2
9D00C1FE  B4430042   BNE V1, V0, 0x9D00C286
9D00C200  00420C00   SLL V0, V0, 1
9D00C202      0C00   NOP
154:                     {
155:                         len = prefixI2c(buffer, (char)x1, (char)x2, (char)(y1/8), (char)(y2/8));
9D00C204  345E0040   LHU V0, 64(S8)
9D00C206  00402D2D   PRECRQ_RS.PH.W A1, ZERO, V0
9D00C208      2D2D   ANDI V0, V0, 0xFF
9D00C20A  00A23B3C   SEH A1, V0
9D00C20C  3B3C345E   SH T9, 13406(GP)
9D00C20E  345E0048   LHU V0, 72(S8)
9D00C210  00482D2D   PRECRQ_RS.PH.W A1, T0, V0
9D00C212      2D2D   ANDI V0, V0, 0xFF
9D00C214  00C23B3C   SEH A2, V0
9D00C216  3B3C3C5E   SH T9, 15454(GP)
9D00C218  3C5E0044   LH V0, 68(S8)
9D00C21C  30620007   ADDIU V1, V0, 7
9D00C220  90820000   SLTI A0, V0, 0
9D00C224  00831018   MOVN V0, V1, A0
9D00C226  10180042   ADDI ZERO, T8, 66
9D00C228  00421880   SRA V0, V0, 3
9D00C22A  18800042   SB A0, 66(ZERO)
9D00C22C  00423B3C   SEH V0, V0
9D00C22E  3B3C2D2D   SH T9, 11565(GP)
9D00C230      2D2D   ANDI V0, V0, 0xFF
9D00C232  00623B3C   SEH V1, V0
9D00C234  3B3C3C5E   SH T9, 15454(GP)
9D00C236  3C5E004C   LH V0, 76(S8)
9D00C23A  30820007   ADDIU A0, V0, 7
9D00C23E  90E20000   SLTI A3, V0, 0
9D00C242  00E41018   MOVN V0, A0, A3
9D00C244  10180042   ADDI ZERO, T8, 66
9D00C246  00421880   SRA V0, V0, 3
9D00C248  18800042   SB A0, 66(ZERO)
9D00C24A  00423B3C   SEH V0, V0
9D00C24C  3B3C2D2D   SH T9, 11565(GP)
9D00C24E      2D2D   ANDI V0, V0, 0xFF
9D00C250  00423B3C   SEH V0, V0
9D00C252  3B3CC844   SH T9, -14268(GP)
9D00C254      C844   SW V0, 16(SP)
9D00C256  FC9E0028   LW A0, 40(S8)
9D00C25A      0CE3   MOVE A3, V1
9D00C25C  76806990   JALS prefixI2c
9D00C25E      6990   LW V1, 0(S1)
9D00C260      0C00   NOP
9D00C262  F85E0018   SW V0, 24(S8)
156:                         portInfo->writeBuffer(portInfo, buffer, len); 
9D00C266  FC5C804C   LW V0, -32692(GP)
9D00C26A      6920   LW V0, 0(V0)
9D00C26C  FC9C804C   LW A0, -32692(GP)
9D00C270  FC7E0018   LW V1, 24(S8)
9D00C274  00633B3C   SEH V1, V1
9D00C276  3B3CFCBE   SH T9, -834(GP)
9D00C278  FCBE0028   LW A1, 40(S8)
9D00C27C      0CC3   MOVE A2, V1
9D00C27E      45E2   JALRS16 V0
9D00C280      0C00   NOP
9D00C282      CC49   B 0x9D00C316
9D00C284      0C00   NOP
157:                     }
158:                     else if(portInfo->periphType==PERIPH_TYPE.spi)
9D00C286  FC5C804C   LW V0, -32692(GP)
9D00C28A  14620040   LBU V1, 64(V0)
9D00C28C  00400C40   SRL V0, ZERO, 1
9D00C28E      0C40   MOVE V0, ZERO
9D00C290  B4430041   BNE V1, V0, 0x9D00C316
9D00C292  00410C00   SLL V0, AT, 1
9D00C294      0C00   NOP
159:                     {
160:                         len = prefixSpi(buffer, (char)x1, (char)x2, (char)(y1/8), (char)(y2/8));
9D00C296  345E0040   LHU V0, 64(S8)
9D00C298  00402D2D   PRECRQ_RS.PH.W A1, ZERO, V0
9D00C29A      2D2D   ANDI V0, V0, 0xFF
9D00C29C  00A23B3C   SEH A1, V0
9D00C29E  3B3C345E   SH T9, 13406(GP)
9D00C2A0  345E0048   LHU V0, 72(S8)
9D00C2A2  00482D2D   PRECRQ_RS.PH.W A1, T0, V0
9D00C2A4      2D2D   ANDI V0, V0, 0xFF
9D00C2A6  00C23B3C   SEH A2, V0
9D00C2A8  3B3C3C5E   SH T9, 15454(GP)
9D00C2AA  3C5E0044   LH V0, 68(S8)
9D00C2AE  30620007   ADDIU V1, V0, 7
9D00C2B2  90820000   SLTI A0, V0, 0
9D00C2B6  00831018   MOVN V0, V1, A0
9D00C2B8  10180042   ADDI ZERO, T8, 66
9D00C2BA  00421880   SRA V0, V0, 3
9D00C2BC  18800042   SB A0, 66(ZERO)
9D00C2BE  00423B3C   SEH V0, V0
9D00C2C0  3B3C2D2D   SH T9, 11565(GP)
9D00C2C2      2D2D   ANDI V0, V0, 0xFF
9D00C2C4  00623B3C   SEH V1, V0
9D00C2C6  3B3C3C5E   SH T9, 15454(GP)
9D00C2C8  3C5E004C   LH V0, 76(S8)
9D00C2CC  30820007   ADDIU A0, V0, 7
9D00C2D0  90E20000   SLTI A3, V0, 0
9D00C2D4  00E41018   MOVN V0, A0, A3
9D00C2D6  10180042   ADDI ZERO, T8, 66
9D00C2D8  00421880   SRA V0, V0, 3
9D00C2DA  18800042   SB A0, 66(ZERO)
9D00C2DC  00423B3C   SEH V0, V0
9D00C2DE  3B3C2D2D   SH T9, 11565(GP)
9D00C2E0      2D2D   ANDI V0, V0, 0xFF
9D00C2E2  00423B3C   SEH V0, V0
9D00C2E4  3B3CC844   SH T9, -14268(GP)
9D00C2E6      C844   SW V0, 16(SP)
9D00C2E8  FC9E0028   LW A0, 40(S8)
9D00C2EC      0CE3   MOVE A3, V1
9D00C2EE  76806948   JALS prefixSpi
9D00C2F0      6948   LW V0, 32(A0)
9D00C2F2      0C00   NOP
9D00C2F4  F85E0018   SW V0, 24(S8)
161:                         portInfo->writeBufferMode(portInfo, buffer, len, 1); 
9D00C2F8  FC5C804C   LW V0, -32692(GP)
9D00C2FC      6921   LW V0, 4(V0)
9D00C2FE  FC9C804C   LW A0, -32692(GP)
9D00C302  FC7E0018   LW V1, 24(S8)
9D00C306  00633B3C   SEH V1, V1
9D00C308  3B3CFCBE   SH T9, -834(GP)
9D00C30A  FCBE0028   LW A1, 40(S8)
9D00C30E      0CC3   MOVE A2, V1
9D00C310      EF81   LI A3, 1
9D00C312      45E2   JALRS16 V0
9D00C314      0C00   NOP
162:                     }
163:                     
164:                     
165:                     int count=(x2-x1 + 1) * ((y2-y1)/8 + 1);        //pocet bytes
9D00C316  3C7E0048   LH V1, 72(S8)
9D00C31A  3C5E0040   LH V0, 64(S8)
9D00C31C  00400527   BREAK
9D00C31E      0527   SUBU V0, V1, V0
9D00C320      6DA0   ADDIU V1, V0, 1
9D00C322  3C9E004C   LH A0, 76(S8)
9D00C326  3C5E0044   LH V0, 68(S8)
9D00C32A      0529   SUBU V0, A0, V0
9D00C32C  30820007   ADDIU A0, V0, 7
9D00C330  90A20000   SLTI A1, V0, 0
9D00C334  00A41018   MOVN V0, A0, A1
9D00C336  10180042   ADDI ZERO, T8, 66
9D00C338  00421880   SRA V0, V0, 3
9D00C33A  18806D20   SB A0, 27936(ZERO)
9D00C33C      6D20   ADDIU V0, V0, 1
9D00C33E  00438B3C   MULT V1, V0
9D00C340      8B3C   SB A2, 12(V1)
9D00C342      4642   MFLO V0
9D00C344  F85E001C   SW V0, 28(S8)
166:                     char patern=(char)color;                        //pouzije dolni byte parametru color
9D00C348  345E0050   LHU V0, 80(S8)
9D00C34C  185E002C   SB V0, 44(S8)
167:                     
168:                     if(portInfo->directMode==1)
9D00C350  FC5C804C   LW V0, -32692(GP)
9D00C354  1462003D   LBU V1, 61(V0)
9D00C358      ED01   LI V0, 1
9D00C35A  B4430022   BNE V1, V0, 0x9D00C3A2
9D00C35C  00220C00   SLL AT, V0, 1
9D00C35E      0C00   NOP
169:                     {
170:                         //pouze SPI
171:                         //direct write data >> SPIBUF
172:                         spi_Process(portInfo->portIndex, 1);         //ceka na dokonceni      
9D00C360  FC5C804C   LW V0, -32692(GP)
9D00C364  1442003C   LBU V0, 60(V0)
9D00C368      0C82   MOVE A0, V0
9D00C36A      EE81   LI A1, 1
9D00C36C  768070E8   JALS spi_Process
9D00C36E  70E80C00   XORI A3, T0, 3072
9D00C370      0C00   NOP
173:                 
174:                         //odesila patern primo do hw_bufferu (SPIxBUF) (SPI 8-bit mode)
175:                         int* spi_buf=portInfo->directModeHwBuffer;
9D00C372  FC5C804C   LW V0, -32692(GP)
9D00C376      6928   LW V0, 32(V0)
9D00C378  F85E0030   SW V0, 48(S8)
176:                         while(count>0)
9D00C37C      CC0B   B 0x9D00C394
9D00C37E      0C00   NOP
9D00C394  FC5E001C   LW V0, 28(S8)
9D00C398  40C2FFF2   BGTZ V0, 0x9D00C380
9D00C39A  FFF20C00   LW RA, 3072(S2)
9D00C39C      0C00   NOP
9D00C39E      CC44   B 0x9D00C428
9D00C3A0      0C00   NOP
177:                         {
178:                             *spi_buf=patern;
9D00C380  147E002C   LBU V1, 44(S8)
9D00C384  FC5E0030   LW V0, 48(S8)
9D00C386  0030E9A0   SUB SP, S0, AT
9D00C388      E9A0   SW V1, 0(V0)
179:                             count--;
9D00C38A  FC5E001C   LW V0, 28(S8)
9D00C38E      6D2E   ADDIU V0, V0, -1
9D00C390  F85E001C   SW V0, 28(S8)
180:                         }
181:                     }
182:                     else
183:                     {
184:                         //SPI, I2C
185:                         int a;
186:                         while(count>0)
9D00C3A2      CC3D   B 0x9D00C41E
9D00C3A4      0C00   NOP
9D00C41E  FC5E001C   LW V0, 28(S8)
9D00C422  40C2FFC0   BGTZ V0, 0x9D00C3A6
9D00C424  FFC00C00   LW S8, 3072(ZERO)
9D00C426      0C00   NOP
187:                         {
188:                             len=0;
9D00C3A6  F81E0018   SW ZERO, 24(S8)
9D00C3A8  00187680   OR T6, T8, ZERO
189:                             buffer=getBuffer(); 
9D00C3AA  768069F4   JALS getBuffer
9D00C3AC      69F4   LW V1, 16(A3)
9D00C3AE      0C00   NOP
9D00C3B0  F85E0028   SW V0, 40(S8)
190:                             
191:                             for(a=0; a<BUFFER_SIZE; a++)
9D00C3B4  F81E0020   SW ZERO, 32(S8)
9D00C3B8      CC1E   B 0x9D00C3F6
9D00C3BA      0C00   NOP
9D00C3EC  FC5E0020   LW V0, 32(S8)
9D00C3EE  00206D20   ADD T5, ZERO, AT
9D00C3F0      6D20   ADDIU V0, V0, 1
9D00C3F2  F85E0020   SW V0, 32(S8)
9D00C3F6  FC5E0020   LW V0, 32(S8)
9D00C3FA  90420100   SLTI V0, V0, 256
9D00C3FE  40A2FFDD   BNEZC V0, 0x9D00C3BC
9D00C400  FFDDFC5C   LW S8, -932(SP)
192:                             {
193:                                 buffer[a]=patern;
9D00C3BC  FC5E0020   LW V0, 32(S8)
9D00C3C0  FC7E0028   LW V1, 40(S8)
9D00C3C4      0526   ADDU V0, V1, V0
9D00C3C6  147E002C   LBU V1, 44(S8)
9D00C3C8  002C89A0   SUB S1, T4, AT
9D00C3CA      89A0   SB V1, 0(V0)
194:                                 len++;
9D00C3CC  FC5E0018   LW V0, 24(S8)
9D00C3CE  00186D20   ADD T5, T8, ZERO
9D00C3D0      6D20   ADDIU V0, V0, 1
9D00C3D2  F85E0018   SW V0, 24(S8)
195:                                 count--;
9D00C3D6  FC5E001C   LW V0, 28(S8)
9D00C3DA      6D2E   ADDIU V0, V0, -1
9D00C3DC  F85E001C   SW V0, 28(S8)
196:                                 if(count==0) { break; }
9D00C3E0  FC5E001C   LW V0, 28(S8)
9D00C3E4  40A20002   BNEZC V0, 0x9D00C3EC
9D00C3E6  0002CC0C   INS ZERO, V0, 16, 10
9D00C3E8      CC0C   B 0x9D00C402
9D00C3EA      0C00   NOP
197:                             }
198:                             
199:                             portInfo->writeBuffer(portInfo, buffer, len);
9D00C402  FC5C804C   LW V0, -32692(GP)
9D00C406      6920   LW V0, 0(V0)
9D00C408  FC9C804C   LW A0, -32692(GP)
9D00C40C  FC7E0018   LW V1, 24(S8)
9D00C410  00633B3C   SEH V1, V1
9D00C412  3B3CFCBE   SH T9, -834(GP)
9D00C414  FCBE0028   LW A1, 40(S8)
9D00C418      0CC3   MOVE A2, V1
9D00C41A      45E2   JALRS16 V0
9D00C41C      0C00   NOP
200:                         }
201:                     }
202:                     
203:                     freePort();
9D00C428  76806A2C   JALS freePort
9D00C42A      6A2C   LW A0, 48(V0)
9D00C42C      0C00   NOP
204:                 }
9D00C42E      0FBE   MOVE SP, S8
9D00C430      4BEF   LW RA, 60(SP)
9D00C432      4BCE   LW S8, 56(SP)
9D00C434      4C21   ADDIU SP, SP, 64
9D00C436      45BF   JRC RA
205:                 
206:                 static void drawLine(short x1, short y1, short x2, short y2, short w, short color)
207:                 {
9D00C438      4FB0   ADDIU SP, SP, -8
9D00C43A      CBC1   SW S8, 4(SP)
9D00C43C      0FDD   MOVE S8, SP
9D00C43E      0D04   MOVE T0, A0
9D00C440      0C85   MOVE A0, A1
9D00C442      0C66   MOVE V1, A2
9D00C444      0C47   MOVE V0, A3
9D00C446  391E0008   SH T0, 8(S8)
9D00C44A  389E000C   SH A0, 12(S8)
9D00C44E  387E0010   SH V1, 16(S8)
9D00C452  385E0014   SH V0, 20(S8)
208:                     //neumoznuje zobrazit cary
209:                 }
9D00C456      0FBE   MOVE SP, S8
9D00C458      4BC1   LW S8, 4(SP)
9D00C45A      4C05   ADDIU SP, SP, 8
9D00C45C      45BF   JRC RA
9D00C45E      0C00   NOP
210:                 
211:                 static void drawImage(IMAGE_SRC* da, short x, short y)
212:                 {
9D00C460      4FE5   ADDIU SP, SP, -56
9D00C462      CBED   SW RA, 52(SP)
9D00C464      CBCC   SW S8, 48(SP)
9D00C466      0FDD   MOVE S8, SP
9D00C468  F89E0038   SW A0, 56(S8)
9D00C46A  00380C65   MULEQ_S.W.PHR AT, T8, AT
9D00C46C      0C65   MOVE V1, A1
9D00C46E      0C46   MOVE V0, A2
9D00C470  387E003C   SH V1, 60(S8)
9D00C474  385E0040   SH V0, 64(S8)
213:                     //predpoklada, ze obrazek ma vysku 8/16/24/32/40/48/64
214:                     //y musi byt delitelne 8
215:                     if((y % 8 != 0)) { return; }
9D00C478  345E0040   LHU V0, 64(S8)
9D00C47C      2D25   ANDI V0, V0, 0x7
9D00C47E      2D2F   ANDI V0, V0, 0xFFFF
9D00C480  40E20002   BEQZC V0, 0x9D00C488
9D00C484      CD53   B 0x9D00C72C
9D00C486      0C00   NOP
216:                     
217:                     //cely obrazek musi byt na displeji, nepodporuje zobrazeni casti obrazku
218:                     if(x < 0) { return; }
9D00C488  3C5E003C   LH V0, 60(S8)
9D00C48C  40420003   BGEZ V0, 0x9D00C496
9D00C48E  00030C00   SLL ZERO, V1, 1
9D00C490      0C00   NOP
9D00C492      CD4C   B 0x9D00C72C
9D00C494      0C00   NOP
219:                     if((x + da->width) > Width) { return; }
9D00C496  3C7E003C   LH V1, 60(S8)
9D00C49A  FC5E0038   LW V0, 56(S8)
9D00C49E  3C420004   LH V0, 4(V0)
9D00C4A2      05A6   ADDU V1, V1, V0
9D00C4A4  3C5C801A   LH V0, -32742(GP)
9D00C4A8  00621350   SLT V0, V0, V1
9D00C4AA  135040E2   ADDI K0, S0, 16610
9D00C4AC  40E20002   BEQZC V0, 0x9D00C4B4
9D00C4AE  0002CD3D   REPL.PH T9, 0x2
9D00C4B0      CD3D   B 0x9D00C72C
9D00C4B2      0C00   NOP
220:                     if(y < 0) { return; }
9D00C4B4  3C5E0040   LH V0, 64(S8)
9D00C4B8  40420003   BGEZ V0, 0x9D00C4C2
9D00C4BA  00030C00   SLL ZERO, V1, 1
9D00C4BC      0C00   NOP
9D00C4BE      CD36   B 0x9D00C72C
9D00C4C0      0C00   NOP
221:                     if((y + da->height) > Height) { return; }
9D00C4C2  3C7E0040   LH V1, 64(S8)
9D00C4C6  FC5E0038   LW V0, 56(S8)
9D00C4CA  3C420006   LH V0, 6(V0)
9D00C4CE      05A6   ADDU V1, V1, V0
9D00C4D0  3C5C801C   LH V0, -32740(GP)
9D00C4D4  00621350   SLT V0, V0, V1
9D00C4D6  135040E2   ADDI K0, S0, 16610
9D00C4D8  40E20002   BEQZC V0, 0x9D00C4E0
9D00C4DA  0002CD27   BREAK
9D00C4DC      CD27   B 0x9D00C72C
9D00C4DE      0C00   NOP
222:                    
223:                     getPort();
9D00C4E0  76806A0E   JALS getPort
9D00C4E2      6A0E   LW A0, 56(S0)
9D00C4E4      0C00   NOP
224:                     
225:                     int len=0;
9D00C4E6  F81E0018   SW ZERO, 24(S8)
226:                     short start_x=x;
9D00C4EA  345E003C   LHU V0, 60(S8)
9D00C4EE  385E0020   SH V0, 32(S8)
227:                     short end_x=x + da->width - 1;
9D00C4F2  FC5E0038   LW V0, 56(S8)
9D00C4F6  3C420004   LH V0, 4(V0)
9D00C4FA      2DAF   ANDI V1, V0, 0xFFFF
9D00C4FC  345E003C   LHU V0, 60(S8)
9D00C500      0526   ADDU V0, V1, V0
9D00C502      2D2F   ANDI V0, V0, 0xFFFF
9D00C504      6D2E   ADDIU V0, V0, -1
9D00C506      2D2F   ANDI V0, V0, 0xFFFF
9D00C508  385E0022   SH V0, 34(S8)
228:                     short start_page=y/8;
9D00C50C  3C5E0040   LH V0, 64(S8)
9D00C510  30620007   ADDIU V1, V0, 7
9D00C514  90820000   SLTI A0, V0, 0
9D00C518  00831018   MOVN V0, V1, A0
9D00C51A  10180042   ADDI ZERO, T8, 66
9D00C51C  00421880   SRA V0, V0, 3
9D00C51E  1880385E   SB A0, 14430(ZERO)
9D00C520  385E0024   SH V0, 36(S8)
229:                     short end_page=y/8 + da->height/8 - 1;
9D00C524  3C5E0040   LH V0, 64(S8)
9D00C528  30620007   ADDIU V1, V0, 7
9D00C52C  90820000   SLTI A0, V0, 0
9D00C530  00831018   MOVN V0, V1, A0
9D00C532  10180042   ADDI ZERO, T8, 66
9D00C534  00421880   SRA V0, V0, 3
9D00C536  18800042   SB A0, 66(ZERO)
9D00C538  00423B3C   SEH V0, V0
9D00C53A  3B3C2DAF   SH T9, 11695(GP)
9D00C53C      2DAF   ANDI V1, V0, 0xFFFF
9D00C53E  FC5E0038   LW V0, 56(S8)
9D00C542  3C420006   LH V0, 6(V0)
9D00C546  30820007   ADDIU A0, V0, 7
9D00C54A  90A20000   SLTI A1, V0, 0
9D00C54E  00A41018   MOVN V0, A0, A1
9D00C550  10180042   ADDI ZERO, T8, 66
9D00C552  00421880   SRA V0, V0, 3
9D00C554  18800042   SB A0, 66(ZERO)
9D00C556  00423B3C   SEH V0, V0
9D00C558  3B3C2D2F   SH T9, 11567(GP)
9D00C55A      2D2F   ANDI V0, V0, 0xFFFF
9D00C55C      0526   ADDU V0, V1, V0
9D00C55E      2D2F   ANDI V0, V0, 0xFFFF
9D00C560      6D2E   ADDIU V0, V0, -1
9D00C562      2D2F   ANDI V0, V0, 0xFFFF
9D00C564  385E0026   SH V0, 38(S8)
9D00C566  00267680   OR T6, A2, AT
230:                     
231:                     char* buffer=getBuffer();
9D00C568  768069F4   JALS getBuffer
9D00C56A      69F4   LW V1, 16(A3)
9D00C56C      0C00   NOP
9D00C56E  F85E0028   SW V0, 40(S8)
232:                     if(portInfo->periphType==PERIPH_TYPE.i2c)
9D00C572  FC5C804C   LW V0, -32692(GP)
9D00C576  14620040   LBU V1, 64(V0)
9D00C57A      ED02   LI V0, 2
9D00C57C  B4430023   BNE V1, V0, 0x9D00C5C6
9D00C57E  00230C00   SLL AT, V1, 1
9D00C580      0C00   NOP
233:                     {
234:                         len = prefixI2c(buffer, start_x, end_x, start_page, end_page);
9D00C582  3CBE0020   LH A1, 32(S8)
9D00C586  3C7E0022   LH V1, 34(S8)
9D00C58A  3C5E0024   LH V0, 36(S8)
9D00C58E  3C9E0026   LH A0, 38(S8)
9D00C592      C884   SW A0, 16(SP)
9D00C594  FC9E0028   LW A0, 40(S8)
9D00C598      0CC3   MOVE A2, V1
9D00C59A      0CE2   MOVE A3, V0
9D00C59C  76806990   JALS prefixI2c
9D00C59E      6990   LW V1, 0(S1)
9D00C5A0      0C00   NOP
9D00C5A2  F85E0018   SW V0, 24(S8)
235:                         portInfo->writeBuffer(portInfo, buffer, len); 
9D00C5A6  FC5C804C   LW V0, -32692(GP)
9D00C5AA      6920   LW V0, 0(V0)
9D00C5AC  FC9C804C   LW A0, -32692(GP)
9D00C5B0  FC7E0018   LW V1, 24(S8)
9D00C5B4  00633B3C   SEH V1, V1
9D00C5B6  3B3CFCBE   SH T9, -834(GP)
9D00C5B8  FCBE0028   LW A1, 40(S8)
9D00C5BC      0CC3   MOVE A2, V1
9D00C5BE      45E2   JALRS16 V0
9D00C5C0      0C00   NOP
9D00C5C2      CC2A   B 0x9D00C618
9D00C5C4      0C00   NOP
236:                     }
237:                     else if(portInfo->periphType==PERIPH_TYPE.spi)
9D00C5C6  FC5C804C   LW V0, -32692(GP)
9D00C5CA  14620040   LBU V1, 64(V0)
9D00C5CC  00400C40   SRL V0, ZERO, 1
9D00C5CE      0C40   MOVE V0, ZERO
9D00C5D0  B4430022   BNE V1, V0, 0x9D00C618
9D00C5D2  00220C00   SLL AT, V0, 1
9D00C5D4      0C00   NOP
238:                     {
239:                         len = prefixSpi(buffer, start_x, end_x, start_page, end_page);
9D00C5D6  3CBE0020   LH A1, 32(S8)
9D00C5DA  3C7E0022   LH V1, 34(S8)
9D00C5DE  3C5E0024   LH V0, 36(S8)
9D00C5E2  3C9E0026   LH A0, 38(S8)
9D00C5E6      C884   SW A0, 16(SP)
9D00C5E8  FC9E0028   LW A0, 40(S8)
9D00C5EC      0CC3   MOVE A2, V1
9D00C5EE      0CE2   MOVE A3, V0
9D00C5F0  76806948   JALS prefixSpi
9D00C5F2      6948   LW V0, 32(A0)
9D00C5F4      0C00   NOP
9D00C5F6  F85E0018   SW V0, 24(S8)
240:                         portInfo->writeBufferMode(portInfo, buffer, len, 1); 
9D00C5FA  FC5C804C   LW V0, -32692(GP)
9D00C5FE      6921   LW V0, 4(V0)
9D00C600  FC9C804C   LW A0, -32692(GP)
9D00C604  FC7E0018   LW V1, 24(S8)
9D00C608  00633B3C   SEH V1, V1
9D00C60A  3B3CFCBE   SH T9, -834(GP)
9D00C60C  FCBE0028   LW A1, 40(S8)
9D00C610      0CC3   MOVE A2, V1
9D00C612      EF81   LI A3, 1
9D00C614      45E2   JALRS16 V0
9D00C616      0C00   NOP
241:                     }
242:                     
243:                     if(portInfo->directMode==1)
9D00C618  FC5C804C   LW V0, -32692(GP)
9D00C61C  1462003D   LBU V1, 61(V0)
9D00C620      ED01   LI V0, 1
9D00C622  B443002D   BNE V1, V0, 0x9D00C680
9D00C624  002D0C00   SLL AT, T5, 1
9D00C626      0C00   NOP
244:                     {
245:                         //direct write data >> SPIBUF
246:                         spi_Process(portInfo->portIndex, 1);         //ceka na dokonceni      
9D00C628  FC5C804C   LW V0, -32692(GP)
9D00C62C  1442003C   LBU V0, 60(V0)
9D00C630      0C82   MOVE A0, V0
9D00C632      EE81   LI A1, 1
9D00C634  768070E8   JALS spi_Process
9D00C636  70E80C00   XORI A3, T0, 3072
9D00C638      0C00   NOP
247:                         
248:                         //odesila data znaku primo do hw_bufferu (SPIxBUF) (SPI 8-bit mode)
249:                         char* a;
250:                         int* spi_buf=portInfo->directModeHwBuffer;
9D00C63A  FC5C804C   LW V0, -32692(GP)
9D00C63E      6928   LW V0, 32(V0)
9D00C640  F85E002C   SW V0, 44(S8)
251:                         for(a=da->srcStartPosition; a < da->srcAfter; a++)
9D00C644  FC5E0038   LW V0, 56(S8)
9D00C648      692A   LW V0, 40(V0)
9D00C64A  F85E001C   SW V0, 28(S8)
9D00C64C  001CCC0D   ADDQ_S.PH T9, GP, ZERO
9D00C64E      CC0D   B 0x9D00C66A
9D00C650      0C00   NOP
9D00C660  FC5E001C   LW V0, 28(S8)
9D00C662  001C6D20   ADD T5, GP, ZERO
9D00C664      6D20   ADDIU V0, V0, 1
9D00C666  F85E001C   SW V0, 28(S8)
9D00C66A  FC5E0038   LW V0, 56(S8)
9D00C66E      69AB   LW V1, 44(V0)
9D00C670  FC5E001C   LW V0, 28(S8)
9D00C674  00621390   SLTU V0, V0, V1
9D00C676  139040A2   ADDI GP, S0, 16546
9D00C678  40A2FFEB   BNEZC V0, 0x9D00C652
9D00C67A  FFEBCC54   LW RA, -13228(T3)
9D00C67C      CC54   B 0x9D00C726
9D00C67E      0C00   NOP
252:                         {
253:                             *spi_buf=*a;
9D00C652  FC5E001C   LW V0, 28(S8)
9D00C654  001C0920   ADD AT, GP, ZERO
9D00C656      0920   LBU V0, 0(V0)
9D00C658      0C62   MOVE V1, V0
9D00C65A  FC5E002C   LW V0, 44(S8)
9D00C65C  002CE9A0   SUB SP, T4, AT
9D00C65E      E9A0   SW V1, 0(V0)
254:                         }
255:                     }
256:                     else
257:                     {
258:                         //vlozi data znaku do bufferu a ten odesila
259:                         da->srcPosition=da->srcStartPosition;
9D00C680  FC5E0038   LW V0, 56(S8)
9D00C684      69AA   LW V1, 40(V0)
9D00C686  FC5E0038   LW V0, 56(S8)
9D00C68A      E9A4   SW V1, 16(V0)
260:                         da->eof=0;
9D00C68C  FC5E0038   LW V0, 56(S8)
9D00C690  18020049   SB ZERO, 73(V0)
261:                         
262:                         do
263:                         {
264:                             len=0;
9D00C694  F81E0018   SW ZERO, 24(S8)
9D00C696  00187680   OR T6, T8, ZERO
265:                             buffer=getBuffer();
9D00C698  768069F4   JALS getBuffer
9D00C69A      69F4   LW V1, 16(A3)
9D00C69C      0C00   NOP
9D00C69E  F85E0028   SW V0, 40(S8)
9D00C6A0  0028CC27   BREAK
266:                             
267:                             while(len < BUFFER_SIZE)
9D00C6A2      CC27   B 0x9D00C6F2
9D00C6A4      0C00   NOP
9D00C6F2  FC5E0018   LW V0, 24(S8)
9D00C6F6  90420100   SLTI V0, V0, 256
9D00C6FA  40A2FFD4   BNEZC V0, 0x9D00C6A6
9D00C6FC  FFD4FC5C   LW S8, -932(S4)
268:                             {
269:                                 buffer[len]=*da->srcPosition;
9D00C6A6  FC5E0018   LW V0, 24(S8)
9D00C6AA  FC7E0028   LW V1, 40(S8)
9D00C6AE      0526   ADDU V0, V1, V0
9D00C6B0  FC7E0038   LW V1, 56(S8)
9D00C6B4      69B4   LW V1, 16(V1)
9D00C6B6      09B0   LBU V1, 0(V1)
9D00C6B8      89A0   SB V1, 0(V0)
270:                                 da->srcPosition++;
9D00C6BA  FC5E0038   LW V0, 56(S8)
9D00C6BE      6924   LW V0, 16(V0)
9D00C6C0      6DA0   ADDIU V1, V0, 1
9D00C6C2  FC5E0038   LW V0, 56(S8)
9D00C6C6      E9A4   SW V1, 16(V0)
271:                                 len++;
9D00C6C8  FC5E0018   LW V0, 24(S8)
9D00C6CA  00186D20   ADD T5, T8, ZERO
9D00C6CC      6D20   ADDIU V0, V0, 1
9D00C6CE  F85E0018   SW V0, 24(S8)
272:                             
273:                                 if(da->srcPosition == da->srcAfter)
9D00C6D2  FC5E0038   LW V0, 56(S8)
9D00C6D6      69A4   LW V1, 16(V0)
9D00C6D8  FC5E0038   LW V0, 56(S8)
9D00C6DC      692B   LW V0, 44(V0)
9D00C6DE  B4430008   BNE V1, V0, 0x9D00C6F2
9D00C6E0  00080C00   SLL ZERO, T0, 1
9D00C6E2      0C00   NOP
274:                                 {
275:                                     da->eof=1; 
9D00C6E4  FC5E0038   LW V0, 56(S8)
9D00C6E8      ED81   LI V1, 1
9D00C6EA  18620049   SB V1, 73(V0)
9D00C6EC  0049CC07   BREAK
276:                                     break;
9D00C6EE      CC07   B 0x9D00C6FE
9D00C6F0      0C00   NOP
277:                                 }
278:                             }
279:                             
280:                             portInfo->writeBuffer(portInfo, buffer, len);
9D00C6FE  FC5C804C   LW V0, -32692(GP)
9D00C702      6920   LW V0, 0(V0)
9D00C704  FC9C804C   LW A0, -32692(GP)
9D00C708  FC7E0018   LW V1, 24(S8)
9D00C70C  00633B3C   SEH V1, V1
9D00C70E  3B3CFCBE   SH T9, -834(GP)
9D00C710  FCBE0028   LW A1, 40(S8)
9D00C714      0CC3   MOVE A2, V1
9D00C716      45E2   JALRS16 V0
9D00C718      0C00   NOP
281:                             
282:                         } while (da->eof == 0);
9D00C71A  FC5E0038   LW V0, 56(S8)
9D00C71E  14420049   LBU V0, 73(V0)
9D00C722  40E2FFB7   BEQZC V0, 0x9D00C694
9D00C724  FFB77680   LW SP, 30336(S7)
283:                     }
284:                 
285:                     freePort();
9D00C726  76806A2C   JALS freePort
9D00C728      6A2C   LW A0, 48(V0)
9D00C72A      0C00   NOP
286:                 }
9D00C72C      0FBE   MOVE SP, S8
9D00C72E      4BED   LW RA, 52(SP)
9D00C730      4BCC   LW S8, 48(SP)
9D00C732      4C1D   ADDIU SP, SP, 56
9D00C734      45BF   JRC RA
9D00C736      0C00   NOP
287:                 
288:                 static void drawPoint(short x, short y, short color)
289:                 {
9D00C738      4FB0   ADDIU SP, SP, -8
9D00C73A      CBC1   SW S8, 4(SP)
9D00C73C      0FDD   MOVE S8, SP
9D00C73E      0C65   MOVE V1, A1
9D00C740      0C46   MOVE V0, A2
9D00C742  389E0008   SH A0, 8(S8)
9D00C746  387E000C   SH V1, 12(S8)
9D00C74A  385E0010   SH V0, 16(S8)
290:                     //neumoznuje zobrazit jednotlive body
291:                 
292:                 }
9D00C74E      0FBE   MOVE SP, S8
9D00C750      4BC1   LW S8, 4(SP)
9D00C752      4C05   ADDIU SP, SP, 8
9D00C754      45BF   JRC RA
9D00C756      0C00   NOP
293:                 
294:                 static short textWidth(char* text, IMAGE_SRC* font)
295:                 {
9D00C758      4FED   ADDIU SP, SP, -40
9D00C75A      CBE9   SW RA, 36(SP)
9D00C75C      CBC8   SW S8, 32(SP)
9D00C75E      0FDD   MOVE S8, SP
9D00C760  F89E0028   SW A0, 40(S8)
9D00C764  F8BE002C   SW A1, 44(S8)
296:                     int a, w=0;
9D00C768  F81E0014   SW ZERO, 20(S8)
297:                     int l=strLen(text);
9D00C76C  FC9E0028   LW A0, 40(S8)
9D00C76E  00287680   OR T6, T0, AT
9D00C770  76808024   JALS strLen
9D00C774      0C00   NOP
9D00C776  F85E0018   SW V0, 24(S8)
298:                     for(a=0; a<l; a++)
9D00C77A  F81E0010   SW ZERO, 16(S8)
9D00C77E      CC1B   B 0x9D00C7B6
9D00C780      0C00   NOP
9D00C7AC  FC5E0010   LW V0, 16(S8)
9D00C7AE  00106D20   ADD T5, S0, ZERO
9D00C7B0      6D20   ADDIU V0, V0, 1
9D00C7B2  F85E0010   SW V0, 16(S8)
9D00C7B6  FC7E0010   LW V1, 16(S8)
9D00C7BA  FC5E0018   LW V0, 24(S8)
9D00C7BE  00431350   SLT V0, V1, V0
9D00C7C0  135040A2   ADDI K0, S0, 16546
9D00C7C2  40A2FFDE   BNEZC V0, 0x9D00C782
9D00C7C4  FFDEFC5E   LW S8, -930(S8)
299:                     {
300:                         fontCharParam(font, text[a]);
9D00C782  FC5E0010   LW V0, 16(S8)
9D00C786  FC7E0028   LW V1, 40(S8)
9D00C78A      0526   ADDU V0, V1, V0
9D00C78C      0920   LBU V0, 0(V0)
9D00C78E  FC9E002C   LW A0, 44(S8)
9D00C792      0CA2   MOVE A1, V0
9D00C794  7680788A   JALS fontCharParam
9D00C796  788A0C00   ADDIUPC AT, 2633728
9D00C798      0C00   NOP
301:                         w+=font->width;
9D00C79A  FC5E002C   LW V0, 44(S8)
9D00C79E  3C420004   LH V0, 4(V0)
9D00C7A2  FC7E0014   LW V1, 20(S8)
9D00C7A6      0526   ADDU V0, V1, V0
9D00C7A8  F85E0014   SW V0, 20(S8)
302:                     }     
303:                     
304:                     return w;
9D00C7C6  FC5E0014   LW V0, 20(S8)
9D00C7CA  00423B3C   SEH V0, V0
9D00C7CC  3B3C0FBE   SH T9, 4030(GP)
305:                 }
9D00C7CE      0FBE   MOVE SP, S8
9D00C7D0      4BE9   LW RA, 36(SP)
9D00C7D2      4BC8   LW S8, 32(SP)
9D00C7D4      4C15   ADDIU SP, SP, 40
9D00C7D6      45BF   JRC RA
306:                 
307:                 static void clear(short color)
308:                 {
9D00C7D8      4FF1   ADDIU SP, SP, -32
9D00C7DA      CBE7   SW RA, 28(SP)
9D00C7DC      CBC6   SW S8, 24(SP)
9D00C7DE      0FDD   MOVE S8, SP
9D00C7E0      0C44   MOVE V0, A0
9D00C7E2  385E0020   SH V0, 32(S8)
309:                     fillBox(0, 0, Width-1, Height-1, color);
9D00C7E6  3C5C801A   LH V0, -32742(GP)
9D00C7EA      2D2F   ANDI V0, V0, 0xFFFF
9D00C7EC      6D2E   ADDIU V0, V0, -1
9D00C7EE      2D2F   ANDI V0, V0, 0xFFFF
9D00C7F0  00623B3C   SEH V1, V0
9D00C7F2  3B3C3C5C   SH T9, 15452(GP)
9D00C7F4  3C5C801C   LH V0, -32740(GP)
9D00C7F8      2D2F   ANDI V0, V0, 0xFFFF
9D00C7FA      6D2E   ADDIU V0, V0, -1
9D00C7FC      2D2F   ANDI V0, V0, 0xFFFF
9D00C7FE  00423B3C   SEH V0, V0
9D00C800  3B3C3C9E   SH T9, 15518(GP)
9D00C802  3C9E0020   LH A0, 32(S8)
9D00C806      C884   SW A0, 16(SP)
9D00C808      0C80   MOVE A0, ZERO
9D00C80A      0CA0   MOVE A1, ZERO
9D00C80C      0CC3   MOVE A2, V1
9D00C80E      0CE2   MOVE A3, V0
9D00C810  76806060   JALS fillBox
9D00C812  60600C00   LWL V1, -1024(ZERO)
9D00C814      0C00   NOP
310:                 }
9D00C816      0FBE   MOVE SP, S8
9D00C818      4BE7   LW RA, 28(SP)
9D00C81A      4BC6   LW S8, 24(SP)
9D00C81C      4C11   ADDIU SP, SP, 32
9D00C81E      45BF   JRC RA
311:                 
312:                 static void initDisplay(PORT_INFO* pi)
313:                 {
9D00C820      4FB0   ADDIU SP, SP, -8
9D00C822      CBC1   SW S8, 4(SP)
9D00C824      0FDD   MOVE S8, SP
9D00C826  F89E0008   SW A0, 8(S8)
314:                     portInfo=pi;
9D00C82A  FC5E0008   LW V0, 8(S8)
9D00C82E  F85C804C   SW V0, -32692(GP)
315:                     portInfo->eventFn=&eventDC;
9D00C832  FC5C804C   LW V0, -32692(GP)
9D00C836  41A39D01   LUI V1, 0x9D01
9D00C838  9D013063   LWC1 F8, 12387(AT)
9D00C83A  3063D495   ADDIU V1, V1, -11115
9D00C83C  D495E9A5   J 0x992BD34A
9D00C83E      E9A5   SW V1, 20(V0)
316:                     
317:                     isInitialized=0;
9D00C840  181C8048   SB ZERO, -32696(GP)
318:                     
319:                 #ifndef SIMULATOR    
320:                     dinit();
321:                 #endif    
322:                    
323:                     isInitialized=1;
9D00C844      ED01   LI V0, 1
9D00C846  185C8048   SB V0, -32696(GP)
324:                 }
9D00C84A      0FBE   MOVE SP, S8
9D00C84C      4BC1   LW S8, 4(SP)
9D00C84E      4C05   ADDIU SP, SP, 8
9D00C850      45BF   JRC RA
9D00C852      0C00   NOP
325:                 
326:                 static void setOrientation(char x)
327:                 {
9D00C854      4FB0   ADDIU SP, SP, -8
9D00C856      CBC1   SW S8, 4(SP)
9D00C858      0FDD   MOVE S8, SP
9D00C85A      0C44   MOVE V0, A0
9D00C85C  185E0008   SB V0, 8(S8)
328:                     //nelze menit orientaci
329:                 }
9D00C860      0FBE   MOVE SP, S8
9D00C862      4BC1   LW S8, 4(SP)
9D00C864      4C05   ADDIU SP, SP, 8
9D00C866      45BF   JRC RA
330:                 
331:                 static char getOrientation()
332:                 {
9D00C868      4FB0   ADDIU SP, SP, -8
9D00C86A      CBC1   SW S8, 4(SP)
9D00C86C      0FDD   MOVE S8, SP
333:                     return 0;
9D00C86E      0C40   MOVE V0, ZERO
334:                 }
9D00C870      0FBE   MOVE SP, S8
9D00C872      4BC1   LW S8, 4(SP)
9D00C874      4C05   ADDIU SP, SP, 8
9D00C876      45BF   JRC RA
335:                 
336:                 static void setBrightness(char val)
337:                 {
9D00C878      4FF1   ADDIU SP, SP, -32
9D00C87A      CBE7   SW RA, 28(SP)
9D00C87C      CBC6   SW S8, 24(SP)
9D00C87E      0FDD   MOVE S8, SP
9D00C880      0C44   MOVE V0, A0
9D00C882  185E0020   SB V0, 32(S8)
9D00C884  00207680   OR T6, ZERO, AT
338:                     getPort();
9D00C886  76806A0E   JALS getPort
9D00C888      6A0E   LW A0, 56(S0)
9D00C88A      0C00   NOP
339:                     char* buffer=getBuffer();  
9D00C88C  768069F4   JALS getBuffer
9D00C88E      69F4   LW V1, 16(A3)
9D00C890      0C00   NOP
9D00C892  F85E0010   SW V0, 16(S8)
340:                 
341:                     if(portInfo->periphType==PERIPH_TYPE.spi)
9D00C896  FC5C804C   LW V0, -32692(GP)
9D00C89A  14620040   LBU V1, 64(V0)
9D00C89C  00400C40   SRL V0, ZERO, 1
9D00C89E      0C40   MOVE V0, ZERO
9D00C8A0  B443001F   BNE V1, V0, 0x9D00C8E2
9D00C8A2  001F0C00   SLL ZERO, RA, 1
9D00C8A4      0C00   NOP
342:                     {
343:                         buffer[0]=0b00000001;                       //control byte, nastavi DC=0
9D00C8A6  FC5E0010   LW V0, 16(S8)
9D00C8AA      ED81   LI V1, 1
9D00C8AC      89A0   SB V1, 0(V0)
344:                         buffer[1]=0x81;                             //0x81 = Contrast
9D00C8AE  FC5E0010   LW V0, 16(S8)
9D00C8B0  00106D20   ADD T5, S0, ZERO
9D00C8B2      6D20   ADDIU V0, V0, 1
9D00C8B4  3060FF81   ADDIU V1, ZERO, -127
9D00C8B6  FF8189A0   LW GP, -30304(AT)
9D00C8B8      89A0   SB V1, 0(V0)
345:                         buffer[2]=val;                              //param 0 ... 0xFF
9D00C8BA  FC5E0010   LW V0, 16(S8)
9D00C8BE      4C44   ADDIU V0, V0, 2
9D00C8C0  147E0020   LBU V1, 32(S8)
9D00C8C2  002089A0   SUB S1, ZERO, AT
9D00C8C4      89A0   SB V1, 0(V0)
346:                         portInfo->writeBufferMode(portInfo, buffer, 3, 1);
9D00C8C6  FC5C804C   LW V0, -32692(GP)
9D00C8CA      6921   LW V0, 4(V0)
9D00C8CC  FC7C804C   LW V1, -32692(GP)
9D00C8D0      0C83   MOVE A0, V1
9D00C8D2  FCBE0010   LW A1, 16(S8)
9D00C8D6      EF03   LI A2, 3
9D00C8D8      EF81   LI A3, 1
9D00C8DA      45E2   JALRS16 V0
9D00C8DC      0C00   NOP
9D00C8DE      CC23   B 0x9D00C926
9D00C8E0      0C00   NOP
347:                     }
348:                     else if(portInfo->periphType==PERIPH_TYPE.i2c)
9D00C8E2  FC5C804C   LW V0, -32692(GP)
9D00C8E6  14620040   LBU V1, 64(V0)
9D00C8EA      ED02   LI V0, 2
9D00C8EC  B443001B   BNE V1, V0, 0x9D00C926
9D00C8EE  001B0C00   SLL ZERO, K1, 1
9D00C8F0      0C00   NOP
349:                     {
350:                         buffer[0]=0x0;                              //control byte, nastavi DC=0
9D00C8F2  FC5E0010   LW V0, 16(S8)
9D00C8F6      8820   SB S0, 0(V0)
351:                         buffer[1]=0x81;                             //0x81 = Contrast
9D00C8F8  FC5E0010   LW V0, 16(S8)
9D00C8FA  00106D20   ADD T5, S0, ZERO
9D00C8FC      6D20   ADDIU V0, V0, 1
9D00C8FE  3060FF81   ADDIU V1, ZERO, -127
9D00C900  FF8189A0   LW GP, -30304(AT)
9D00C902      89A0   SB V1, 0(V0)
352:                         buffer[2]=val;                              //param 0 ... 0xFF
9D00C904  FC5E0010   LW V0, 16(S8)
9D00C908      4C44   ADDIU V0, V0, 2
9D00C90A  147E0020   LBU V1, 32(S8)
9D00C90C  002089A0   SUB S1, ZERO, AT
9D00C90E      89A0   SB V1, 0(V0)
353:                         portInfo->writeBuffer(portInfo, buffer, 3);        
9D00C910  FC5C804C   LW V0, -32692(GP)
9D00C914      6920   LW V0, 0(V0)
9D00C916  FC7C804C   LW V1, -32692(GP)
9D00C91A      0C83   MOVE A0, V1
9D00C91C  FCBE0010   LW A1, 16(S8)
9D00C920      EF03   LI A2, 3
9D00C922      45E2   JALRS16 V0
9D00C924      0C00   NOP
354:                     }
355:                 
356:                     freePort();
9D00C926  76806A2C   JALS freePort
9D00C928      6A2C   LW A0, 48(V0)
9D00C92A      0C00   NOP
357:                 }
9D00C92C      0FBE   MOVE SP, S8
9D00C92E      4BE7   LW RA, 28(SP)
9D00C930      4BC6   LW S8, 24(SP)
9D00C932      4C11   ADDIU SP, SP, 32
9D00C934      45BF   JRC RA
9D00C936      0C00   NOP
358:                 
359:                 static void controlDisplay(char on, char sleep, char bl, char inv)
360:                 {
9D00C938      4FF1   ADDIU SP, SP, -32
9D00C93A      CBE7   SW RA, 28(SP)
9D00C93C      CBC6   SW S8, 24(SP)
9D00C93E      0FDD   MOVE S8, SP
9D00C940      0D04   MOVE T0, A0
9D00C942      0C85   MOVE A0, A1
9D00C944      0C66   MOVE V1, A2
9D00C946      0C47   MOVE V0, A3
9D00C948  191E0020   SB T0, 32(S8)
9D00C94C  189E0024   SB A0, 36(S8)
9D00C950  187E0028   SB V1, 40(S8)
9D00C954  185E002C   SB V0, 44(S8)
9D00C956  002C7680   OR T6, T4, AT
361:                     //hodnota 0xFF = bez zmeny, 0=OFF(vypni), 1=ON(zapni)
362:                     //on (display) nastavuje sleep mode (on=1 - SLEEP OFF, on=0 - SLEEP ON)
363:                     //sleep - nastavi/ukonci sleep mode (sleep=1 - SLEEP ON, sleep=0 - SLEEP OFF)
364:                     //ON i SLEEP naji stejnou fci, ale pracuji opacne
365:                     //bl (backLight) nema zadnou fci
366:                     
367:                     getPort();
9D00C958  76806A0E   JALS getPort
9D00C95A      6A0E   LW A0, 56(S0)
9D00C95C      0C00   NOP
368:                     char* buffer;
369:                     
370:                     if(on != 0xFF)
9D00C95E  147E0020   LBU V1, 32(S8)
9D00C960  00203040   SRL AT, ZERO, 6
9D00C962  304000FF   ADDIU V0, ZERO, 255
9D00C966  94430061   BEQ V1, V0, 0x9D00CA2C
9D00C968  00610C00   SLL V1, AT, 1
9D00C96A      0C00   NOP
371:                     {
372:                         buffer=getBuffer();
9D00C96C  768069F4   JALS getBuffer
9D00C96E      69F4   LW V1, 16(A3)
9D00C970      0C00   NOP
9D00C972  F85E0010   SW V0, 16(S8)
373:                         if(portInfo->periphType==PERIPH_TYPE.spi)
9D00C976  FC5C804C   LW V0, -32692(GP)
9D00C97A  14620040   LBU V1, 64(V0)
9D00C97C  00400C40   SRL V0, ZERO, 1
9D00C97E      0C40   MOVE V0, ZERO
9D00C980  B4430029   BNE V1, V0, 0x9D00C9D6
9D00C982  00290C00   SLL AT, T1, 1
9D00C984      0C00   NOP
374:                         {
375:                             //SPI
376:                             if(on==0)
9D00C986  145E0020   LBU V0, 32(S8)
9D00C98A  40A2000C   BNEZC V0, 0x9D00C9A6
377:                             {
378:                                 //0 = display off (sleep ON)
379:                                 buffer[0]=0b00000001;                       //control byte
9D00C98E  FC5E0010   LW V0, 16(S8)
9D00C992      ED81   LI V1, 1
9D00C994      89A0   SB V1, 0(V0)
380:                                 buffer[1]=0xAE;                             //0xAE = sleep ON
9D00C996  FC5E0010   LW V0, 16(S8)
9D00C998  00106D20   ADD T5, S0, ZERO
9D00C99A      6D20   ADDIU V0, V0, 1
9D00C99C  3060FFAE   ADDIU V1, ZERO, -82
9D00C99E  FFAE89A0   LW SP, -30304(T6)
9D00C9A0      89A0   SB V1, 0(V0)
9D00C9A2      CC0B   B 0x9D00C9BA
9D00C9A4      0C00   NOP
381:                             }
382:                             else
383:                             {
384:                                 //1 = display on (sleep OFF)
385:                                 buffer[0]=0b00000001;                       //control byte
9D00C9A6  FC5E0010   LW V0, 16(S8)
9D00C9AA      ED81   LI V1, 1
9D00C9AC      89A0   SB V1, 0(V0)
386:                                 buffer[1]=0xAF;                             //0xAF = sleep OFF
9D00C9AE  FC5E0010   LW V0, 16(S8)
9D00C9B0  00106D20   ADD T5, S0, ZERO
9D00C9B2      6D20   ADDIU V0, V0, 1
9D00C9B4  3060FFAF   ADDIU V1, ZERO, -81
9D00C9B6  FFAF89A0   LW SP, -30304(T7)
9D00C9B8      89A0   SB V1, 0(V0)
387:                             }   
388:                             portInfo->writeBufferMode(portInfo, buffer, 2, 1);
9D00C9BA  FC5C804C   LW V0, -32692(GP)
9D00C9BE      6921   LW V0, 4(V0)
9D00C9C0  FC7C804C   LW V1, -32692(GP)
9D00C9C4      0C83   MOVE A0, V1
9D00C9C6  FCBE0010   LW A1, 16(S8)
9D00C9CA      EF02   LI A2, 2
9D00C9CC      EF81   LI A3, 1
9D00C9CE      45E2   JALRS16 V0
9D00C9D0      0C00   NOP
9D00C9D2      CC2C   B 0x9D00CA2C
9D00C9D4      0C00   NOP
389:                         }
390:                         else if(portInfo->periphType==PERIPH_TYPE.i2c)
9D00C9D6  FC5C804C   LW V0, -32692(GP)
9D00C9DA  14620040   LBU V1, 64(V0)
9D00C9DE      ED02   LI V0, 2
9D00C9E0  B4430024   BNE V1, V0, 0x9D00CA2C
9D00C9E2  00240C00   SLL AT, A0, 1
9D00C9E4      0C00   NOP
391:                         {
392:                             //I2C
393:                             if(on==0)
9D00C9E6  145E0020   LBU V0, 32(S8)
9D00C9EA  40A2000B   BNEZC V0, 0x9D00CA04
394:                             {
395:                                 //0 = display off (sleep ON)
396:                                 buffer[0]=0x0;                              //control byte
9D00C9EE  FC5E0010   LW V0, 16(S8)
9D00C9F2      8820   SB S0, 0(V0)
397:                                 buffer[1]=0xAE;                             //0xAE = sleep ON
9D00C9F4  FC5E0010   LW V0, 16(S8)
9D00C9F6  00106D20   ADD T5, S0, ZERO
9D00C9F8      6D20   ADDIU V0, V0, 1
9D00C9FA  3060FFAE   ADDIU V1, ZERO, -82
9D00C9FC  FFAE89A0   LW SP, -30304(T6)
9D00C9FE      89A0   SB V1, 0(V0)
9D00CA00      CC0A   B 0x9D00CA16
9D00CA02      0C00   NOP
398:                             }
399:                             else
400:                             {
401:                                 //1 = display on (sleep OFF)
402:                                 buffer[0]=0x0;                              //control byte
9D00CA04  FC5E0010   LW V0, 16(S8)
9D00CA08      8820   SB S0, 0(V0)
403:                                 buffer[1]=0xAF;                             //0xAF = sleep OFF
9D00CA0A  FC5E0010   LW V0, 16(S8)
9D00CA0C  00106D20   ADD T5, S0, ZERO
9D00CA0E      6D20   ADDIU V0, V0, 1
9D00CA10  3060FFAF   ADDIU V1, ZERO, -81
9D00CA12  FFAF89A0   LW SP, -30304(T7)
9D00CA14      89A0   SB V1, 0(V0)
404:                             }   
405:                             portInfo->writeBuffer(portInfo, buffer, 2);            
9D00CA16  FC5C804C   LW V0, -32692(GP)
9D00CA1A      6920   LW V0, 0(V0)
9D00CA1C  FC7C804C   LW V1, -32692(GP)
9D00CA20      0C83   MOVE A0, V1
9D00CA22  FCBE0010   LW A1, 16(S8)
9D00CA26      EF02   LI A2, 2
9D00CA28      45E2   JALRS16 V0
9D00CA2A      0C00   NOP
406:                         }
407:                     }
408:                     
409:                     if(sleep != 0xFF)
9D00CA2C  147E0024   LBU V1, 36(S8)
9D00CA2E  00243040   SRL AT, A0, 6
9D00CA30  304000FF   ADDIU V0, ZERO, 255
9D00CA34  94430061   BEQ V1, V0, 0x9D00CAFA
9D00CA36  00610C00   SLL V1, AT, 1
9D00CA38      0C00   NOP
410:                     {
411:                         buffer=getBuffer();
9D00CA3A  768069F4   JALS getBuffer
9D00CA3C      69F4   LW V1, 16(A3)
9D00CA3E      0C00   NOP
9D00CA40  F85E0010   SW V0, 16(S8)
412:                         if(portInfo->periphType==PERIPH_TYPE.spi)
9D00CA44  FC5C804C   LW V0, -32692(GP)
9D00CA48  14620040   LBU V1, 64(V0)
9D00CA4A  00400C40   SRL V0, ZERO, 1
9D00CA4C      0C40   MOVE V0, ZERO
9D00CA4E  B4430029   BNE V1, V0, 0x9D00CAA4
9D00CA50  00290C00   SLL AT, T1, 1
9D00CA52      0C00   NOP
413:                         {      
414:                             //SPI
415:                             if(on==0)
9D00CA54  145E0020   LBU V0, 32(S8)
9D00CA58  40A2000C   BNEZC V0, 0x9D00CA74
416:                             {
417:                                 //0 = sleep off
418:                                 buffer[0]=0b00000001;                       //control byte
9D00CA5C  FC5E0010   LW V0, 16(S8)
9D00CA60      ED81   LI V1, 1
9D00CA62      89A0   SB V1, 0(V0)
419:                                 buffer[1]=0xAF;                             //0xAF = sleep OFF
9D00CA64  FC5E0010   LW V0, 16(S8)
9D00CA66  00106D20   ADD T5, S0, ZERO
9D00CA68      6D20   ADDIU V0, V0, 1
9D00CA6A  3060FFAF   ADDIU V1, ZERO, -81
9D00CA6C  FFAF89A0   LW SP, -30304(T7)
9D00CA6E      89A0   SB V1, 0(V0)
9D00CA70      CC0B   B 0x9D00CA88
9D00CA72      0C00   NOP
420:                             }
421:                             else
422:                             {
423:                                 //1 = sleep on
424:                                 buffer[0]=0b00000001;                       //control byte
9D00CA74  FC5E0010   LW V0, 16(S8)
9D00CA78      ED81   LI V1, 1
9D00CA7A      89A0   SB V1, 0(V0)
425:                                 buffer[1]=0xAE;                             //0xAE = sleep ON
9D00CA7C  FC5E0010   LW V0, 16(S8)
9D00CA7E  00106D20   ADD T5, S0, ZERO
9D00CA80      6D20   ADDIU V0, V0, 1
9D00CA82  3060FFAE   ADDIU V1, ZERO, -82
9D00CA84  FFAE89A0   LW SP, -30304(T6)
9D00CA86      89A0   SB V1, 0(V0)
426:                             }
427:                             portInfo->writeBufferMode(portInfo, buffer, 2, 1);
9D00CA88  FC5C804C   LW V0, -32692(GP)
9D00CA8C      6921   LW V0, 4(V0)
9D00CA8E  FC7C804C   LW V1, -32692(GP)
9D00CA92      0C83   MOVE A0, V1
9D00CA94  FCBE0010   LW A1, 16(S8)
9D00CA98      EF02   LI A2, 2
9D00CA9A      EF81   LI A3, 1
9D00CA9C      45E2   JALRS16 V0
9D00CA9E      0C00   NOP
9D00CAA0      CC2C   B 0x9D00CAFA
9D00CAA2      0C00   NOP
428:                         }
429:                         else if(portInfo->periphType==PERIPH_TYPE.i2c)
9D00CAA4  FC5C804C   LW V0, -32692(GP)
9D00CAA8  14620040   LBU V1, 64(V0)
9D00CAAC      ED02   LI V0, 2
9D00CAAE  B4430024   BNE V1, V0, 0x9D00CAFA
9D00CAB0  00240C00   SLL AT, A0, 1
9D00CAB2      0C00   NOP
430:                         {
431:                             //I2C
432:                             if(on==0)
9D00CAB4  145E0020   LBU V0, 32(S8)
9D00CAB8  40A2000B   BNEZC V0, 0x9D00CAD2
433:                             {
434:                                 //0 = sleep off
435:                                 buffer[0]=0x0;                              //control byte
9D00CABC  FC5E0010   LW V0, 16(S8)
9D00CAC0      8820   SB S0, 0(V0)
436:                                 buffer[1]=0xAF;                             //0xAF = sleep OFF
9D00CAC2  FC5E0010   LW V0, 16(S8)
9D00CAC4  00106D20   ADD T5, S0, ZERO
9D00CAC6      6D20   ADDIU V0, V0, 1
9D00CAC8  3060FFAF   ADDIU V1, ZERO, -81
9D00CACA  FFAF89A0   LW SP, -30304(T7)
9D00CACC      89A0   SB V1, 0(V0)
9D00CACE      CC0A   B 0x9D00CAE4
9D00CAD0      0C00   NOP
437:                             }
438:                             else
439:                             {
440:                                 //1 = sleep on
441:                                 buffer[0]=0x0;                              //control byte
9D00CAD2  FC5E0010   LW V0, 16(S8)
9D00CAD6      8820   SB S0, 0(V0)
442:                                 buffer[1]=0xAE;                             //0xAE = sleep ON
9D00CAD8  FC5E0010   LW V0, 16(S8)
9D00CADA  00106D20   ADD T5, S0, ZERO
9D00CADC      6D20   ADDIU V0, V0, 1
9D00CADE  3060FFAE   ADDIU V1, ZERO, -82
9D00CAE0  FFAE89A0   LW SP, -30304(T6)
9D00CAE2      89A0   SB V1, 0(V0)
443:                             }
444:                             portInfo->writeBuffer(portInfo, buffer, 2);            
9D00CAE4  FC5C804C   LW V0, -32692(GP)
9D00CAE8      6920   LW V0, 0(V0)
9D00CAEA  FC7C804C   LW V1, -32692(GP)
9D00CAEE      0C83   MOVE A0, V1
9D00CAF0  FCBE0010   LW A1, 16(S8)
9D00CAF4      EF02   LI A2, 2
9D00CAF6      45E2   JALRS16 V0
9D00CAF8      0C00   NOP
445:                         }        
446:                     }
447:                     
448:                     if(bl != 0xFF)
449:                     {
450:                         //backlight nema
451:                      }
452:                     
453:                     if(inv != 0xFF)
9D00CAFA  147E002C   LBU V1, 44(S8)
9D00CAFC  002C3040   SRL AT, T4, 6
9D00CAFE  304000FF   ADDIU V0, ZERO, 255
9D00CB02  9443006D   BEQ V1, V0, 0x9D00CBE0
9D00CB04  006D0C00   SLL V1, T5, 1
9D00CB06      0C00   NOP
454:                     {
455:                         buffer=getBuffer();
9D00CB08  768069F4   JALS getBuffer
9D00CB0A      69F4   LW V1, 16(A3)
9D00CB0C      0C00   NOP
9D00CB0E  F85E0010   SW V0, 16(S8)
456:                         if(portInfo->periphType==PERIPH_TYPE.spi)
9D00CB12  FC5C804C   LW V0, -32692(GP)
9D00CB16  14620040   LBU V1, 64(V0)
9D00CB18  00400C40   SRL V0, ZERO, 1
9D00CB1A      0C40   MOVE V0, ZERO
9D00CB1C  B443002F   BNE V1, V0, 0x9D00CB7E
9D00CB1E  002F0C00   SLL AT, T7, 1
9D00CB20      0C00   NOP
457:                         {      
458:                             //SPI        
459:                             if(inv==0)
9D00CB22  145E002C   LBU V0, 44(S8)
9D00CB26  40A2000C   BNEZC V0, 0x9D00CB42
460:                             {
461:                                 //0=normal, not inv
462:                                 buffer[0]=0b00000001;                       //control byte
9D00CB2A  FC5E0010   LW V0, 16(S8)
9D00CB2E      ED81   LI V1, 1
9D00CB30      89A0   SB V1, 0(V0)
463:                                 buffer[1]=0xA6;                             //0xA6 = inversion OFF (normal mode)
9D00CB32  FC5E0010   LW V0, 16(S8)
9D00CB34  00106D20   ADD T5, S0, ZERO
9D00CB36      6D20   ADDIU V0, V0, 1
9D00CB38  3060FFA6   ADDIU V1, ZERO, -90
9D00CB3A  FFA689A0   LW SP, -30304(A2)
9D00CB3C      89A0   SB V1, 0(V0)
9D00CB3E      CC11   B 0x9D00CB62
9D00CB40      0C00   NOP
464:                             }
465:                             else if (inv==1)
9D00CB42  147E002C   LBU V1, 44(S8)
9D00CB46      ED01   LI V0, 1
9D00CB48  B443000B   BNE V1, V0, 0x9D00CB62
9D00CB4A  000B0C00   SLL ZERO, T3, 1
9D00CB4C      0C00   NOP
466:                             {
467:                                 //1=inv 
468:                                 buffer[0]=0b00000001;                       //control byte
9D00CB4E  FC5E0010   LW V0, 16(S8)
9D00CB52      ED81   LI V1, 1
9D00CB54      89A0   SB V1, 0(V0)
469:                                 buffer[1]=0xA7;                             //0x21 = inversion ON (inv mode)
9D00CB56  FC5E0010   LW V0, 16(S8)
9D00CB58  00106D20   ADD T5, S0, ZERO
9D00CB5A      6D20   ADDIU V0, V0, 1
9D00CB5C  3060FFA7   ADDIU V1, ZERO, -89
9D00CB5E  FFA789A0   LW SP, -30304(A3)
9D00CB60      89A0   SB V1, 0(V0)
470:                             }
471:                             portInfo->writeBufferMode(portInfo, buffer, 2, 1);
9D00CB62  FC5C804C   LW V0, -32692(GP)
9D00CB66      6921   LW V0, 4(V0)
9D00CB68  FC7C804C   LW V1, -32692(GP)
9D00CB6C      0C83   MOVE A0, V1
9D00CB6E  FCBE0010   LW A1, 16(S8)
9D00CB72      EF02   LI A2, 2
9D00CB74      EF81   LI A3, 1
9D00CB76      45E2   JALRS16 V0
9D00CB78      0C00   NOP
9D00CB7A      CC32   B 0x9D00CBE0
9D00CB7C      0C00   NOP
472:                         }
473:                         else if(portInfo->periphType==PERIPH_TYPE.i2c)
9D00CB7E  FC5C804C   LW V0, -32692(GP)
9D00CB82  14620040   LBU V1, 64(V0)
9D00CB86      ED02   LI V0, 2
9D00CB88  B443002A   BNE V1, V0, 0x9D00CBE0
9D00CB8A  002A0C00   SLL AT, T2, 1
9D00CB8C      0C00   NOP
474:                         {
475:                             //I2C
476:                             if(inv==0)
9D00CB8E  145E002C   LBU V0, 44(S8)
9D00CB92  40A2000B   BNEZC V0, 0x9D00CBAC
477:                             {
478:                                 //0=normal, not inv
479:                                 buffer[0]=0x0;                              //control byte
9D00CB96  FC5E0010   LW V0, 16(S8)
9D00CB9A      8820   SB S0, 0(V0)
480:                                 buffer[1]=0xA6;                             //0xA6 = inversion OFF (normal mode)
9D00CB9C  FC5E0010   LW V0, 16(S8)
9D00CB9E  00106D20   ADD T5, S0, ZERO
9D00CBA0      6D20   ADDIU V0, V0, 1
9D00CBA2  3060FFA6   ADDIU V1, ZERO, -90
9D00CBA4  FFA689A0   LW SP, -30304(A2)
9D00CBA6      89A0   SB V1, 0(V0)
9D00CBA8      CC10   B 0x9D00CBCA
9D00CBAA      0C00   NOP
481:                             }
482:                             else if (inv==1)
9D00CBAC  147E002C   LBU V1, 44(S8)
9D00CBB0      ED01   LI V0, 1
9D00CBB2  B443000A   BNE V1, V0, 0x9D00CBCA
9D00CBB4  000A0C00   SLL ZERO, T2, 1
9D00CBB6      0C00   NOP
483:                             {
484:                                 //1=inv 
485:                                 buffer[0]=0x0;                              //control byte
9D00CBB8  FC5E0010   LW V0, 16(S8)
9D00CBBC      8820   SB S0, 0(V0)
486:                                 buffer[1]=0xA7;                             //0x21 = inversion ON (inv mode)
9D00CBBE  FC5E0010   LW V0, 16(S8)
9D00CBC0  00106D20   ADD T5, S0, ZERO
9D00CBC2      6D20   ADDIU V0, V0, 1
9D00CBC4  3060FFA7   ADDIU V1, ZERO, -89
9D00CBC6  FFA789A0   LW SP, -30304(A3)
9D00CBC8      89A0   SB V1, 0(V0)
487:                             }
488:                             portInfo->writeBuffer(portInfo, buffer, 2);            
9D00CBCA  FC5C804C   LW V0, -32692(GP)
9D00CBCE      6920   LW V0, 0(V0)
9D00CBD0  FC7C804C   LW V1, -32692(GP)
9D00CBD4      0C83   MOVE A0, V1
9D00CBD6  FCBE0010   LW A1, 16(S8)
9D00CBDA      EF02   LI A2, 2
9D00CBDC      45E2   JALRS16 V0
9D00CBDE      0C00   NOP
489:                         }
490:                     }
491:                     
492:                     freePort();
9D00CBE0  76806A2C   JALS freePort
9D00CBE2      6A2C   LW A0, 48(V0)
9D00CBE4      0C00   NOP
493:                 }
9D00CBE6      0FBE   MOVE SP, S8
9D00CBE8      4BE7   LW RA, 28(SP)
9D00CBEA      4BC6   LW S8, 24(SP)
9D00CBEC      4C11   ADDIU SP, SP, 32
9D00CBEE      45BF   JRC RA
494:                 
495:                 static char getInitialized()
496:                 {
9D00CBF0      4FB0   ADDIU SP, SP, -8
9D00CBF2      CBC1   SW S8, 4(SP)
9D00CBF4      0FDD   MOVE S8, SP
497:                     return isInitialized;
9D00CBF6  145C8048   LBU V0, -32696(GP)
498:                 }
9D00CBFA      0FBE   MOVE SP, S8
9D00CBFC      4BC1   LW S8, 4(SP)
9D00CBFE      4C05   ADDIU SP, SP, 8
9D00CC00      45BF   JRC RA
9D00CC02      0C00   NOP
499:                 
500:                 static void print(char* t)
501:                 {
9D00CC04      4FF5   ADDIU SP, SP, -24
9D00CC06      CBE5   SW RA, 20(SP)
9D00CC08      CBC4   SW S8, 16(SP)
9D00CC0A      0FDD   MOVE S8, SP
9D00CC0C  F89E0018   SW A0, 24(S8)
502:                     if((displayInfo->print_y + fontSys.height) > Height)
9D00CC10  FC5C8050   LW V0, -32688(GP)
9D00CC14  3C420044   LH V0, 68(V0)
9D00CC18      0C62   MOVE V1, V0
9D00CC1A  41A28000   LUI V0, 0x8000
9D00CC1E  304207B8   ADDIU V0, V0, 1976
9D00CC20      07B8   ADDU A3, A0, V1
9D00CC22  3C420006   LH V0, 6(V0)
9D00CC26      05A6   ADDU V1, V1, V0
9D00CC28  3C5C801C   LH V0, -32740(GP)
9D00CC2C  00621350   SLT V0, V0, V1
9D00CC2E  135040E2   ADDI K0, S0, 16610
9D00CC30  40E20009   BEQZC V0, 0x9D00CC46
9D00CC32  00090C40   SRL ZERO, T1, 1
503:                     {
504:                         //plna obrazovka
505:                         clear(COLOR.Black);
9D00CC34      0C40   MOVE V0, ZERO
9D00CC36      0C82   MOVE A0, V0
9D00CC38  768063EC   JALS clear
9D00CC3A  63EC0C00   LWL RA, -1024(T4)
9D00CC3C      0C00   NOP
506:                         displayInfo->print_y = 0;
9D00CC3E  FC5C8050   LW V0, -32688(GP)
9D00CC42  38020044   SH ZERO, 68(V0)
507:                     }
508:                     
509:                     drawString(t, &fontSys, 0, displayInfo->print_y);
9D00CC46  FC5C8050   LW V0, -32688(GP)
9D00CC4A  3C420044   LH V0, 68(V0)
9D00CC4E  FC9E0018   LW A0, 24(S8)
9D00CC52  41A38000   LUI V1, 0x8000
9D00CC56  30A307B8   ADDIU A1, V1, 1976
9D00CC58      07B8   ADDU A3, A0, V1
9D00CC5A      0CC0   MOVE A2, ZERO
9D00CC5C      0CE2   MOVE A3, V0
9D00CC5E  76806008   JALS drawString
9D00CC60  60080C00   LWL ZERO, -1024(T0)
9D00CC62      0C00   NOP
510:                     displayInfo->print_y += fontSys.height;
9D00CC64  FC5C8050   LW V0, -32688(GP)
9D00CC68  FC7C8050   LW V1, -32688(GP)
9D00CC6C  3C630044   LH V1, 68(V1)
9D00CC70      2E3F   ANDI A0, V1, 0xFFFF
9D00CC72  41A38000   LUI V1, 0x8000
9D00CC76  306307B8   ADDIU V1, V1, 1976
9D00CC78      07B8   ADDU A3, A0, V1
9D00CC7A  3C630006   LH V1, 6(V1)
9D00CC7E      2DBF   ANDI V1, V1, 0xFFFF
9D00CC80      05B8   ADDU V1, A0, V1
9D00CC82      2DBF   ANDI V1, V1, 0xFFFF
9D00CC84  00633B3C   SEH V1, V1
9D00CC86  3B3C3862   SH T9, 14434(GP)
9D00CC88  38620044   SH V1, 68(V0)
511:                 }
9D00CC8C      0FBE   MOVE SP, S8
9D00CC8E      4BE5   LW RA, 20(SP)
9D00CC90      4BC4   LW S8, 16(SP)
9D00CC92      4C0D   ADDIU SP, SP, 24
9D00CC94      45BF   JRC RA
9D00CC96      0C00   NOP
512:                 
513:                 static short getWidth()
514:                 {
9D00CC98      4FB0   ADDIU SP, SP, -8
9D00CC9A      CBC1   SW S8, 4(SP)
9D00CC9C      0FDD   MOVE S8, SP
515:                     return Width;
9D00CC9E  3C5C801A   LH V0, -32742(GP)
516:                 }
9D00CCA2      0FBE   MOVE SP, S8
9D00CCA4      4BC1   LW S8, 4(SP)
9D00CCA6      4C05   ADDIU SP, SP, 8
9D00CCA8      45BF   JRC RA
9D00CCAA      0C00   NOP
517:                 
518:                 static short getHeight()
519:                 {
9D00CCAC      4FB0   ADDIU SP, SP, -8
9D00CCAE      CBC1   SW S8, 4(SP)
9D00CCB0      0FDD   MOVE S8, SP
520:                     return Height;
9D00CCB2  3C5C801C   LH V0, -32740(GP)
521:                 }
9D00CCB6      0FBE   MOVE SP, S8
9D00CCB8      4BC1   LW S8, 4(SP)
9D00CCBA      4C05   ADDIU SP, SP, 8
9D00CCBC      45BF   JRC RA
9D00CCBE      0C00   NOP
522:                 
523:                 
524:                 static void dinit()
525:                 {
9D00CCC0      4FF1   ADDIU SP, SP, -32
9D00CCC2      CBE7   SW RA, 28(SP)
9D00CCC4      CBC6   SW S8, 24(SP)
9D00CCC6      0FDD   MOVE S8, SP
526:                     char* buffer;
527:                 	resetDisplay();
9D00CCC8  76806A6A   JALS resetDisplay
9D00CCCA      6A6A   LW A0, 40(A2)
9D00CCCC      0C00   NOP
528:                 
529:                     getPort();
9D00CCCE  76806A0E   JALS getPort
9D00CCD0      6A0E   LW A0, 56(S0)
9D00CCD2      0C00   NOP
530:                     buffer=getBuffer();
9D00CCD4  768069F4   JALS getBuffer
9D00CCD6      69F4   LW V1, 16(A3)
9D00CCD8      0C00   NOP
9D00CCDA  F85E0010   SW V0, 16(S8)
531:                     
532:                     if(portInfo->periphType==PERIPH_TYPE.spi)
9D00CCDE  FC5C804C   LW V0, -32692(GP)
9D00CCE2  14620040   LBU V1, 64(V0)
9D00CCE4  00400C40   SRL V0, ZERO, 1
9D00CCE6      0C40   MOVE V0, ZERO
9D00CCE8  B44300A7   BNE V1, V0, 0x9D00CE3A
9D00CCEA  00A70C00   SLL A1, A3, 1
9D00CCEC      0C00   NOP
533:                     {
534:                         //SPI
535:                         buffer[0]=0xAE;
9D00CCEE  FC5E0010   LW V0, 16(S8)
9D00CCF2  3060FFAE   ADDIU V1, ZERO, -82
9D00CCF4  FFAE89A0   LW SP, -30304(T6)
9D00CCF6      89A0   SB V1, 0(V0)
536:                         buffer[1]=0xD5;
9D00CCF8  FC5E0010   LW V0, 16(S8)
9D00CCFA  00106D20   ADD T5, S0, ZERO
9D00CCFC      6D20   ADDIU V0, V0, 1
9D00CCFE  3060FFD5   ADDIU V1, ZERO, -43
9D00CD00  FFD589A0   LW S8, -30304(S5)
9D00CD02      89A0   SB V1, 0(V0)
537:                         buffer[2]=0x80;            
9D00CD04  FC5E0010   LW V0, 16(S8)
9D00CD08      4C44   ADDIU V0, V0, 2
9D00CD0A  3060FF80   ADDIU V1, ZERO, -128
9D00CD0C  FF8089A0   LW GP, -30304(ZERO)
9D00CD0E      89A0   SB V1, 0(V0)
538:                         buffer[3]=0xA8;            
9D00CD10  FC5E0010   LW V0, 16(S8)
9D00CD14      4C46   ADDIU V0, V0, 3
9D00CD16  3060FFA8   ADDIU V1, ZERO, -88
9D00CD18  FFA889A0   LW SP, -30304(T0)
9D00CD1A      89A0   SB V1, 0(V0)
539:                         buffer[4]=0x3F;            
9D00CD1C  FC5E0010   LW V0, 16(S8)
9D00CD20      6D22   ADDIU V0, V0, 4
9D00CD22      EDBF   LI V1, 63
9D00CD24      89A0   SB V1, 0(V0)
540:                         buffer[5]=0xD3;      //offset
9D00CD26  FC5E0010   LW V0, 16(S8)
9D00CD2A      4C4A   ADDIU V0, V0, 5
9D00CD2C  3060FFD3   ADDIU V1, ZERO, -45
9D00CD2E  FFD389A0   LW S8, -30304(S3)
9D00CD30      89A0   SB V1, 0(V0)
541:                         buffer[6]=0x00;           
9D00CD32  FC5E0010   LW V0, 16(S8)
9D00CD34  00104C4C   INS ZERO, S0, 17, -7
9D00CD36      4C4C   ADDIU V0, V0, 6
9D00CD38      8820   SB S0, 0(V0)
542:                         buffer[7]=0x00;            
9D00CD3A  FC5E0010   LW V0, 16(S8)
9D00CD3E      4C4E   ADDIU V0, V0, 7
9D00CD40      8820   SB S0, 0(V0)
543:                         buffer[8]=0x8D;      //charge pump
9D00CD42  FC5E0010   LW V0, 16(S8)
9D00CD46      6D24   ADDIU V0, V0, 8
9D00CD48  3060FF8D   ADDIU V1, ZERO, -115
9D00CD4A  FF8D89A0   LW GP, -30304(T5)
9D00CD4C      89A0   SB V1, 0(V0)
544:                         buffer[9]=0x14;
9D00CD4E  FC5E0010   LW V0, 16(S8)
9D00CD52  30420009   ADDIU V0, V0, 9
9D00CD56      ED94   LI V1, 20
9D00CD58      89A0   SB V1, 0(V0)
545:                         buffer[10]=0x20;            
9D00CD5A  FC5E0010   LW V0, 16(S8)
9D00CD5E  3042000A   ADDIU V0, V0, 10
9D00CD60  000AEDA0   SUB SP, T2, ZERO
9D00CD62      EDA0   LI V1, 32
9D00CD64      89A0   SB V1, 0(V0)
546:                         buffer[11]=0x00;            
9D00CD66  FC5E0010   LW V0, 16(S8)
9D00CD6A  3042000B   ADDIU V0, V0, 11
9D00CD6E      8820   SB S0, 0(V0)
547:                         buffer[12]=0xA1;     //set remap, 
9D00CD70  FC5E0010   LW V0, 16(S8)
9D00CD74      6D26   ADDIU V0, V0, 12
9D00CD76  3060FFA1   ADDIU V1, ZERO, -95
9D00CD78  FFA189A0   LW SP, -30304(AT)
9D00CD7A      89A0   SB V1, 0(V0)
548:                         buffer[13]=0xC8;
9D00CD7C  FC5E0010   LW V0, 16(S8)
9D00CD80  3042000D   ADDIU V0, V0, 13
9D00CD84  3060FFC8   ADDIU V1, ZERO, -56
9D00CD86  FFC889A0   LW S8, -30304(T0)
9D00CD88      89A0   SB V1, 0(V0)
549:                         buffer[14]=0xDA;     //pin hw config
9D00CD8A  FC5E0010   LW V0, 16(S8)
9D00CD8E  3042000E   ADDIU V0, V0, 14
9D00CD92  3060FFDA   ADDIU V1, ZERO, -38
9D00CD94  FFDA89A0   LW S8, -30304(K0)
9D00CD96      89A0   SB V1, 0(V0)
550:                         buffer[15]=0x12;            
9D00CD98  FC5E0010   LW V0, 16(S8)
9D00CD9C  3042000F   ADDIU V0, V0, 15
9D00CDA0      ED92   LI V1, 18
9D00CDA2      89A0   SB V1, 0(V0)
551:                         buffer[16]=0x81;     //contrast,
9D00CDA4  FC5E0010   LW V0, 16(S8)
9D00CDA6  00106D28   LWXS T5, ZERO(S0)
9D00CDA8      6D28   ADDIU V0, V0, 16
9D00CDAA  3060FF81   ADDIU V1, ZERO, -127
9D00CDAC  FF8189A0   LW GP, -30304(AT)
9D00CDAE      89A0   SB V1, 0(V0)
552:                         buffer[17]=0x7F;     //CF
9D00CDB0  FC5E0010   LW V0, 16(S8)
9D00CDB4  30420011   ADDIU V0, V0, 17
9D00CDB8  3060007F   ADDIU V1, ZERO, 127
9D00CDBA  007F89A0   SUB S1, RA, V1
9D00CDBC      89A0   SB V1, 0(V0)
553:                         buffer[18]=0xD9;     //pre-charge
9D00CDBE  FC5E0010   LW V0, 16(S8)
9D00CDC2  30420012   ADDIU V0, V0, 18
9D00CDC6  3060FFD9   ADDIU V1, ZERO, -39
9D00CDC8  FFD989A0   LW S8, -30304(T9)
9D00CDCA      89A0   SB V1, 0(V0)
554:                         buffer[19]=0x02;     //F1      
9D00CDCC  FC5E0010   LW V0, 16(S8)
9D00CDD0  30420013   ADDIU V0, V0, 19
9D00CDD4      ED82   LI V1, 2
9D00CDD6      89A0   SB V1, 0(V0)
555:                         buffer[20]=0xDB;     //deselect level 
9D00CDD8  FC5E0010   LW V0, 16(S8)
9D00CDDC      6D2A   ADDIU V0, V0, 20
9D00CDDE  3060FFDB   ADDIU V1, ZERO, -37
9D00CDE0  FFDB89A0   LW S8, -30304(K1)
9D00CDE2      89A0   SB V1, 0(V0)
556:                         buffer[21]=0x40;
9D00CDE4  FC5E0010   LW V0, 16(S8)
9D00CDE8  30420015   ADDIU V0, V0, 21
9D00CDEA  0015EDC0   SUBU SP, S5, ZERO
9D00CDEC      EDC0   LI V1, 64
9D00CDEE      89A0   SB V1, 0(V0)
557:                         buffer[22]=0xA4;            
9D00CDF0  FC5E0010   LW V0, 16(S8)
9D00CDF4  30420016   ADDIU V0, V0, 22
9D00CDF8  3060FFA4   ADDIU V1, ZERO, -92
9D00CDFA  FFA489A0   LW SP, -30304(A0)
9D00CDFC      89A0   SB V1, 0(V0)
558:                         buffer[23]=0xA6;            
9D00CDFE  FC5E0010   LW V0, 16(S8)
9D00CE02  30420017   ADDIU V0, V0, 23
9D00CE06  3060FFA6   ADDIU V1, ZERO, -90
9D00CE08  FFA689A0   LW SP, -30304(A2)
9D00CE0A      89A0   SB V1, 0(V0)
559:                         buffer[24]=0xAF; 
9D00CE0C  FC5E0010   LW V0, 16(S8)
9D00CE0E  00106D2C   EXT ZERO, S0, 20, 14
9D00CE10      6D2C   ADDIU V0, V0, 24
9D00CE12  3060FFAF   ADDIU V1, ZERO, -81
9D00CE14  FFAF89A0   LW SP, -30304(T7)
9D00CE16      89A0   SB V1, 0(V0)
560:                     
561:                         setDCPin(0);            //0=command
9D00CE18      0C80   MOVE A0, ZERO
9D00CE1A  76806A8C   JALS setDCPin
9D00CE1C      6A8C   LW A1, 48(S0)
9D00CE1E      0C00   NOP
562:                         portInfo->writeBuffer(portInfo, buffer, 25);
9D00CE20  FC5C804C   LW V0, -32692(GP)
9D00CE24      6920   LW V0, 0(V0)
9D00CE26  FC7C804C   LW V1, -32692(GP)
9D00CE2A      0C83   MOVE A0, V1
9D00CE2C  FCBE0010   LW A1, 16(S8)
9D00CE30      EF19   LI A2, 25
9D00CE32      45E2   JALRS16 V0
9D00CE34      0C00   NOP
9D00CE36      CCAF   B 0x9D00CF96
9D00CE38      0C00   NOP
563:                     }
564:                     else if (portInfo->periphType==PERIPH_TYPE.i2c)
9D00CE3A  FC5C804C   LW V0, -32692(GP)
9D00CE3E  14620040   LBU V1, 64(V0)
9D00CE42      ED02   LI V0, 2
9D00CE44  B44300A7   BNE V1, V0, 0x9D00CF96
9D00CE46  00A70C00   SLL A1, A3, 1
9D00CE48      0C00   NOP
565:                     {
566:                         //I2C
567:                         buffer[0]=0x00;     //vsechny nasledujici bytes jsou command
9D00CE4A  FC5E0010   LW V0, 16(S8)
9D00CE4E      8820   SB S0, 0(V0)
568:                         buffer[1]=0xAE;
9D00CE50  FC5E0010   LW V0, 16(S8)
9D00CE52  00106D20   ADD T5, S0, ZERO
9D00CE54      6D20   ADDIU V0, V0, 1
9D00CE56  3060FFAE   ADDIU V1, ZERO, -82
9D00CE58  FFAE89A0   LW SP, -30304(T6)
9D00CE5A      89A0   SB V1, 0(V0)
569:                         buffer[2]=0xD5;
9D00CE5C  FC5E0010   LW V0, 16(S8)
9D00CE60      4C44   ADDIU V0, V0, 2
9D00CE62  3060FFD5   ADDIU V1, ZERO, -43
9D00CE64  FFD589A0   LW S8, -30304(S5)
9D00CE66      89A0   SB V1, 0(V0)
570:                         buffer[3]=0x80;            
9D00CE68  FC5E0010   LW V0, 16(S8)
9D00CE6C      4C46   ADDIU V0, V0, 3
9D00CE6E  3060FF80   ADDIU V1, ZERO, -128
9D00CE70  FF8089A0   LW GP, -30304(ZERO)
9D00CE72      89A0   SB V1, 0(V0)
571:                         buffer[4]=0xA8;            
9D00CE74  FC5E0010   LW V0, 16(S8)
9D00CE78      6D22   ADDIU V0, V0, 4
9D00CE7A  3060FFA8   ADDIU V1, ZERO, -88
9D00CE7C  FFA889A0   LW SP, -30304(T0)
9D00CE7E      89A0   SB V1, 0(V0)
572:                         buffer[5]=0x3F;            
9D00CE80  FC5E0010   LW V0, 16(S8)
9D00CE84      4C4A   ADDIU V0, V0, 5
9D00CE86      EDBF   LI V1, 63
9D00CE88      89A0   SB V1, 0(V0)
573:                         buffer[6]=0xD3;      //offset
9D00CE8A  FC5E0010   LW V0, 16(S8)
9D00CE8C  00104C4C   INS ZERO, S0, 17, -7
9D00CE8E      4C4C   ADDIU V0, V0, 6
9D00CE90  3060FFD3   ADDIU V1, ZERO, -45
9D00CE92  FFD389A0   LW S8, -30304(S3)
9D00CE94      89A0   SB V1, 0(V0)
574:                         buffer[7]=0x00;           
9D00CE96  FC5E0010   LW V0, 16(S8)
9D00CE9A      4C4E   ADDIU V0, V0, 7
9D00CE9C      8820   SB S0, 0(V0)
575:                         buffer[8]=0x00;            
9D00CE9E  FC5E0010   LW V0, 16(S8)
9D00CEA2      6D24   ADDIU V0, V0, 8
9D00CEA4      8820   SB S0, 0(V0)
576:                         buffer[9]=0x8D;      //charge pump
9D00CEA6  FC5E0010   LW V0, 16(S8)
9D00CEAA  30420009   ADDIU V0, V0, 9
9D00CEAE  3060FF8D   ADDIU V1, ZERO, -115
9D00CEB0  FF8D89A0   LW GP, -30304(T5)
9D00CEB2      89A0   SB V1, 0(V0)
577:                         buffer[10]=0x14;
9D00CEB4  FC5E0010   LW V0, 16(S8)
9D00CEB8  3042000A   ADDIU V0, V0, 10
9D00CEBC      ED94   LI V1, 20
9D00CEBE      89A0   SB V1, 0(V0)
578:                         buffer[11]=0x20;            
9D00CEC0  FC5E0010   LW V0, 16(S8)
9D00CEC4  3042000B   ADDIU V0, V0, 11
9D00CEC6  000BEDA0   SUB SP, T3, ZERO
9D00CEC8      EDA0   LI V1, 32
9D00CECA      89A0   SB V1, 0(V0)
579:                         buffer[12]=0x00;            
9D00CECC  FC5E0010   LW V0, 16(S8)
9D00CED0      6D26   ADDIU V0, V0, 12
9D00CED2      8820   SB S0, 0(V0)
580:                         buffer[13]=0xA1;     //set remap, hw config
9D00CED4  FC5E0010   LW V0, 16(S8)
9D00CED8  3042000D   ADDIU V0, V0, 13
9D00CEDC  3060FFA1   ADDIU V1, ZERO, -95
9D00CEDE  FFA189A0   LW SP, -30304(AT)
9D00CEE0      89A0   SB V1, 0(V0)
581:                         buffer[14]=0xC8;
9D00CEE2  FC5E0010   LW V0, 16(S8)
9D00CEE6  3042000E   ADDIU V0, V0, 14
9D00CEEA  3060FFC8   ADDIU V1, ZERO, -56
9D00CEEC  FFC889A0   LW S8, -30304(T0)
9D00CEEE      89A0   SB V1, 0(V0)
582:                         buffer[15]=0xDA;            
9D00CEF0  FC5E0010   LW V0, 16(S8)
9D00CEF4  3042000F   ADDIU V0, V0, 15
9D00CEF8  3060FFDA   ADDIU V1, ZERO, -38
9D00CEFA  FFDA89A0   LW S8, -30304(K0)
9D00CEFC      89A0   SB V1, 0(V0)
583:                         buffer[16]=0x12;            
9D00CEFE  FC5E0010   LW V0, 16(S8)
9D00CF00  00106D28   LWXS T5, ZERO(S0)
9D00CF02      6D28   ADDIU V0, V0, 16
9D00CF04      ED92   LI V1, 18
9D00CF06      89A0   SB V1, 0(V0)
584:                         buffer[17]=0x81;     //contrast, pre-charge
9D00CF08  FC5E0010   LW V0, 16(S8)
9D00CF0C  30420011   ADDIU V0, V0, 17
9D00CF10  3060FF81   ADDIU V1, ZERO, -127
9D00CF12  FF8189A0   LW GP, -30304(AT)
9D00CF14      89A0   SB V1, 0(V0)
585:                         buffer[18]=0x7F;
9D00CF16  FC5E0010   LW V0, 16(S8)
9D00CF1A  30420012   ADDIU V0, V0, 18
9D00CF1E  3060007F   ADDIU V1, ZERO, 127
9D00CF20  007F89A0   SUB S1, RA, V1
9D00CF22      89A0   SB V1, 0(V0)
586:                         buffer[19]=0xD9;            
9D00CF24  FC5E0010   LW V0, 16(S8)
9D00CF28  30420013   ADDIU V0, V0, 19
9D00CF2C  3060FFD9   ADDIU V1, ZERO, -39
9D00CF2E  FFD989A0   LW S8, -30304(T9)
9D00CF30      89A0   SB V1, 0(V0)
587:                         buffer[20]=0xF1;            
9D00CF32  FC5E0010   LW V0, 16(S8)
9D00CF36      6D2A   ADDIU V0, V0, 20
9D00CF38  3060FFF1   ADDIU V1, ZERO, -15
9D00CF3A  FFF189A0   LW RA, -30304(S1)
9D00CF3C      89A0   SB V1, 0(V0)
588:                         buffer[21]=0xDB;     //deselect level 
9D00CF3E  FC5E0010   LW V0, 16(S8)
9D00CF42  30420015   ADDIU V0, V0, 21
9D00CF46  3060FFDB   ADDIU V1, ZERO, -37
9D00CF48  FFDB89A0   LW S8, -30304(K1)
9D00CF4A      89A0   SB V1, 0(V0)
589:                         buffer[22]=0x40;
9D00CF4C  FC5E0010   LW V0, 16(S8)
9D00CF50  30420016   ADDIU V0, V0, 22
9D00CF52  0016EDC0   SUBU SP, S6, ZERO
9D00CF54      EDC0   LI V1, 64
9D00CF56      89A0   SB V1, 0(V0)
590:                         buffer[23]=0xA4;            
9D00CF58  FC5E0010   LW V0, 16(S8)
9D00CF5C  30420017   ADDIU V0, V0, 23
9D00CF60  3060FFA4   ADDIU V1, ZERO, -92
9D00CF62  FFA489A0   LW SP, -30304(A0)
9D00CF64      89A0   SB V1, 0(V0)
591:                         buffer[24]=0xA6;            
9D00CF66  FC5E0010   LW V0, 16(S8)
9D00CF68  00106D2C   EXT ZERO, S0, 20, 14
9D00CF6A      6D2C   ADDIU V0, V0, 24
9D00CF6C  3060FFA6   ADDIU V1, ZERO, -90
9D00CF6E  FFA689A0   LW SP, -30304(A2)
9D00CF70      89A0   SB V1, 0(V0)
592:                         buffer[25]=0xAF;         
9D00CF72  FC5E0010   LW V0, 16(S8)
9D00CF76  30420019   ADDIU V0, V0, 25
9D00CF7A  3060FFAF   ADDIU V1, ZERO, -81
9D00CF7C  FFAF89A0   LW SP, -30304(T7)
9D00CF7E      89A0   SB V1, 0(V0)
593:                         
594:                         portInfo->writeBuffer(portInfo, buffer, 26);
9D00CF80  FC5C804C   LW V0, -32692(GP)
9D00CF84      6920   LW V0, 0(V0)
9D00CF86  FC7C804C   LW V1, -32692(GP)
9D00CF8A      0C83   MOVE A0, V1
9D00CF8C  FCBE0010   LW A1, 16(S8)
9D00CF90      EF1A   LI A2, 26
9D00CF92      45E2   JALRS16 V0
9D00CF94      0C00   NOP
595:                     }
596:                 
597:                     freePort();
9D00CF96  76806A2C   JALS freePort
9D00CF98      6A2C   LW A0, 48(V0)
9D00CF9A      0C00   NOP
598:                 }
9D00CF9C      0FBE   MOVE SP, S8
9D00CF9E      4BE7   LW RA, 28(SP)
9D00CFA0      4BC6   LW S8, 24(SP)
9D00CFA2      4C11   ADDIU SP, SP, 32
9D00CFA4      45BF   JRC RA
9D00CFA6      0C00   NOP
599:                 
600:                 static void writeChar(IMAGE_SRC* fi, char code, short x, short y)
601:                 {
9D00CFA8      4FE5   ADDIU SP, SP, -56
9D00CFAA      CBED   SW RA, 52(SP)
9D00CFAC      CBCC   SW S8, 48(SP)
9D00CFAE      0FDD   MOVE S8, SP
9D00CFB0  F89E0038   SW A0, 56(S8)
9D00CFB2  00380C85   CMP.LE.PH T8, AT
9D00CFB4      0C85   MOVE A0, A1
9D00CFB6      0C66   MOVE V1, A2
9D00CFB8      0C47   MOVE V0, A3
9D00CFBA  189E003C   SB A0, 60(S8)
9D00CFBE  387E0040   SH V1, 64(S8)
9D00CFC2  385E0044   SH V0, 68(S8)
602:                     //fi=font-image struct IMAGE_SRC
603:                     if(fontCharParam(fi, code)==0)
9D00CFC6  145E003C   LBU V0, 60(S8)
9D00CFCA  FC9E0038   LW A0, 56(S8)
9D00CFCE      0CA2   MOVE A1, V0
9D00CFD0  7680788A   JALS fontCharParam
9D00CFD2  788A0C00   ADDIUPC AT, 2633728
9D00CFD4      0C00   NOP
9D00CFD6  40A20002   BNEZC V0, 0x9D00CFDE
9D00CFD8  0002CD55   MULQ_S.PH T9, V0, ZERO
604:                     {
605:                         //chyba, neni nastaven font (fi->fileID=0)
606:                         return;
9D00CFDA      CD55   B 0x9D00D286
9D00CFDC      0C00   NOP
607:                     }
608:                     
609:                     //cely znak musi byt na displeji, jinak ho nezobrazuje (neumoznuje zobrazit pouze cast znaku)
610:                     
611:                     if(y % 8 != 0)
9D00CFDE  345E0044   LHU V0, 68(S8)
9D00CFE2      2D25   ANDI V0, V0, 0x7
9D00CFE4      2D2F   ANDI V0, V0, 0xFFFF
9D00CFE6  40E20002   BEQZC V0, 0x9D00CFEE
9D00CFE8  0002CD4D   ADDUH_R.QB T9, V0, ZERO
612:                     {
613:                         //y musi byt delitelne 8
614:                         return;
9D00CFEA      CD4D   B 0x9D00D286
9D00CFEC      0C00   NOP
615:                     }
616:                     if(x < 0) { return; }
9D00CFEE  3C5E0040   LH V0, 64(S8)
9D00CFF2  40420003   BGEZ V0, 0x9D00CFFC
9D00CFF4  00030C00   SLL ZERO, V1, 1
9D00CFF6      0C00   NOP
9D00CFF8      CD46   B 0x9D00D286
9D00CFFA      0C00   NOP
617:                     if((x + fi->width) > Width) { return; }
9D00CFFC  3C7E0040   LH V1, 64(S8)
9D00D000  FC5E0038   LW V0, 56(S8)
9D00D004  3C420004   LH V0, 4(V0)
9D00D008      05A6   ADDU V1, V1, V0
9D00D00A  3C5C801A   LH V0, -32742(GP)
9D00D00E  00621350   SLT V0, V0, V1
9D00D010  135040E2   ADDI K0, S0, 16610
9D00D012  40E20002   BEQZC V0, 0x9D00D01A
9D00D014  0002CD37   BREAK
9D00D016      CD37   B 0x9D00D286
9D00D018      0C00   NOP
618:                     if(y < 0) { return; }
9D00D01A  3C5E0044   LH V0, 68(S8)
9D00D01E  40420003   BGEZ V0, 0x9D00D028
9D00D020  00030C00   SLL ZERO, V1, 1
9D00D022      0C00   NOP
9D00D024      CD30   B 0x9D00D286
9D00D026      0C00   NOP
619:                     if((y + fi->height) > Height) { return; }
9D00D028  3C7E0044   LH V1, 68(S8)
9D00D02C  FC5E0038   LW V0, 56(S8)
9D00D030  3C420006   LH V0, 6(V0)
9D00D034      05A6   ADDU V1, V1, V0
9D00D036  3C5C801C   LH V0, -32740(GP)
9D00D03A  00621350   SLT V0, V0, V1
9D00D03C  135040E2   ADDI K0, S0, 16610
9D00D03E  40E20002   BEQZC V0, 0x9D00D046
9D00D042      CD21   B 0x9D00D286
9D00D044      0C00   NOP
620:                 
621:                     /*
622:                     //x
623:                     char* buffer=getBuffer();
624:                     buffer[0]=0b00000011;                       //control byte (DC=0)
625:                     buffer[1]=0x21;
626:                     buffer[2]=(char)x;
627:                     buffer[3]=(char)(x + fi->width - 1);
628:                     portInfo->writeBufferMode(portInfo, buffer, 4, 1);
629:                     
630:                     //y
631:                     buffer=getBuffer();
632:                     buffer[0]=0b00000011;                       //control byte (DC=0)
633:                     buffer[1]=0x22;
634:                     buffer[2]=(char)(y/8);
635:                     buffer[3]=(char)(y/8 + fi->height/8 - 1);
636:                     buffer[4]=0b11000000;                      //control byte (ukonci SPI mode 1, nastavi DC=1)                      //control byte
637:                     portInfo->writeBufferMode(portInfo, buffer, 5, 1);    
638:                     */
639:                     
640:                     //x
641:                     int len=0;
9D00D046  F81E0018   SW ZERO, 24(S8)
642:                     short start_x=x;
9D00D04A  345E0040   LHU V0, 64(S8)
9D00D04E  385E0020   SH V0, 32(S8)
643:                     short end_x=x + fi->width - 1;
9D00D052  FC5E0038   LW V0, 56(S8)
9D00D056  3C420004   LH V0, 4(V0)
9D00D05A      2DAF   ANDI V1, V0, 0xFFFF
9D00D05C  345E0040   LHU V0, 64(S8)
9D00D060      0526   ADDU V0, V1, V0
9D00D062      2D2F   ANDI V0, V0, 0xFFFF
9D00D064      6D2E   ADDIU V0, V0, -1
9D00D066      2D2F   ANDI V0, V0, 0xFFFF
9D00D068  385E0022   SH V0, 34(S8)
644:                     short start_page=y/8;
9D00D06C  3C5E0044   LH V0, 68(S8)
9D00D070  30620007   ADDIU V1, V0, 7
9D00D074  90820000   SLTI A0, V0, 0
9D00D078  00831018   MOVN V0, V1, A0
9D00D07A  10180042   ADDI ZERO, T8, 66
9D00D07C  00421880   SRA V0, V0, 3
9D00D07E  1880385E   SB A0, 14430(ZERO)
9D00D080  385E0024   SH V0, 36(S8)
645:                     short end_page=y/8 + fi->height/8 - 1;
9D00D084  3C5E0044   LH V0, 68(S8)
9D00D088  30620007   ADDIU V1, V0, 7
9D00D08C  90820000   SLTI A0, V0, 0
9D00D090  00831018   MOVN V0, V1, A0
9D00D092  10180042   ADDI ZERO, T8, 66
9D00D094  00421880   SRA V0, V0, 3
9D00D096  18800042   SB A0, 66(ZERO)
9D00D098  00423B3C   SEH V0, V0
9D00D09A  3B3C2DAF   SH T9, 11695(GP)
9D00D09C      2DAF   ANDI V1, V0, 0xFFFF
9D00D09E  FC5E0038   LW V0, 56(S8)
9D00D0A2  3C420006   LH V0, 6(V0)
9D00D0A6  30820007   ADDIU A0, V0, 7
9D00D0AA  90A20000   SLTI A1, V0, 0
9D00D0AE  00A41018   MOVN V0, A0, A1
9D00D0B0  10180042   ADDI ZERO, T8, 66
9D00D0B2  00421880   SRA V0, V0, 3
9D00D0B4  18800042   SB A0, 66(ZERO)
9D00D0B6  00423B3C   SEH V0, V0
9D00D0B8  3B3C2D2F   SH T9, 11567(GP)
9D00D0BA      2D2F   ANDI V0, V0, 0xFFFF
9D00D0BC      0526   ADDU V0, V1, V0
9D00D0BE      2D2F   ANDI V0, V0, 0xFFFF
9D00D0C0      6D2E   ADDIU V0, V0, -1
9D00D0C2      2D2F   ANDI V0, V0, 0xFFFF
9D00D0C4  385E0026   SH V0, 38(S8)
9D00D0C6  00267680   OR T6, A2, AT
646:                     
647:                     char* buffer=getBuffer();
9D00D0C8  768069F4   JALS getBuffer
9D00D0CA      69F4   LW V1, 16(A3)
9D00D0CC      0C00   NOP
9D00D0CE  F85E0028   SW V0, 40(S8)
648:                     if(portInfo->periphType==PERIPH_TYPE.i2c)
9D00D0D2  FC5C804C   LW V0, -32692(GP)
9D00D0D6  14620040   LBU V1, 64(V0)
9D00D0DA      ED02   LI V0, 2
9D00D0DC  B4430023   BNE V1, V0, 0x9D00D126
9D00D0DE  00230C00   SLL AT, V1, 1
9D00D0E0      0C00   NOP
649:                     {
650:                         len = prefixI2c(buffer, start_x, end_x, start_page, end_page);
9D00D0E2  3CBE0020   LH A1, 32(S8)
9D00D0E6  3C7E0022   LH V1, 34(S8)
9D00D0EA  3C5E0024   LH V0, 36(S8)
9D00D0EE  3C9E0026   LH A0, 38(S8)
9D00D0F2      C884   SW A0, 16(SP)
9D00D0F4  FC9E0028   LW A0, 40(S8)
9D00D0F8      0CC3   MOVE A2, V1
9D00D0FA      0CE2   MOVE A3, V0
9D00D0FC  76806990   JALS prefixI2c
9D00D0FE      6990   LW V1, 0(S1)
9D00D100      0C00   NOP
9D00D102  F85E0018   SW V0, 24(S8)
651:                         portInfo->writeBuffer(portInfo, buffer, len); 
9D00D106  FC5C804C   LW V0, -32692(GP)
9D00D10A      6920   LW V0, 0(V0)
9D00D10C  FC9C804C   LW A0, -32692(GP)
9D00D110  FC7E0018   LW V1, 24(S8)
9D00D114  00633B3C   SEH V1, V1
9D00D116  3B3CFCBE   SH T9, -834(GP)
9D00D118  FCBE0028   LW A1, 40(S8)
9D00D11C      0CC3   MOVE A2, V1
9D00D11E      45E2   JALRS16 V0
9D00D120      0C00   NOP
9D00D122      CC2A   B 0x9D00D178
9D00D124      0C00   NOP
652:                     }
653:                     else if(portInfo->periphType==PERIPH_TYPE.spi)
9D00D126  FC5C804C   LW V0, -32692(GP)
9D00D12A  14620040   LBU V1, 64(V0)
9D00D12C  00400C40   SRL V0, ZERO, 1
9D00D12E      0C40   MOVE V0, ZERO
9D00D130  B4430022   BNE V1, V0, 0x9D00D178
9D00D132  00220C00   SLL AT, V0, 1
9D00D134      0C00   NOP
654:                     {
655:                         len = prefixSpi(buffer, start_x, end_x, start_page, end_page);
9D00D136  3CBE0020   LH A1, 32(S8)
9D00D13A  3C7E0022   LH V1, 34(S8)
9D00D13E  3C5E0024   LH V0, 36(S8)
9D00D142  3C9E0026   LH A0, 38(S8)
9D00D146      C884   SW A0, 16(SP)
9D00D148  FC9E0028   LW A0, 40(S8)
9D00D14C      0CC3   MOVE A2, V1
9D00D14E      0CE2   MOVE A3, V0
9D00D150  76806948   JALS prefixSpi
9D00D152      6948   LW V0, 32(A0)
9D00D154      0C00   NOP
9D00D156  F85E0018   SW V0, 24(S8)
656:                         portInfo->writeBufferMode(portInfo, buffer, len, 1); 
9D00D15A  FC5C804C   LW V0, -32692(GP)
9D00D15E      6921   LW V0, 4(V0)
9D00D160  FC9C804C   LW A0, -32692(GP)
9D00D164  FC7E0018   LW V1, 24(S8)
9D00D168  00633B3C   SEH V1, V1
9D00D16A  3B3CFCBE   SH T9, -834(GP)
9D00D16C  FCBE0028   LW A1, 40(S8)
9D00D170      0CC3   MOVE A2, V1
9D00D172      EF81   LI A3, 1
9D00D174      45E2   JALRS16 V0
9D00D176      0C00   NOP
657:                     }
658:                     
659:                     /*
660:                     buffer[0]=0b00000011;                       //control byte (DC=0)
661:                     buffer[1]=0x21;
662:                     buffer[2]=(char)x;
663:                     buffer[3]=(char)(x + fi->width - 1);
664:                     //portInfo->writeBufferMode(portInfo, buffer, 4, 1);
665:                     
666:                     //y
667:                     //buffer=getBuffer();
668:                     buffer[4]=0b00000011;                       //control byte (DC=0)
669:                     buffer[5]=0x22;
670:                     buffer[6]=(char)(y/8);
671:                     buffer[7]=(char)(y/8 + fi->height/8 - 1);
672:                     buffer[8]=0b11000000;                      //control byte (ukonci SPI mode 1, nastavi DC=1)                      //control byte
673:                     portInfo->writeBufferMode(portInfo, buffer, 9, 1);
674:                     */
675:                     
676:                     if(portInfo->directMode==1)
9D00D178  FC5C804C   LW V0, -32692(GP)
9D00D17C  1462003D   LBU V1, 61(V0)
9D00D180      ED01   LI V0, 1
9D00D182  B443002D   BNE V1, V0, 0x9D00D1E0
9D00D184  002D0C00   SLL AT, T5, 1
9D00D186      0C00   NOP
677:                     {
678:                         //plati pouze pro SPI
679:                         //direct write data >> SPIBUF
680:                         spi_Process(portInfo->portIndex, 1);         //ceka na dokonceni          
9D00D188  FC5C804C   LW V0, -32692(GP)
9D00D18C  1442003C   LBU V0, 60(V0)
9D00D190      0C82   MOVE A0, V0
9D00D192      EE81   LI A1, 1
9D00D194  768070E8   JALS spi_Process
9D00D196  70E80C00   XORI A3, T0, 3072
9D00D198      0C00   NOP
681:                         
682:                         //odesila data znaku primo do hw_bufferu (SPIxBUF) (SPI 8-bit mode)
683:                         char* a;
684:                         int* spi_buf=portInfo->directModeHwBuffer;
9D00D19A  FC5C804C   LW V0, -32692(GP)
9D00D19E      6928   LW V0, 32(V0)
9D00D1A0  F85E002C   SW V0, 44(S8)
685:                         for(a=fi->srcStartPosition; a < fi->srcAfter; a++)
9D00D1A4  FC5E0038   LW V0, 56(S8)
9D00D1A8      692A   LW V0, 40(V0)
9D00D1AA  F85E001C   SW V0, 28(S8)
9D00D1AC  001CCC0D   ADDQ_S.PH T9, GP, ZERO
9D00D1AE      CC0D   B 0x9D00D1CA
9D00D1B0      0C00   NOP
9D00D1C0  FC5E001C   LW V0, 28(S8)
9D00D1C2  001C6D20   ADD T5, GP, ZERO
9D00D1C4      6D20   ADDIU V0, V0, 1
9D00D1C6  F85E001C   SW V0, 28(S8)
9D00D1CA  FC5E0038   LW V0, 56(S8)
9D00D1CE      69AB   LW V1, 44(V0)
9D00D1D0  FC5E001C   LW V0, 28(S8)
9D00D1D4  00621390   SLTU V0, V0, V1
9D00D1D6  139040A2   ADDI GP, S0, 16546
9D00D1D8  40A2FFEB   BNEZC V0, 0x9D00D1B2
9D00D1DA  FFEBCC54   LW RA, -13228(T3)
9D00D1DC      CC54   B 0x9D00D286
9D00D1DE      0C00   NOP
686:                         {
687:                             *spi_buf=*a;
9D00D1B2  FC5E001C   LW V0, 28(S8)
9D00D1B4  001C0920   ADD AT, GP, ZERO
9D00D1B6      0920   LBU V0, 0(V0)
9D00D1B8      0C62   MOVE V1, V0
9D00D1BA  FC5E002C   LW V0, 44(S8)
9D00D1BC  002CE9A0   SUB SP, T4, AT
9D00D1BE      E9A0   SW V1, 0(V0)
688:                         }
689:                     }
690:                     else
691:                     {
692:                         //vlozi data znaku do bufferu a ten odesila
693:                         fi->srcPosition=fi->srcStartPosition;
9D00D1E0  FC5E0038   LW V0, 56(S8)
9D00D1E4      69AA   LW V1, 40(V0)
9D00D1E6  FC5E0038   LW V0, 56(S8)
9D00D1EA      E9A4   SW V1, 16(V0)
694:                         fi->eof=0;
9D00D1EC  FC5E0038   LW V0, 56(S8)
9D00D1F0  18020049   SB ZERO, 73(V0)
695:                         
696:                         do
697:                         {
698:                             //int len=0;
699:                             len=0;
9D00D1F4  F81E0018   SW ZERO, 24(S8)
9D00D1F6  00187680   OR T6, T8, ZERO
700:                             buffer=getBuffer();
9D00D1F8  768069F4   JALS getBuffer
9D00D1FA      69F4   LW V1, 16(A3)
9D00D1FC      0C00   NOP
9D00D1FE  F85E0028   SW V0, 40(S8)
9D00D200  0028CC27   BREAK
701:                             
702:                             while(len < BUFFER_SIZE)
9D00D202      CC27   B 0x9D00D252
9D00D204      0C00   NOP
9D00D252  FC5E0018   LW V0, 24(S8)
9D00D256  90420100   SLTI V0, V0, 256
9D00D25A  40A2FFD4   BNEZC V0, 0x9D00D206
9D00D25C  FFD4FC5C   LW S8, -932(S4)
703:                             {
704:                                 buffer[len]=*fi->srcPosition;
9D00D206  FC5E0018   LW V0, 24(S8)
9D00D20A  FC7E0028   LW V1, 40(S8)
9D00D20E      0526   ADDU V0, V1, V0
9D00D210  FC7E0038   LW V1, 56(S8)
9D00D214      69B4   LW V1, 16(V1)
9D00D216      09B0   LBU V1, 0(V1)
9D00D218      89A0   SB V1, 0(V0)
705:                                 fi->srcPosition++;
9D00D21A  FC5E0038   LW V0, 56(S8)
9D00D21E      6924   LW V0, 16(V0)
9D00D220      6DA0   ADDIU V1, V0, 1
9D00D222  FC5E0038   LW V0, 56(S8)
9D00D226      E9A4   SW V1, 16(V0)
706:                                 len++;
9D00D228  FC5E0018   LW V0, 24(S8)
9D00D22A  00186D20   ADD T5, T8, ZERO
9D00D22C      6D20   ADDIU V0, V0, 1
9D00D22E  F85E0018   SW V0, 24(S8)
707:                             
708:                                 if(fi->srcPosition == fi->srcAfter)
9D00D232  FC5E0038   LW V0, 56(S8)
9D00D236      69A4   LW V1, 16(V0)
9D00D238  FC5E0038   LW V0, 56(S8)
9D00D23C      692B   LW V0, 44(V0)
9D00D23E  B4430008   BNE V1, V0, 0x9D00D252
9D00D240  00080C00   SLL ZERO, T0, 1
9D00D242      0C00   NOP
709:                                 {
710:                                     fi->eof=1; 
9D00D244  FC5E0038   LW V0, 56(S8)
9D00D248      ED81   LI V1, 1
9D00D24A  18620049   SB V1, 73(V0)
9D00D24C  0049CC07   BREAK
711:                                     break;
9D00D24E      CC07   B 0x9D00D25E
9D00D250      0C00   NOP
712:                                 }
713:                             }
714:                             
715:                             portInfo->writeBuffer(portInfo, buffer, len);
9D00D25E  FC5C804C   LW V0, -32692(GP)
9D00D262      6920   LW V0, 0(V0)
9D00D264  FC9C804C   LW A0, -32692(GP)
9D00D268  FC7E0018   LW V1, 24(S8)
9D00D26C  00633B3C   SEH V1, V1
9D00D26E  3B3CFCBE   SH T9, -834(GP)
9D00D270  FCBE0028   LW A1, 40(S8)
9D00D274      0CC3   MOVE A2, V1
9D00D276      45E2   JALRS16 V0
9D00D278      0C00   NOP
716:                             //portInfo->writeBufferMode(portInfo, buffer, len, 0);
717:                             
718:                         } while (fi->eof == 0);
9D00D27A  FC5E0038   LW V0, 56(S8)
9D00D27E  14420049   LBU V0, 73(V0)
9D00D282  40E2FFB7   BEQZC V0, 0x9D00D1F4
9D00D284  FFB70FBE   LW SP, 4030(S7)
719:                     }
720:                     
721:                 }
9D00D286      0FBE   MOVE SP, S8
9D00D288      4BED   LW RA, 52(SP)
9D00D28A      4BCC   LW S8, 48(SP)
9D00D28C      4C1D   ADDIU SP, SP, 56
9D00D28E      45BF   JRC RA
722:                 
723:                 static int prefixSpi(char buffer[], short start_x, short end_x, short start_page, short end_page)
724:                 {
9D00D290      4FB0   ADDIU SP, SP, -8
9D00D292      CBC1   SW S8, 4(SP)
9D00D294      0FDD   MOVE S8, SP
9D00D296  F89E0008   SW A0, 8(S8)
9D00D298  00080C85   CMP.LE.PH T0, ZERO
9D00D29A      0C85   MOVE A0, A1
9D00D29C      0C66   MOVE V1, A2
9D00D29E      0C47   MOVE V0, A3
9D00D2A0  389E000C   SH A0, 12(S8)
9D00D2A4  387E0010   SH V1, 16(S8)
9D00D2A8  385E0014   SH V0, 20(S8)
725:                     //SPI
726:                     buffer[0]=0b00000011;                       //control byte (DC=0)
9D00D2AC  FC5E0008   LW V0, 8(S8)
9D00D2B0      ED83   LI V1, 3
9D00D2B2      89A0   SB V1, 0(V0)
727:                     buffer[1]=0x21;
9D00D2B4  FC5E0008   LW V0, 8(S8)
9D00D2B6  00086D20   ADD T5, T0, ZERO
9D00D2B8      6D20   ADDIU V0, V0, 1
9D00D2BA      EDA1   LI V1, 33
9D00D2BC      89A0   SB V1, 0(V0)
728:                     buffer[2]=(char)start_x;
9D00D2BE  FC5E0008   LW V0, 8(S8)
9D00D2C2      4C44   ADDIU V0, V0, 2
9D00D2C4  347E000C   LHU V1, 12(S8)
9D00D2C6  000C2DBD   REPL.PH A1, 0xC
9D00D2C8      2DBD   ANDI V1, V1, 0xFF
9D00D2CA      89A0   SB V1, 0(V0)
729:                     buffer[3]=(char)end_x;
9D00D2CC  FC5E0008   LW V0, 8(S8)
9D00D2D0      4C46   ADDIU V0, V0, 3
9D00D2D2  347E0010   LHU V1, 16(S8)
9D00D2D4  00102DBD   REPL.PH A1, 0x10
9D00D2D6      2DBD   ANDI V1, V1, 0xFF
9D00D2D8      89A0   SB V1, 0(V0)
730:                     //portInfo->writeBufferMode(portInfo, buffer, 4, 1);
731:                     
732:                     //y
733:                     //buffer=getBuffer();
734:                     buffer[4]=0b00000011;                       //control byte (DC=0)
9D00D2DA  FC5E0008   LW V0, 8(S8)
9D00D2DE      6D22   ADDIU V0, V0, 4
9D00D2E0      ED83   LI V1, 3
9D00D2E2      89A0   SB V1, 0(V0)
735:                     buffer[5]=0x22;
9D00D2E4  FC5E0008   LW V0, 8(S8)
9D00D2E8      4C4A   ADDIU V0, V0, 5
9D00D2EA      EDA2   LI V1, 34
9D00D2EC      89A0   SB V1, 0(V0)
736:                     buffer[6]=(char)start_page;
9D00D2EE  FC5E0008   LW V0, 8(S8)
9D00D2F0  00084C4C   INS ZERO, T0, 17, -7
9D00D2F2      4C4C   ADDIU V0, V0, 6
9D00D2F4  347E0014   LHU V1, 20(S8)
9D00D2F6  00142DBD   REPL.PH A1, 0x14
9D00D2F8      2DBD   ANDI V1, V1, 0xFF
9D00D2FA      89A0   SB V1, 0(V0)
737:                     buffer[7]=(char)end_page;
9D00D2FC  FC5E0008   LW V0, 8(S8)
9D00D300      4C4E   ADDIU V0, V0, 7
9D00D302  347E0018   LHU V1, 24(S8)
9D00D304  00182DBD   REPL.PH A1, 0x18
9D00D306      2DBD   ANDI V1, V1, 0xFF
9D00D308      89A0   SB V1, 0(V0)
738:                     buffer[8]=0b11000000;                      //control byte (ukonci SPI mode 1, nastavi DC=1)                      //control byte
9D00D30A  FC5E0008   LW V0, 8(S8)
9D00D30E      6D24   ADDIU V0, V0, 8
9D00D310  3060FFC0   ADDIU V1, ZERO, -64
9D00D312  FFC089A0   LW S8, -30304(ZERO)
9D00D314      89A0   SB V1, 0(V0)
739:                     //portInfo->writeBufferMode(portInfo, buffer, 9, 1);
740:                     return 9;
9D00D316      ED09   LI V0, 9
741:                 }
9D00D318      0FBE   MOVE SP, S8
9D00D31A      4BC1   LW S8, 4(SP)
9D00D31C      4C05   ADDIU SP, SP, 8
9D00D31E      45BF   JRC RA
742:                 
743:                 static int prefixI2c(char buffer[], short start_x, short end_x, short start_page, short end_page)
744:                 {
9D00D320      4FB0   ADDIU SP, SP, -8
9D00D322      CBC1   SW S8, 4(SP)
9D00D324      0FDD   MOVE S8, SP
9D00D326  F89E0008   SW A0, 8(S8)
9D00D328  00080C85   CMP.LE.PH T0, ZERO
9D00D32A      0C85   MOVE A0, A1
9D00D32C      0C66   MOVE V1, A2
9D00D32E      0C47   MOVE V0, A3
9D00D330  389E000C   SH A0, 12(S8)
9D00D334  387E0010   SH V1, 16(S8)
9D00D338  385E0014   SH V0, 20(S8)
745:                     //I2C
746:                     buffer[0]=0x80;             //command, POZOR - prvni byte prepisuje send command (napr. RESET)
9D00D33C  FC5E0008   LW V0, 8(S8)
9D00D340  3060FF80   ADDIU V1, ZERO, -128
9D00D342  FF8089A0   LW GP, -30304(ZERO)
9D00D344      89A0   SB V1, 0(V0)
747:                     buffer[1]=0x21;             //set x    
9D00D346  FC5E0008   LW V0, 8(S8)
9D00D348  00086D20   ADD T5, T0, ZERO
9D00D34A      6D20   ADDIU V0, V0, 1
9D00D34C      EDA1   LI V1, 33
9D00D34E      89A0   SB V1, 0(V0)
748:                     buffer[2]=0x80;             //command
9D00D350  FC5E0008   LW V0, 8(S8)
9D00D354      4C44   ADDIU V0, V0, 2
9D00D356  3060FF80   ADDIU V1, ZERO, -128
9D00D358  FF8089A0   LW GP, -30304(ZERO)
9D00D35A      89A0   SB V1, 0(V0)
749:                     buffer[3]=(char)start_x;    //x start
9D00D35C  FC5E0008   LW V0, 8(S8)
9D00D360      4C46   ADDIU V0, V0, 3
9D00D362  347E000C   LHU V1, 12(S8)
9D00D364  000C2DBD   REPL.PH A1, 0xC
9D00D366      2DBD   ANDI V1, V1, 0xFF
9D00D368      89A0   SB V1, 0(V0)
750:                     buffer[4]=0x80;             //command
9D00D36A  FC5E0008   LW V0, 8(S8)
9D00D36E      6D22   ADDIU V0, V0, 4
9D00D370  3060FF80   ADDIU V1, ZERO, -128
9D00D372  FF8089A0   LW GP, -30304(ZERO)
9D00D374      89A0   SB V1, 0(V0)
751:                     buffer[5]=(char)end_x;      //x end
9D00D376  FC5E0008   LW V0, 8(S8)
9D00D37A      4C4A   ADDIU V0, V0, 5
9D00D37C  347E0010   LHU V1, 16(S8)
9D00D37E  00102DBD   REPL.PH A1, 0x10
9D00D380      2DBD   ANDI V1, V1, 0xFF
9D00D382      89A0   SB V1, 0(V0)
752:                     buffer[6]=0x80;             //command
9D00D384  FC5E0008   LW V0, 8(S8)
9D00D386  00084C4C   INS ZERO, T0, 17, -7
9D00D388      4C4C   ADDIU V0, V0, 6
9D00D38A  3060FF80   ADDIU V1, ZERO, -128
9D00D38C  FF8089A0   LW GP, -30304(ZERO)
9D00D38E      89A0   SB V1, 0(V0)
753:                     buffer[7]=0x22;             //set page
9D00D390  FC5E0008   LW V0, 8(S8)
9D00D394      4C4E   ADDIU V0, V0, 7
9D00D396      EDA2   LI V1, 34
9D00D398      89A0   SB V1, 0(V0)
754:                     buffer[8]=0x80;             //command
9D00D39A  FC5E0008   LW V0, 8(S8)
9D00D39E      6D24   ADDIU V0, V0, 8
9D00D3A0  3060FF80   ADDIU V1, ZERO, -128
9D00D3A2  FF8089A0   LW GP, -30304(ZERO)
9D00D3A4      89A0   SB V1, 0(V0)
755:                     buffer[9]=(char)start_page; //start page
9D00D3A6  FC5E0008   LW V0, 8(S8)
9D00D3AA  30420009   ADDIU V0, V0, 9
9D00D3AE  347E0014   LHU V1, 20(S8)
9D00D3B0  00142DBD   REPL.PH A1, 0x14
9D00D3B2      2DBD   ANDI V1, V1, 0xFF
9D00D3B4      89A0   SB V1, 0(V0)
756:                     buffer[10]=0x80;            //commandge
9D00D3B6  FC5E0008   LW V0, 8(S8)
9D00D3BA  3042000A   ADDIU V0, V0, 10
9D00D3BE  3060FF80   ADDIU V1, ZERO, -128
9D00D3C0  FF8089A0   LW GP, -30304(ZERO)
9D00D3C2      89A0   SB V1, 0(V0)
757:                     buffer[11]=(char)end_page;  //end page
9D00D3C4  FC5E0008   LW V0, 8(S8)
9D00D3C8  3042000B   ADDIU V0, V0, 11
9D00D3CC  347E0018   LHU V1, 24(S8)
9D00D3CE  00182DBD   REPL.PH A1, 0x18
9D00D3D0      2DBD   ANDI V1, V1, 0xFF
9D00D3D2      89A0   SB V1, 0(V0)
758:                     buffer[12]=0x40;            //data
9D00D3D4  FC5E0008   LW V0, 8(S8)
9D00D3D8      6D26   ADDIU V0, V0, 12
9D00D3DA      EDC0   LI V1, 64
9D00D3DC      89A0   SB V1, 0(V0)
759:                     
760:                     return 13;                  //buffer len
9D00D3DE      ED0D   LI V0, 13
761:                 }
9D00D3E0      0FBE   MOVE SP, S8
9D00D3E2      4BC1   LW S8, 4(SP)
9D00D3E4      4C05   ADDIU SP, SP, 8
9D00D3E6      45BF   JRC RA
762:                 
763:                 static char* getBuffer()
764:                 {
9D00D3E8      4FB0   ADDIU SP, SP, -8
9D00D3EA      CBC1   SW S8, 4(SP)
9D00D3EC      0FDD   MOVE S8, SP
765:                     if(pixAB==0)
9D00D3EE  145C8049   LBU V0, -32695(GP)
9D00D3F2  40A20009   BNEZC V0, 0x9D00D408
766:                     {
767:                         pixAB=1;
9D00D3F6      ED01   LI V0, 1
9D00D3F8  185C8049   SB V0, -32695(GP)
768:                         return pixelsEven;
9D00D3FC  41A28000   LUI V0, 0x8000
9D00D400  30420804   ADDIU V0, V0, 2052
9D00D402      0804   LBU S0, 4(S0)
9D00D404      CC07   B 0x9D00D414
9D00D406      0C00   NOP
769:                     }
770:                     else
771:                     {
772:                         pixAB=0;
9D00D408  181C8049   SB ZERO, -32695(GP)
773:                         return pixelsOdd;
9D00D40C  41A28000   LUI V0, 0x8000
9D00D410  30420904   ADDIU V0, V0, 2308
9D00D412      0904   LBU V0, 4(S0)
774:                     }
775:                 }
9D00D414      0FBE   MOVE SP, S8
9D00D416      4BC1   LW S8, 4(SP)
9D00D418      4C05   ADDIU SP, SP, 8
9D00D41A      45BF   JRC RA
776:                 
777:                 static void getPort()
778:                 {
9D00D41C      4FF5   ADDIU SP, SP, -24
9D00D41E      CBE5   SW RA, 20(SP)
9D00D420      CBC4   SW S8, 16(SP)
9D00D422      0FDD   MOVE S8, SP
779:                     portInfo->getPort(portInfo);                            //zajisti pouziti periph pro tento driver (je-li obsazena, vola doEvents)
9D00D424  FC5C804C   LW V0, -32692(GP)
9D00D428      6923   LW V0, 12(V0)
9D00D42A  FC7C804C   LW V1, -32692(GP)
9D00D42E      0C83   MOVE A0, V1
9D00D430      45E2   JALRS16 V0
9D00D432      0C00   NOP
780:                     
781:                     if(portInfo->periphType != PERIPH_TYPE.i2c)
9D00D434  FC5C804C   LW V0, -32692(GP)
9D00D438  14620040   LBU V1, 64(V0)
9D00D43C      ED02   LI V0, 2
9D00D43E  94430005   BEQ V1, V0, 0x9D00D44C
9D00D440  00050C00   SLL ZERO, A1, 1
9D00D442      0C00   NOP
782:                     {
783:                         //I2C nema CS signal
784:                         setCSPin(0);
9D00D444      0C80   MOVE A0, ZERO
9D00D446  76806AB0   JALS setCSPin
9D00D448      6AB0   LW A1, 0(V1)
9D00D44A      0C00   NOP
785:                     }
786:                 }
9D00D44C      0FBE   MOVE SP, S8
9D00D44E      4BE5   LW RA, 20(SP)
9D00D450      4BC4   LW S8, 16(SP)
9D00D452      4C0D   ADDIU SP, SP, 24
9D00D454      45BF   JRC RA
9D00D456      0C00   NOP
787:                 
788:                 static void freePort()
789:                 {
9D00D458      4FF5   ADDIU SP, SP, -24
9D00D45A      CBE5   SW RA, 20(SP)
9D00D45C      CBC4   SW S8, 16(SP)
9D00D45E      0FDD   MOVE S8, SP
790:                     portInfo->freePort(portInfo);                           //uvolni periph az po odvisilani dat, proto muze volat doEvents()
9D00D460  FC5C804C   LW V0, -32692(GP)
9D00D464      6924   LW V0, 16(V0)
9D00D466  FC7C804C   LW V1, -32692(GP)
9D00D46A      0C83   MOVE A0, V1
9D00D46C      45E2   JALRS16 V0
9D00D46E      0C00   NOP
791:                     
792:                     if(portInfo->periphType != PERIPH_TYPE.i2c)
9D00D470  FC5C804C   LW V0, -32692(GP)
9D00D474  14620040   LBU V1, 64(V0)
9D00D478      ED02   LI V0, 2
9D00D47A  94430005   BEQ V1, V0, 0x9D00D488
9D00D47C  00050C00   SLL ZERO, A1, 1
9D00D47E      0C00   NOP
793:                     {
794:                         //I2C nema CS signal    
795:                         setCSPin(1);
9D00D480      EE01   LI A0, 1
9D00D482  76806AB0   JALS setCSPin
9D00D484      6AB0   LW A1, 0(V1)
9D00D486      0C00   NOP
796:                     }
797:                 }
9D00D488      0FBE   MOVE SP, S8
9D00D48A      4BE5   LW RA, 20(SP)
9D00D48C      4BC4   LW S8, 16(SP)
9D00D48E      4C0D   ADDIU SP, SP, 24
9D00D490      45BF   JRC RA
9D00D492      0C00   NOP
798:                 
799:                 static void eventDC(char x)
800:                 {
9D00D494      4FF5   ADDIU SP, SP, -24
9D00D496      CBE5   SW RA, 20(SP)
9D00D498      CBC4   SW S8, 16(SP)
9D00D49A      0FDD   MOVE S8, SP
9D00D49C      0C44   MOVE V0, A0
9D00D49E  185E0018   SB V0, 24(S8)
801:                     //plati pouze pro SPI
802:                     //b6=0/1 obsahuje hodnotu, ktera bude nastavena na DC pin 
803:                     //b7=0 - command v b0-b5 obsahuje pocet bytes dat, ktere nasleduji (nez bude dalsi command)
804:                     //b7=1 - command ukonci MODE 1, port pokracuje v MODE 0 (vse dalsi jsou data)
805:                     x=x & 0b01000000; // x>>6;
9D00D4A2  145E0018   LBU V0, 24(S8)
9D00D4A4  00182D2C   EXT ZERO, T8, 20, 6
9D00D4A6      2D2C   ANDI V0, V0, 0x40
9D00D4A8  185E0018   SB V0, 24(S8)
806:                     if(x==0){setDCPin(0);}
9D00D4AC  145E0018   LBU V0, 24(S8)
9D00D4B0  40A20006   BNEZC V0, 0x9D00D4C0
9D00D4B2  00060C80   SRA ZERO, A2, 1
9D00D4B4      0C80   MOVE A0, ZERO
9D00D4B6  76806A8C   JALS setDCPin
9D00D4B8      6A8C   LW A1, 48(S0)
9D00D4BA      0C00   NOP
9D00D4BC      CC05   B 0x9D00D4C8
9D00D4BE      0C00   NOP
807:                     else{setDCPin(1);}
9D00D4C0      EE01   LI A0, 1
9D00D4C2  76806A8C   JALS setDCPin
9D00D4C4      6A8C   LW A1, 48(S0)
9D00D4C6      0C00   NOP
808:                 }
9D00D4C8      0FBE   MOVE SP, S8
9D00D4CA      4BE5   LW RA, 20(SP)
9D00D4CC      4BC4   LW S8, 16(SP)
9D00D4CE      4C0D   ADDIU SP, SP, 24
9D00D4D0      45BF   JRC RA
9D00D4D2      0C00   NOP
809:                 
810:                 
811:                 static void resetDisplay()
812:                 {
9D00D4D4      4FF5   ADDIU SP, SP, -24
9D00D4D6      CBE5   SW RA, 20(SP)
9D00D4D8      CBC4   SW S8, 16(SP)
9D00D4DA      0FDD   MOVE S8, SP
813:                     //provede UP, DOWN (reset), UP
814:                     //je-li zapojeno vice displeju, maji spolecny RESET (pripadne i D/C signal)
815:                     
816:                 #ifdef SW_RESET
817:                     //SW reset
818:                     //UP
819:                     setResetPin(1);
9D00D4DC      EE01   LI A0, 1
9D00D4DE  76806AD4   JALS setResetPin
9D00D4E0      6AD4   LW A1, 16(A1)
9D00D4E2      0C00   NOP
820:                     pauseEvent(50);                     //50ms
9D00D4E4      EE32   LI A0, 50
9D00D4E6  76808168   JALS pauseEvent
9D00D4EA      0C00   NOP
821:                     //DOWN - probiha reset displeje
822:                     setResetPin(0);
9D00D4EC      0C80   MOVE A0, ZERO
9D00D4EE  76806AD4   JALS setResetPin
9D00D4F0      6AD4   LW A1, 16(A1)
9D00D4F2      0C00   NOP
823:                     pauseEvent(100);                    //100ms
9D00D4F4      EE64   LI A0, 100
9D00D4F6  76808168   JALS pauseEvent
9D00D4FA      0C00   NOP
824:                     //UP
825:                     setResetPin(1);
9D00D4FC      EE01   LI A0, 1
9D00D4FE  76806AD4   JALS setResetPin
9D00D500      6AD4   LW A1, 16(A1)
9D00D502      0C00   NOP
826:                     pauseEvent(50);                     //50ms
9D00D504      EE32   LI A0, 50
9D00D506  76808168   JALS pauseEvent
9D00D50A      0C00   NOP
827:                 #else    
828:                     //HW RESET
829:                     //pauseEvent(50);                     //50ms (je-li treba cekat na dokonceni hw resetu) 
830:                 #endif    
831:                     
832:                 }
9D00D50C      0FBE   MOVE SP, S8
9D00D50E      4BE5   LW RA, 20(SP)
9D00D510      4BC4   LW S8, 16(SP)
9D00D512      4C0D   ADDIU SP, SP, 24
9D00D514      45BF   JRC RA
9D00D516      0C00   NOP
833:                 
834:                 void setDCPin(char value)
835:                 {
9D00D518      4FF9   ADDIU SP, SP, -16
9D00D51A      CBC3   SW S8, 12(SP)
9D00D51C      0FDD   MOVE S8, SP
9D00D51E      0C44   MOVE V0, A0
9D00D520  185E0010   SB V0, 16(S8)
836:                     //nastav DC pin na value
837:                     int* p;
838:                     if(value==0)
9D00D524  145E0010   LBU V0, 16(S8)
9D00D528  40A20009   BNEZC V0, 0x9D00D53E
839:                     {
840:                         p=(int*)(portInfo->dc_portBase + LAT_OFFSET + CLR_OFFSET);
9D00D52C  FC5C804C   LW V0, -32692(GP)
9D00D530      692D   LW V0, 52(V0)
9D00D532  30420034   ADDIU V0, V0, 52
9D00D536  F85E0000   SW V0, 0(S8)
9D00D538  0000CC08   MOVN T9, ZERO, ZERO
9D00D53A      CC08   B 0x9D00D54C
9D00D53C      0C00   NOP
841:                     }
842:                     else
843:                     {
844:                         p=(int*)(portInfo->dc_portBase + LAT_OFFSET + SET_OFFSET);
9D00D53E  FC5C804C   LW V0, -32692(GP)
9D00D542      692D   LW V0, 52(V0)
9D00D544  30420038   ADDIU V0, V0, 56
9D00D548  F85E0000   SW V0, 0(S8)
845:                     }
846:                     
847:                     *p = portInfo->dc_pin;  
9D00D54C  FC5C804C   LW V0, -32692(GP)
9D00D550      69AE   LW V1, 56(V0)
9D00D552  FC5E0000   LW V0, 0(S8)
9D00D554  0000E9A0   SUB SP, ZERO, ZERO
9D00D556      E9A0   SW V1, 0(V0)
848:                     
849:                     //RB6 (pin 15)
850:                     //_DC_pin=value;
851:                     //LATBbits.LATB6=value;
852:                 }
9D00D558      0FBE   MOVE SP, S8
9D00D55A      4BC3   LW S8, 12(SP)
9D00D55C      4C09   ADDIU SP, SP, 16
9D00D55E      45BF   JRC RA
853:                 
854:                 static void setCSPin(char value)
855:                 {
9D00D560      4FF9   ADDIU SP, SP, -16
9D00D562      CBC3   SW S8, 12(SP)
9D00D564      0FDD   MOVE S8, SP
9D00D566      0C44   MOVE V0, A0
9D00D568  185E0010   SB V0, 16(S8)
856:                     //nastav CS pin na value
857:                     int* p;
858:                     if(value==0)
9D00D56C  145E0010   LBU V0, 16(S8)
9D00D570  40A20009   BNEZC V0, 0x9D00D586
859:                     {
860:                         p=(int*)(portInfo->cs_portBase + LAT_OFFSET + CLR_OFFSET);
9D00D574  FC5C804C   LW V0, -32692(GP)
9D00D578      6929   LW V0, 36(V0)
9D00D57A  30420034   ADDIU V0, V0, 52
9D00D57E  F85E0000   SW V0, 0(S8)
9D00D580  0000CC08   MOVN T9, ZERO, ZERO
9D00D582      CC08   B 0x9D00D594
9D00D584      0C00   NOP
861:                     }
862:                     else
863:                     {
864:                         p=(int*)(portInfo->cs_portBase + LAT_OFFSET + SET_OFFSET);
9D00D586  FC5C804C   LW V0, -32692(GP)
9D00D58A      6929   LW V0, 36(V0)
9D00D58C  30420038   ADDIU V0, V0, 56
9D00D590  F85E0000   SW V0, 0(S8)
865:                     }
866:                     
867:                     *p = portInfo->cs_pin;  
9D00D594  FC5C804C   LW V0, -32692(GP)
9D00D598      69AA   LW V1, 40(V0)
9D00D59A  FC5E0000   LW V0, 0(S8)
9D00D59C  0000E9A0   SUB SP, ZERO, ZERO
9D00D59E      E9A0   SW V1, 0(V0)
868:                 }
9D00D5A0      0FBE   MOVE SP, S8
9D00D5A2      4BC3   LW S8, 12(SP)
9D00D5A4      4C09   ADDIU SP, SP, 16
9D00D5A6      45BF   JRC RA
869:                 
870:                 static void setResetPin(char value)
871:                 {
9D00D5A8      4FF9   ADDIU SP, SP, -16
9D00D5AA      CBC3   SW S8, 12(SP)
9D00D5AC      0FDD   MOVE S8, SP
9D00D5AE      0C44   MOVE V0, A0
9D00D5B0  185E0010   SB V0, 16(S8)
872:                     int* p;
873:                     if(value==0)
9D00D5B4  145E0010   LBU V0, 16(S8)
9D00D5B8  40A20009   BNEZC V0, 0x9D00D5CE
874:                     {
875:                         p=(int*)(portInfo->reset_portBase + LAT_OFFSET + CLR_OFFSET);
9D00D5BC  FC5C804C   LW V0, -32692(GP)
9D00D5C0      692B   LW V0, 44(V0)
9D00D5C2  30420034   ADDIU V0, V0, 52
9D00D5C6  F85E0000   SW V0, 0(S8)
9D00D5C8  0000CC08   MOVN T9, ZERO, ZERO
9D00D5CA      CC08   B 0x9D00D5DC
9D00D5CC      0C00   NOP
876:                     }
877:                     else
878:                     {
879:                         p=(int*)(portInfo->reset_portBase + LAT_OFFSET + SET_OFFSET);
9D00D5CE  FC5C804C   LW V0, -32692(GP)
9D00D5D2      692B   LW V0, 44(V0)
9D00D5D4  30420038   ADDIU V0, V0, 56
9D00D5D8  F85E0000   SW V0, 0(S8)
880:                     }
881:                     
882:                     *p = portInfo->reset_pin;  
9D00D5DC  FC5C804C   LW V0, -32692(GP)
9D00D5E0      69AC   LW V1, 48(V0)
9D00D5E2  FC5E0000   LW V0, 0(S8)
9D00D5E4  0000E9A0   SUB SP, ZERO, ZERO
9D00D5E6      E9A0   SW V1, 0(V0)
883:                 }
9D00D5E8      0FBE   MOVE SP, S8
884:                 
885:                 #endif
---  d:/bos/bos/app3.c  ---------------------------------------------------------------------------------
1:                   #include <xc.h>
2:                   #include <stdio.h>
3:                   #include <stdlib.h>
4:                   #include "globals.h"
5:                   #include "asm.h"
6:                   
7:                   #include "graphics.h"
8:                   //#include "fontConsolas.h"
9:                   
10:                  #ifdef PIC32MZ
11:                  
12:                  #define     _LED_INV_REG    LATHINV
13:                  #define     _LED_INV_VAL    0b100
14:                  
15:                  #endif
16:                  
17:                  #ifdef PIC32MM0064
18:                  
19:                  #define     _LED_INV_REG    LATBINV
20:                  #define     _LED_INV_VAL    0b0                 //nic
21:                  
22:                  #endif
23:                  
24:                  #ifdef PIC32MM0256
25:                  
26:                  #define     _LED_INV_REG    LATCINV
27:                  #define     _LED_INV_VAL    0b1000              //RC3                
28:                  
29:                  #endif
30:                  
31:                  char txt[]="Tady je nejaky text";
32:                  
33:                  //extern DISPLAY dispA;
34:                  //PORT_INFO pinfo;
35:                  //IMAGE_SRC img3;
36:                  //IMAGE_SRC font;
37:                  
38:                  void m3_start();
39:                  static void blick3();
40:                  void drawLinex(short x1, short y1, short x2, short y2, short color);
41:                  void linex(short x, short y, short color);
42:                  
43:                  void m3_start()
44:                  {
9D013568      4FF5   ADDIU SP, SP, -24
9D01356A      CBE5   SW RA, 20(SP)
9D01356C      CBC4   SW S8, 16(SP)
9D01356E      0FDD   MOVE S8, SP
45:                      blick3();
9D013570  76809AC0   JALS blick3
9D013572  9AC00C00   SWC1 F22, 3072(ZERO)
9D013574      0C00   NOP
46:                      /*
47:                      pinfo.cs_portBase = PORTC_BASE;                 //CS
48:                      pinfo.cs_pin = BIT2;
49:                      pinfo.reset_portBase = PORTC_BASE;              //RESET
50:                      pinfo.reset_pin = BIT1;
51:                      pinfo.dc_portBase = PORTC_BASE;                 //DC
52:                      pinfo.dc_pin = BIT0;
53:                      pinfo.busMode = BUS_MODE._8bit;
54:                      pinfo.directMode=1;
55:                      
56:                      portWriter_init(&pinfo, PERIPH_TYPE.spi, 1);        //pinfo obsahuje fce pro vysilani dat na pozadovany port SPI, PMP, ...
57:                      */
58:                      
59:                      //disp9341_set(&dispB);                               //dispA obsahuje fce modulu disp9341
60:                      //nastavi port pro dispA
61:                      //pokud se pouziva pouze jeden display, staci nastavit jednou
62:                      //pokud je vice displeju, vola se pred kazdym pouzitim displeje
63:                      //dispB.selectPort(&pinfo);
64:                      //dispA.initDisplay();
65:                      //dispA.clear(COLOR.Black);
66:                      
67:                      while(1)
68:                      {
69:                           doEvents();
9D013576  76807F8E   JALS doEvents
9D01357A      0C00   NOP
70:                      }
9D01357C      CFFC   B 0x9D013576
9D01357E      0C00   NOP
71:                      
72:                      //setImageSrc(&image51, &img3); //image51
73:                      //while(dispA.getInitialized()==0){ doEvents(); }
74:                      
75:                      //setFontSrc(&font_dlg18, &font);
76:                      
77:                      while(1)
78:                      {
79:                          short col;
80:                          int c, r;
81:                          /*
82:                          //test box 
83:                          for(r=0; r<240; r+=25)
84:                          {
85:                              for(c=0; c<320; c+=32)
86:                              {
87:                                  col=(short)random(65535);
88:                                  dispA.drawBox(c, r, c+32, r+24, col);
89:                                  pauseEvent(200);
90:                              }
91:                          }
92:                          */
93:                          
94:                          /*
95:                          //test line
96:                          dispA.clear(COLOR.Black);
97:                          col=0xFFFF;
98:                          for(r=1; r<15; r++)
99:                          {
100:                            dispA.drawLine(5, r*15, 320, r*15, r, col);
101:                         }
102:                         pauseEvent(4000); 
103:                         */
104:                         
105:                         //test point
106:                         //dispA.clear(COLOR.Black);
107:                         
108:                         col=RGB16(0 ,63, 0);
109:                         
110:                         /*
111:                         drawLinex(0, 0, 10, 100, col);
112:                         
113:                         col=RGB16(31 ,0, 0);
114:                         drawLinex(0, 200, 50, 10, col);
115:                         
116:                         col=RGB16(0 ,0, 31);
117:                         drawLinex(80, 5, 10, 220, col);
118:                         
119:                         col=RGB16(31 ,63, 31);
120:                         drawLinex(200, 230, 180, 20, col);
121:                         */
122:                         
123:                         for(c=10; c<100; c++)
124:                         {
125:                             //drawLinex(c, 0, c+4, 239, col);
126:                             //linex
127:                             //dispA.drawLine(0, c-20, 319, c+15, 1, col);
128:                         }
129:                         
130:                         //dispA.drawString(txt3, &img2, 100, a);
131:                         //dispA.drawString(txt, &font, 20, 200);
132:                         pauseEvent(10000);
133:                         
134:                         
135:                         /*
136:                         
137:                         //for(r=0; r<240; r+=2)
138:                         //{
139:                         r=120;
140:                         
141:                             for(c=0; c<320; c++)
142:                             {
143:                                 //col=(short)c;
144:                                 r+=(short)random(20)-10;
145:                                 if(r<10){r=10;}
146:                                 if(r>230){r=230;}
147:                                 dispA.drawPoint(c, r, col);
148:                             }
149:                         //}
150:                         
151:                         pauseEvent(200);
152:                         */
153:                     }
154:                     
155:                     while(1)
156:                     {
157:                         //dispA.selectPort(&pinfo);
158:                         //dispA.clear(COLOR.Black);
159:                         //dispA.drawImage(&img3, 40, 20);
160:                         //pauseEvent(4000);   
161:                     }
162:                     
163:                 }
164:                 
165:                 static void blick3()
166:                 {
9D013580      4FF1   ADDIU SP, SP, -32
9D013582      CBE7   SW RA, 28(SP)
9D013584      CBC6   SW S8, 24(SP)
9D013586      0FDD   MOVE S8, SP
167:                     while(1)
168:                     {
169:                         //do LATxINV zapise 1 na prislusnou pozici
170:                         _LED_INV_REG = _LED_INV_VAL;
9D013588  41A2BF80   LUI V0, 0xBF80
9D01358A  BF80ED88   LDC1 F28, -4728(ZERO)
9D01358C      ED88   LI V1, 8
9D01358E  F8622DEC   SW V1, 11756(V0)
9D013590      2DEC   ANDI V1, A2, 0x40
171:                         
172:                         int a, b=0;
9D013592  F81E0014   SW ZERO, 20(S8)
173:                         for(a=0; a<150000; a++)
9D013596  F81E0010   SW ZERO, 16(S8)
9D01359A      CC26   B 0x9D0135E8
9D01359C      0C00   NOP
9D0135DE  FC5E0010   LW V0, 16(S8)
9D0135E0  00106D20   ADD T5, S0, ZERO
9D0135E2      6D20   ADDIU V0, V0, 1
9D0135E4  F85E0010   SW V0, 16(S8)
9D0135E8  FC7E0010   LW V1, 16(S8)
9D0135EC  41A20002   LUI V0, 0x2
9D0135F0  504249F0   ORI V0, V0, 18928
9D0135F2      49F0   LW T7, 64(SP)
9D0135F4  00431350   SLT V0, V1, V0
9D0135F6  135040A2   ADDI K0, S0, 16546
9D0135F8  40A2FFD1   BNEZC V0, 0x9D01359E
9D0135FA  FFD1CFC5   LW S8, -12347(S1)
174:                         {
175:                             b++;
9D01359E  FC5E0014   LW V0, 20(S8)
9D0135A0  00146D20   ADD T5, S4, ZERO
9D0135A2      6D20   ADDIU V0, V0, 1
9D0135A4  F85E0014   SW V0, 20(S8)
176:                             if(a % 1000 == 0)
9D0135A8  FCBE0010   LW A1, 16(S8)
9D0135AC  41A21062   LUI V0, 0x1062
9D0135AE  10625042   ADDI V1, V0, 20546
9D0135B0  50424DD3   ORI V0, V0, 19923
9D0135B2      4DD3   ADDIU SP, SP, 932
9D0135B4  00458B3C   MULT A1, V0
9D0135B6      8B3C   SB A2, 12(V1)
9D0135B8      4602   MFHI V0
9D0135BA  00623080   SRA V1, V0, 6
9D0135BC  30800045   ADDIU A0, ZERO, 69
9D0135BE  0045F880   SRA V0, A1, 31
9D0135C0  F88005A7   SW A0, 1447(ZERO)
9D0135C2      05A7   SUBU V1, V1, V0
9D0135C4      0C83   MOVE A0, V1
9D0135C6      2544   SLL V0, A0, 2
9D0135C8      0C82   MOVE A0, V0
9D0135CA      254A   SLL V0, A0, 5
9D0135CC      0545   SUBU V0, V0, A0
9D0135CE      0534   ADDU V0, V0, V1
9D0135D0      2526   SLL V0, V0, 3
9D0135D2      05AB   SUBU V1, A1, V0
9D0135D4  40A30003   BNEZC V1, 0x9D0135DE
9D0135D6  00037680   OR T6, V1, ZERO
177:                             {
178:                                 doEvents();
9D0135D8  76807F8E   JALS doEvents
9D0135DC      0C00   NOP
179:                             }
180:                         }
181:                     }    
9D0135FC      CFC5   B 0x9D013588
9D0135FE      0C00   NOP
182:                 }
183:                 
184:                 void drawLinex(short x1, short y1, short x2, short y2, short color)
185:                 {
9D013600      4FB0   ADDIU SP, SP, -8
9D013602      CBC1   SW S8, 4(SP)
9D013604      0FDD   MOVE S8, SP
9D013606      0D04   MOVE T0, A0
9D013608      0C85   MOVE A0, A1
9D01360A      0C66   MOVE V1, A2
9D01360C      0C47   MOVE V0, A3
9D01360E  391E0008   SH T0, 8(S8)
9D013612  389E000C   SH A0, 12(S8)
9D013616  387E0010   SH V1, 16(S8)
9D01361A  385E0014   SH V0, 20(S8)
186:                     /*
187:                     short dx=x2-x1, dy=y2-y1;
188:                     if(dx<0) {dx*=-1;}
189:                     if(dy<0) {dy*=-1;}
190:                 
191:                     if(dx>=dy)
192:                     {    
193:                         //x1 musi byt mensi, nez x2
194:                         if(x1 > x2) 
195:                         { 
196:                             short x=x1; x1=x2, x2=x; 
197:                             short y=y1; y1=y2, y2=y;
198:                         }
199:                     
200:                         short rx=x2-x1;
201:                         short ry=y2-y1;
202:                         float r=(float)ry/(float)rx;
203:                     
204:                         short a; 
205:                         short resy;
206:                 
207:                         for(a=x1; a<=x2; a++)
208:                         {
209:                             resy=((float)a)*r + y1;
210:                             dispA.drawPoint(a, resy, color);
211:                         }
212:                     }
213:                     else
214:                     {
215:                         //y1 musi byt mensi, nez y2
216:                         if(y1 > y2) 
217:                         { 
218:                             short y=y1; y1=y2, y2=y;
219:                             short x=x1; x1=x2, x2=x; 
220:                         }        
221:                         
222:                         short rx=x2-x1;
223:                         short ry=y2-y1;
224:                         float r=(float)rx/(float)ry;
225:                     
226:                         short a; 
227:                         short resx;        
228:                         
229:                         for(a=y1; a<=y2; a++)
230:                         {
231:                             resx=((float)a)*r + x1;
232:                             dispA.drawPoint(resx, a, color);
233:                         }        
234:                         
235:                     }
236:                 */
237:                     
238:                     
239:                 }
9D01361E      0FBE   MOVE SP, S8
---  d:/bos/bos/app2.c  ---------------------------------------------------------------------------------
1:                   #include <xc.h>
2:                   #include <stdio.h>
3:                   #include <stdlib.h>
4:                   #include "globals.h"
5:                   #include "asm.h"
6:                   #include "usb_device_mm.h"
7:                   #include "graphics.h"
8:                   #include "font_fixed1306.h"
9:                   //#include "disp9341a.h"
10:                  //#include "font1306.h"
11:                  //#include "fontConsolas.h"
12:                  //#include "font_twcen.h"
13:                  //#include "font_ygm.h"
14:                  
15:                  #ifdef PIC32MZ
16:                  
17:                  #define     _LED_INV_REG    LATHINV
18:                  #define     _LED_INV_VAL    0b010
19:                  
20:                  #endif
21:                  
22:                  #ifdef PIC32MM0064
23:                  
24:                  #define     _LED_INV_REG    LATBINV
25:                  #define     _LED_INV_VAL    0b0                 //nic
26:                  
27:                  #endif
28:                  
29:                  #ifdef PIC32MM0256
30:                  
31:                  #define     _LED_INV_REG    LATBINV
32:                  #define     _LED_INV_VAL    0b10000000          //RB7                
33:                  
34:                  #endif
35:                  
36:                     
37:                  
38:                  //char txt[]="0123";
39:                  char txt1[]="\x9Fslo \x7F\x43 ";
40:                  char txt2[]="15:39  +-.,";
41:                  char txt3[]="delsi text cislo 3 nejdelsi";
42:                  
43:                  //extern DISPLAY dispA;
44:                  //extern PORT_INFO pinfo;
45:                  extern GRAPHICS graphics;
46:                  extern DISPLAY dispSys;
47:                  /*
48:                  IMAGE_SRC f_dlg18;
49:                  IMAGE_SRC f_consolas16;
50:                  IMAGE_SRC f_consolas20;
51:                  IMAGE_SRC f_consolas28;
52:                  IMAGE_SRC f_consolas36;
53:                  IMAGE_SRC f_arial18;
54:                  IMAGE_SRC f_gothic78;
55:                  IMAGE_SRC f_ygm16;
56:                  IMAGE_SRC f_ygm20;
57:                  IMAGE_SRC f_ygm28;
58:                  IMAGE_SRC f_ygm36;
59:                  IMAGE_SRC f_ygm46;
60:                  IMAGE_SRC f_twcen18;
61:                  IMAGE_SRC f_twcen22;
62:                  IMAGE_SRC f_twcen28;
63:                  IMAGE_SRC f_twcen36;
64:                  IMAGE_SRC f_twcen46;
65:                  IMAGE_SRC f_twcen80;
66:                  */
67:                  
68:                  
69:                  short   x=0;
70:                  short   y=0;
71:                  //char buffer[1024];
72:                  
73:                  char hour=10;
74:                  char min=0;   
75:                  
76:                  void m2_start();
77:                  //char stack2[8];
78:                  void dispText(DISPLAY* d, char* txt);
79:                  
80:                  
81:                  void blick2();
82:                  void usb_reaction(char command[], char data_out[]);
83:                  int usb_value=0;
84:                  
85:                  void writePrint();
86:                  
87:                  short cmap[16]; 
88:                  void loadColorMap(short cm[]);
89:                  
90:                  void initGraph();
91:                  void testGraphText();
92:                  void testGraphLine();
93:                  void testTouch(short x, short y);
94:                  extern int touchXpt2046_regEvent(void* fn);
95:                  void testDisp1306();
96:                  
97:                  void m2_start()
98:                  {
9D010CE8      4FB1   ADDIU SP, SP, -160
9D010CEA  FBFD009C   SW RA, 156(SP)
9D010CEC  009CFBDD   SHILO AC3, 28
9D010CEE  FBDD0098   SW S8, 152(SP)
9D010CF0  00980FDD   SHILO AC0, 24
9D010CF2      0FDD   MOVE S8, SP
99:                      testDisp1306();
9D010CF4  768088E6   JALS testDisp1306
9D010CF6      88E6   SB S1, 6(A2)
9D010CF8      0C00   NOP
100:                     
101:                     //blick2();
102:                     //setFontSrc(&font_dlg18, &f_dlg18);
103:                     
104:                     //initGraph();
105:                     //testGraphText();
106:                     //testGraphLine();
107:                     //void* tt=(void*)&testTouch;
108:                     
109:                     //IMAGE_SRC f;
110:                     
111:                     //setFontSrc(&font_fixed32x, &f);
112:                     //f.foreColor=RGB16(31, 63, 31);
113:                     //graphics.drawString("12345678", &f, 0, 0);
114:                     //graphics.drawString("ABC def", &f, 0, 32);
115:                     
116:                     //IMAGE_SRC fs;
117:                     //setFontSrc(&font_fixed48x, &fs);
118:                     //graphics.drawString("12:55", &fs, 8, 8);
119:                     
120:                     
121:                     //IMAGE_SRC im;
122:                     //setImageSrc(&image1306x, &im);
123:                     //graphics.drawImage(&im, 0, 0);
124:                     
125:                     //graphics.drawString("ABCDEFGHIJKLMNOP", &fs, 0, 40);
126:                     //graphics.drawString("abcdefghijklmnop", &fs, 0, 48);
127:                     
128:                     //graphics.drawString("ABCdefghijklmnop", NULL, 0, 0);
129:                     //graphics.drawString("1234567890-+*/WW", NULL, 0, 16);
130:                     //graphics.drawString(txt1, NULL, 0, 32);
131:                     
132:                     
133:                     //touchXpt2046_regEvent(&testTouch);
134:                     
135:                     //dispText(&dispA);
136:                     
137:                     /*
138:                     //test image 
139:                     setImageSrc(&image52, &img2); //image51
140:                     //if(img2.format==0x4){ setImageColorMap(&img2, cmap); }
141:                     //else if(img2.format==0x1){ img2.foreColor=0xFFFF; img2.bgColor=0x0; }
142:                     //img2.start_x=-1;
143:                     //int l=imageToBuffer2(&img2, buffer, 1024, 1);
144:                     
145:                     int a, b;
146:                     
147:                     while(1)
148:                     {
149:                         for(a=0; a<200; a+=20)
150:                         {
151:                             for(b=0; b<140; b+=10)
152:                             {
153:                                 dispA.clear(COLOR.Black);
154:                                 dispA.drawImage(&img2, a, b);
155:                                 pauseEvent(3000);                
156:                             }
157:                         }
158:                     }
159:                     */
160:                     
161:                     
162:                 
163:                 
164:                 
165:                     
166:                     /*
167:                     setImageSrc(image03, &imgx);
168:                     dispA.drawImage(&imgx, 10, 10);
169:                     */
170:                 
171:                 
172:                     //dispA.drawString(txt, &fo, 0, 90);
173:                     //dispA.drawString(txt, &fo, 0, 160);    
174:                     
175:                     /*
176:                     char th[2];
177:                     char tm[2];
178:                     char res[5];
179:                     
180:                     while(1)
181:                     {
182:                         pauseEvent(1000);
183:                         min++;
184:                         if(min==60){min=0;}
185:                         
186:                         byteToChar(hour, th, 2);
187:                         byteToChar(min, tm, 2);
188:                         createString(res, 6, th, ":", tm, NULL);
189:                         
190:                         dispA.drawString(res, &fo, 30, 50);
191:                         doEvents();
192:                     }
193:                     */
194:                     
195:                     while(usbDevice_isConnected()==0)
9D010CFA      CC04   B 0x9D010D04
9D010CFC      0C00   NOP
9D010D04  76807B02   JALS usbDevice_isConnected
9D010D06  7B020C00   ADDIUPC A2, 536576
9D010D08      0C00   NOP
9D010D0A  40E2FFF8   BEQZC V0, 0x9D010CFE
9D010D0C  FFF8ED01   LW RA, -4863(T8)
196:                     {
197:                         doEvents();  
9D010CFE  76807F8E   JALS doEvents
9D010D02      0C00   NOP
198:                     }
199:                     
200:                     //reakce na pozadavek z hosta
201:                     char buffer_cmd[64];                   //prijem command z hosta (max. 16B)
202:                     char data_out[64];                     //data pro hosta
203:                     char ep=1;
9D010D0E      ED01   LI V0, 1
9D010D10  185E0010   SB V0, 16(S8)
204:                 
205:                     while(1)
206:                     {
207:                         usbDevice_rxData(ep, buffer_cmd, 64);         //Pripravi se na data z hosta
9D010D14  147E0010   LBU V1, 16(S8)
9D010D18  305E0014   ADDIU V0, S8, 20
9D010D1C      0C83   MOVE A0, V1
9D010D1E      0CA2   MOVE A1, V0
9D010D20      EF40   LI A2, 64
9D010D22  76807B76   JALS usbDevice_rxData
9D010D24  7B760C00   ADDIUPC A2, 30945280
9D010D26      0C00   NOP
208:                         while(usbDevice_isRxProgress(ep)==1) 
9D010D28      CC04   B 0x9D010D32
9D010D2A      0C00   NOP
9D010D32  145E0010   LBU V0, 16(S8)
9D010D36      0C82   MOVE A0, V0
9D010D38  76807BA2   JALS usbDevice_isRxProgress
9D010D3A  7BA20C00   ADDIUPC A3, 8925184
9D010D3C      0C00   NOP
9D010D3E      0C62   MOVE V1, V0
9D010D40      ED01   LI V0, 1
9D010D42  9443FFF3   BEQ V1, V0, 0x9D010D2C
9D010D44  FFF30C00   LW RA, 3072(S3)
9D010D46      0C00   NOP
209:                         { 
210:                             //cekani na data
211:                             doEvents(); 
9D010D2C  76807F8E   JALS doEvents
9D010D30      0C00   NOP
212:                         }
213:                  
214:                         //ok, data prijata
215:                         //usb_value=buffer_cmd[0]*256 + buffer_cmd[1];
216:                         //dekoduje command 
217:                         usb_reaction(buffer_cmd, data_out);
9D010D48  307E0014   ADDIU V1, S8, 20
9D010D4C  305E0054   ADDIU V0, S8, 84
9D010D50      0C83   MOVE A0, V1
9D010D52      0CA2   MOVE A1, V0
9D010D54  768087BE   JALS usb_reaction
9D010D56      87BE   MOVEP A0, A3, S4, V1
9D010D58      0C00   NOP
218:                     
219:                         //odeslani dat do hosta
220:                         //while(USB_isTxProgress(ep)==1)
221:                         //{ 
222:                         //    doEvents(); 
223:                         //}
224:                         //USB_txData(ep, data_out, 64);
225:                     }
9D010D5A      CFDC   B 0x9D010D14
9D010D5C      0C00   NOP
9D010D5E      0C00   NOP
226:                     
227:                     
228:                     while(1)
229:                     {
230:                         //do LATxINV zapise 1 na prislusnou pozici
231:                         _LED_INV_REG = _LED_INV_VAL;
232:                         
233:                         int a, b=0;
234:                         for(a=0; a<100000; a++)
235:                         {
236:                             b++;
237:                             if(a % 1000 == 0)
238:                             {
239:                                 doEvents();
240:                             }
241:                         }
242:                     }
243:                 }
244:                 
245:                 /*
246:                 void initGraph()
247:                 {
248:                     //definuje jinou colorMap (system obsahuje std colorMap (B/W), ktera se automaticky nastavi v IMAGE_SRC fci setFontSrc/setImageSrc)
249:                     loadColorMap(cmap);
250:                 
251:                     //<editor-fold defaultstate="collapsed" desc="PortWriter, pin set">
252:                     //pin configuration
253:                     //pinfo.portIndex = 1;                            //SPI[1]=SPI2
254:                     pinfo.cs_portBase = PORTC_BASE; //CS
255:                     pinfo.cs_pin = BIT2;
256:                     pinfo.reset_portBase = PORTC_BASE; //RESET
257:                     pinfo.reset_pin = BIT1;
258:                     pinfo.dc_portBase = PORTC_BASE; //DC
259:                     pinfo.dc_pin = BIT0;
260:                     pinfo.busMode = BUS_MODE._8bit;
261:                     pinfo.directMode = 1;
262:                 
263:                     portWriter_init(&pinfo, PERIPH_TYPE.spi, 1); //pinfo obsahuje fce pro vysilani dat na pozadovany port SPI, PMP, ...
264:                     // </editor-fold>
265:                 
266:                     // <editor-fold defaultstate="collapsed" desc="inicializace displeje">
267:                     disp9341_driver(&dispA);                    //dispA obsahuje fce modulu disp9341
268:                     dispA.initDisplay(&pinfo);                  //init
269:                     // </editor-fold>
270:                 
271:                     // <editor-fold defaultstate="collapsed" desc="aktivuje Graphics">
272:                     //dispA je asociovan s Graphics, vystup Graphics jde na dispA
273:                     setGraphics(&gr, &dispA, &pinfo); 
274:                     // </editor-fold>
275:                 
276:                     //cls
277:                     gr.clear(COLOR.Black);    
278:                 }
279:                 */
280:                 
281:                 void testGraphText()
282:                 {
9D010D60      4FB0   ADDIU SP, SP, -8
9D010D62      CBC1   SW S8, 4(SP)
9D010D64      0FDD   MOVE S8, SP
283:                     
284:                     /*
285:                     //font 4-bit, pouziva std color map
286:                     setFontSrc(&font_twcen18, &f_twcen18);
287:                     gr.drawString(txt1, &f_twcen18, 0, 0);  
288:                     
289:                     setFontSrc(&font_ygm16, &f_ygm16);
290:                     gr.drawString(txt1, &f_ygm16, 0, 20); 
291:                     
292:                     setFontSrc(&font_twcen22, &f_twcen22);
293:                     gr.drawString(txt1, &f_twcen22, 0, 40); 
294:                     
295:                     setFontSrc(&font_ygm20, &f_ygm20);
296:                     gr.drawString(txt1, &f_ygm20, 0, 70);    
297:                 
298:                     //font 4-bit, nastavi jinou colorMap
299:                     setFontSrc(&font_twcen28, &f_twcen28);
300:                     setImageColorMap(&f_twcen28, cmap);
301:                     gr.drawString(txt1, &f_twcen28, 0, 110); 
302:                     
303:                     setFontSrc(&font_ygm28, &f_ygm28);
304:                     setImageColorMap(&f_ygm28, cmap);
305:                     gr.drawString(txt1, &f_ygm28, 0, 150);   
306:                     
307:                 
308:                     setFontSrc(&font_twcen80, &f_twcen80);
309:                     gr.drawString(txt2, &f_twcen80, 0, 150); 
310:                     
311:                     */
312:                     
313:                 
314:                     //setFontSrc(&font_twcen46, &f_twcen46);
315:                     //gr.drawString(txt1, &f_twcen46, 0, 120);     
316:                     
317:                     
318:                     //setFontSrc(&font_dlg18, &f_dlg18);
319:                     //gr.drawString(txt1, &f_dlg18, 0, 0);
320:                 
321:                     //setFontSrc(&font_ygm28, &f_ygm28);
322:                     //gr.drawString(txt1, &f_ygm28, 0, 0);    
323:                     
324:                     //setFontSrc(&font_ygm36, &f_ygm36);
325:                     //gr.drawString(txt1, &f_ygm36, 0, 30);    
326:                     
327:                     //setFontSrc(&font_ygm46, &f_ygm46);
328:                     //gr.drawString(txt1, &f_ygm46, 0, 70);      
329:                     
330:                     //setFontSrc(&font_consolas16, &f_consolas16);
331:                     //f_consolas16.foreColor=COLOR.GreenYellow;
332:                     //gr.drawString(txt1, &f_consolas16, 0, 30);
333:                     
334:                     //setFontSrc(&font_consolas20, &f_consolas20);
335:                     //f_consolas20.foreColor=COLOR.GreenYellow;
336:                     //gr.drawString(txt1, &f_consolas20, 0, 45);
337:                     
338:                     //setFontSrc(&font_consolas28, &f_consolas28);
339:                     //f_consolas28.foreColor=COLOR.GreenYellow;
340:                     //gr.drawString(txt1, &f_consolas28, 0, 70);
341:                     
342:                     //setFontSrc(&font_consolas36, &f_consolas36);
343:                     //f_consolas36.foreColor=COLOR.Pink;
344:                     //gr.drawString(txt1, &f_consolas36, 0, 100);    
345:                     
346:                     //setFontSrc(&font_arial18, &f_arial18);
347:                     //f_arial18.foreColor=COLOR.Cyan;
348:                     //gr.drawString(txt1, &f_arial18, 0, 150); 
349:                     
350:                     //setFontSrc(&font_ygm16, &f_ygm16);
351:                     //f_ygm16.foreColor=COLOR.Cyan;
352:                     //gr.drawString(txt1, &f_ygm16, 0, 150); 
353:                     
354:                     //setFontSrc(&font_ygm20, &f_ygm20);
355:                     //f_ygm16.foreColor=COLOR.Cyan;
356:                     //gr.drawString(txt1, &f_ygm20, 0, 180);
357:                     
358:                     //setFontSrc(&font_gothic78, &f_gothic78);
359:                     //f_gothic78.foreColor=COLOR.Yellow;
360:                     //gr.drawString(txt2, &f_gothic78, 0, 130);     
361:                     
362:                 }
9D010D66      0FBE   MOVE SP, S8
9D010D68      4BC1   LW S8, 4(SP)
9D010D6A      4C05   ADDIU SP, SP, 8
9D010D6C      45BF   JRC RA
9D010D6E      0C00   NOP
363:                 
364:                 void testTouch(short x, short y)
365:                 {
9D010D70      4FF1   ADDIU SP, SP, -32
9D010D72      CBE7   SW RA, 28(SP)
9D010D74      CBC6   SW S8, 24(SP)
9D010D76      CA05   SW S0, 20(SP)
9D010D78      0FDD   MOVE S8, SP
9D010D7A      0C64   MOVE V1, A0
9D010D7C      0C45   MOVE V0, A1
9D010D7E  387E0020   SH V1, 32(S8)
9D010D82  385E0024   SH V0, 36(S8)
366:                     
367:                     graphics.drawPoint(x, y, RGB16(0,63,31));
9D010D86  41A28000   LUI V0, 0x8000
9D010D8A  304206C0   ADDIU V0, V0, 1728
9D010D8C      06C0   ADDU A1, S0, A0
9D010D8E      6826   LW S0, 24(V0)
9D010D90      0C80   MOVE A0, ZERO
9D010D92      EEBF   LI A1, 63
9D010D94      EF1F   LI A2, 31
9D010D96  768078E2   JALS RGB16
9D010D98  78E20C00   ADDIUPC AT, 25702400
9D010D9A      0C00   NOP
9D010D9C  00423B3C   SEH V0, V0
9D010D9E  3B3C3C9E   SH T9, 15518(GP)
9D010DA0  3C9E0020   LH A0, 32(S8)
9D010DA4  3C7E0024   LH V1, 36(S8)
9D010DA8      0CA3   MOVE A1, V1
9D010DAA      0CC2   MOVE A2, V0
9D010DAC      45F0   JALRS16 S0
9D010DAE      0C00   NOP
368:                     
369:                 }
9D010DB0      0FBE   MOVE SP, S8
9D010DB2      4BE7   LW RA, 28(SP)
9D010DB4      4BC6   LW S8, 24(SP)
9D010DB6      4A05   LW S0, 20(SP)
9D010DB8      4C11   ADDIU SP, SP, 32
9D010DBA      45BF   JRC RA
370:                 
371:                 void testGraphLine()
372:                 {
9D010DBC      4FF1   ADDIU SP, SP, -32
9D010DBE      CBE7   SW RA, 28(SP)
9D010DC0      CBC6   SW S8, 24(SP)
9D010DC2      0FDD   MOVE S8, SP
373:                     graphics.drawBox(0, 100, 50, 120, 1, COLOR.Blue);
9D010DC4  41A28000   LUI V0, 0x8000
9D010DC8  304206C0   ADDIU V0, V0, 1728
9D010DCA      06C0   ADDU A1, S0, A0
9D010DCC      6921   LW V0, 4(V0)
9D010DCE      ED9F   LI V1, 31
9D010DD0      EE01   LI A0, 1
9D010DD2      C884   SW A0, 16(SP)
9D010DD4      C865   SW V1, 20(SP)
9D010DD6      0C80   MOVE A0, ZERO
9D010DD8      EEE4   LI A1, 100
9D010DDA      EF32   LI A2, 50
9D010DDC      EFF8   LI A3, 120
9D010DDE      45E2   JALRS16 V0
9D010DE0      0C00   NOP
374:                     graphics.drawBox(300, 200, 319, 239, 1, COLOR.Magenta);
9D010DE2  41A28000   LUI V0, 0x8000
9D010DE6  304206C0   ADDIU V0, V0, 1728
9D010DE8      06C0   ADDU A1, S0, A0
9D010DEA      6921   LW V0, 4(V0)
9D010DEC  3060F81F   ADDIU V1, ZERO, -2017
9D010DEE  F81FEE01   SW ZERO, -4607(RA)
9D010DF0      EE01   LI A0, 1
9D010DF2      C884   SW A0, 16(SP)
9D010DF4      C865   SW V1, 20(SP)
9D010DF6  3080012C   ADDIU A0, ZERO, 300
9D010DFA  30A000C8   ADDIU A1, ZERO, 200
9D010DFC  00C830C0   ROTR A2, T0, 6
9D010DFE  30C0013F   ADDIU A2, ZERO, 319
9D010E02  30E000EF   ADDIU A3, ZERO, 239
9D010E06      45E2   JALRS16 V0
9D010E08      0C00   NOP
375:                     
376:                     graphics.drawLine(0, 100, 50, 120, 1, COLOR.Cyan);
9D010E0A  41A28000   LUI V0, 0x8000
9D010E0E  304206C0   ADDIU V0, V0, 1728
9D010E10      06C0   ADDU A1, S0, A0
9D010E12      6924   LW V0, 16(V0)
9D010E14  306007FF   ADDIU V1, ZERO, 2047
9D010E16      07FF   SUBU A3, A3, A3
9D010E18      EE01   LI A0, 1
9D010E1A      C884   SW A0, 16(SP)
9D010E1C      C865   SW V1, 20(SP)
9D010E1E      0C80   MOVE A0, ZERO
9D010E20      EEE4   LI A1, 100
9D010E22      EF32   LI A2, 50
9D010E24      EFF8   LI A3, 120
9D010E26      45E2   JALRS16 V0
9D010E28      0C00   NOP
377:                     graphics.drawLine(0, 120, 50, 100, 1, COLOR.Cyan);
9D010E2A  41A28000   LUI V0, 0x8000
9D010E2E  304206C0   ADDIU V0, V0, 1728
9D010E30      06C0   ADDU A1, S0, A0
9D010E32      6924   LW V0, 16(V0)
9D010E34  306007FF   ADDIU V1, ZERO, 2047
9D010E36      07FF   SUBU A3, A3, A3
9D010E38      EE01   LI A0, 1
9D010E3A      C884   SW A0, 16(SP)
9D010E3C      C865   SW V1, 20(SP)
9D010E3E      0C80   MOVE A0, ZERO
9D010E40      EEF8   LI A1, 120
9D010E42      EF32   LI A2, 50
9D010E44      EFE4   LI A3, 100
9D010E46      45E2   JALRS16 V0
9D010E48      0C00   NOP
378:                             
379:                     //short color=colWHITE;
380:                     graphics.drawLine(0, 0, 319, 0, 1, COLOR.Orange);
9D010E4A  41A28000   LUI V0, 0x8000
9D010E4E  304206C0   ADDIU V0, V0, 1728
9D010E50      06C0   ADDU A1, S0, A0
9D010E52      6924   LW V0, 16(V0)
9D010E54  3060FD20   ADDIU V1, ZERO, -736
9D010E56  FD20EE01   LW T1, -4607(ZERO)
9D010E58      EE01   LI A0, 1
9D010E5A      C884   SW A0, 16(SP)
9D010E5C      C865   SW V1, 20(SP)
9D010E5E      0C80   MOVE A0, ZERO
9D010E60      0CA0   MOVE A1, ZERO
9D010E62  30C0013F   ADDIU A2, ZERO, 319
9D010E66      0CE0   MOVE A3, ZERO
9D010E68      45E2   JALRS16 V0
9D010E6A      0C00   NOP
381:                     graphics.drawLine(319, 0, 319, 239, 1, COLOR.Yellow);
9D010E6C  41A28000   LUI V0, 0x8000
9D010E70  304206C0   ADDIU V0, V0, 1728
9D010E72      06C0   ADDU A1, S0, A0
9D010E74      6924   LW V0, 16(V0)
9D010E76  3060FFE0   ADDIU V1, ZERO, -32
9D010E78  FFE0EE01   LW RA, -4607(ZERO)
9D010E7A      EE01   LI A0, 1
9D010E7C      C884   SW A0, 16(SP)
9D010E7E      C865   SW V1, 20(SP)
9D010E80  3080013F   ADDIU A0, ZERO, 319
9D010E84      0CA0   MOVE A1, ZERO
9D010E86  30C0013F   ADDIU A2, ZERO, 319
9D010E8A  30E000EF   ADDIU A3, ZERO, 239
9D010E8E      45E2   JALRS16 V0
9D010E90      0C00   NOP
382:                     graphics.drawLine(319, 239, 0, 239, 1, COLOR.Orange);
9D010E92  41A28000   LUI V0, 0x8000
9D010E96  304206C0   ADDIU V0, V0, 1728
9D010E98      06C0   ADDU A1, S0, A0
9D010E9A      6924   LW V0, 16(V0)
9D010E9C  3060FD20   ADDIU V1, ZERO, -736
9D010E9E  FD20EE01   LW T1, -4607(ZERO)
9D010EA0      EE01   LI A0, 1
9D010EA2      C884   SW A0, 16(SP)
9D010EA4      C865   SW V1, 20(SP)
9D010EA6  3080013F   ADDIU A0, ZERO, 319
9D010EAA  30A000EF   ADDIU A1, ZERO, 239
9D010EAC  00EF0CC0   ROTR A3, T7, 1
9D010EAE      0CC0   MOVE A2, ZERO
9D010EB0  30E000EF   ADDIU A3, ZERO, 239
9D010EB4      45E2   JALRS16 V0
9D010EB6      0C00   NOP
383:                     graphics.drawLine(0, 239, 0, 0, 1, COLOR.Yellow);    
9D010EB8  41A28000   LUI V0, 0x8000
9D010EBC  304206C0   ADDIU V0, V0, 1728
9D010EBE      06C0   ADDU A1, S0, A0
9D010EC0      6924   LW V0, 16(V0)
9D010EC2  3060FFE0   ADDIU V1, ZERO, -32
9D010EC4  FFE0EE01   LW RA, -4607(ZERO)
9D010EC6      EE01   LI A0, 1
9D010EC8      C884   SW A0, 16(SP)
9D010ECA      C865   SW V1, 20(SP)
9D010ECC      0C80   MOVE A0, ZERO
9D010ECE  30A000EF   ADDIU A1, ZERO, 239
9D010ED0  00EF0CC0   ROTR A3, T7, 1
9D010ED2      0CC0   MOVE A2, ZERO
9D010ED4      0CE0   MOVE A3, ZERO
9D010ED6      45E2   JALRS16 V0
9D010ED8      0C00   NOP
384:                 }
9D010EDA      0FBE   MOVE SP, S8
9D010EDC      4BE7   LW RA, 28(SP)
9D010EDE      4BC6   LW S8, 24(SP)
9D010EE0      4C11   ADDIU SP, SP, 32
9D010EE2      45BF   JRC RA
385:                 
386:                 void writePrint()
387:                 {
9D010EE4      4FDD   ADDIU SP, SP, -72
9D010EE6      CBF1   SW RA, 68(SP)
9D010EE8      CBD0   SW S8, 64(SP)
9D010EEA      0FDD   MOVE S8, SP
388:                     int a;
389:                     char res[32];
390:                     char tm[4];
391:                     for(a=0; a<100; a++)
9D010EEC  F81E0018   SW ZERO, 24(S8)
9D010EEE  0018CC2D   MUL_S.PH T9, T8, ZERO
9D010EF0      CC2D   B 0x9D010F4C
9D010EF2      0C00   NOP
9D010F42  FC5E0018   LW V0, 24(S8)
9D010F44  00186D20   ADD T5, T8, ZERO
9D010F46      6D20   ADDIU V0, V0, 1
9D010F48  F85E0018   SW V0, 24(S8)
9D010F4C  FC5E0018   LW V0, 24(S8)
9D010F50  90420064   SLTI V0, V0, 100
9D010F54  40A2FFCE   BNEZC V0, 0x9D010EF4
9D010F56  FFCE0FBE   LW S8, 4030(T6)
392:                     {
393:                         byteToChar(a, tm, 1);
9D010EF4  305E003C   ADDIU V0, S8, 60
9D010EF8  FC9E0018   LW A0, 24(S8)
9D010EFC      0CA2   MOVE A1, V0
9D010EFE      EF01   LI A2, 1
9D010F00  768081CA   JALS byteToChar
9D010F04      0C00   NOP
394:                         createString(res, 32, "Vpis textu \x9Fslo : ", tm, NULL);
9D010F06  307E001C   ADDIU V1, S8, 28
9D010F0A  305E003C   ADDIU V0, S8, 60
9D010F0E      C804   SW ZERO, 16(SP)
9D010F10      0C83   MOVE A0, V1
9D010F12      EEA0   LI A1, 32
9D010F14  41A39D00   LUI V1, 0x9D00
9D010F16  9D0030C3   LWC1 F8, 12483(ZERO)
9D010F18  30C361F8   ADDIU A2, V1, 25080
9D010F1A  61F80CE2   LWL T7, -798(T8)
9D010F1C      0CE2   MOVE A3, V0
9D010F1E  768083F2   JALS createString
9D010F22      0C00   NOP
395:                         graphics.print(res);
9D010F24  41A28000   LUI V0, 0x8000
9D010F28  304206C0   ADDIU V0, V0, 1728
9D010F2A      06C0   ADDU A1, S0, A0
9D010F2C      6927   LW V0, 28(V0)
9D010F2E  307E001C   ADDIU V1, S8, 28
9D010F32      0C83   MOVE A0, V1
9D010F34      45E2   JALRS16 V0
9D010F36      0C00   NOP
396:                         pauseEvent(1000);
9D010F38  308003E8   ADDIU A0, ZERO, 1000
9D010F3A  03E87680   OR T6, T0, RA
9D010F3C  76808168   JALS pauseEvent
9D010F40      0C00   NOP
397:                     }
398:                 }
9D010F58      0FBE   MOVE SP, S8
9D010F5A      4BF1   LW RA, 68(SP)
9D010F5C      4BD0   LW S8, 64(SP)
9D010F5E      4C25   ADDIU SP, SP, 72
9D010F60      45BF   JRC RA
9D010F62      0C00   NOP
399:                 
400:                 void dispText(DISPLAY* d, char* txt)
401:                 {
9D010F64      4FB0   ADDIU SP, SP, -8
9D010F66      CBC1   SW S8, 4(SP)
9D010F68      0FDD   MOVE S8, SP
9D010F6A  F89E0008   SW A0, 8(S8)
9D010F6E  F8BE000C   SW A1, 12(S8)
402:                     //char txt2[] = {" "};
403:                     //char txt[] = {"Kratky text"};
404:                     //char txt[] = {'J','i','\xFE','',' ','R','a','\xE7','p','l','i','\x9F','k','a','','','','','?','?',' '};
405:                     //char txt[] = {'\xA6','l','u','\x9C','o','u','\x9F','k','\xEC',' ','k','\xDE','\xE5',',',' ','\x9F','e','p','i','c','e'};
406:                 
407:                     //int a;
408:                     //short y=0, x=0;
409:                     
410:                     //FONT_SRC fo;
411:                     //setFontSrc(fontConsolas12x20, &fo);
412:                     //fo.foreColor=colWHITE;    //RGB16(31, 63, 31);
413:                     //fo.bgColor=colBLACK;    //RGB16(0, 0, 0);
414:                     
415:                     //d->drawString(txt, &fo, x, y);
416:                     //y+=fo.height;
417:                     //x+=d->textWidth(txt, &fo);
418:                     
419:                     /*
420:                     FONT_SRC foa;
421:                     setFontSrc(fontArial18, &foa);
422:                     foa.foreColor=colWHITE; //RGB16(31, 63, 31);
423:                     foa.bgColor=colBLACK;   //RGB16(0, 0, 0);    
424:                     
425:                     d->drawString(txt, &foa, 0, y);
426:                     y+=foa.height;
427:                     */
428:                     
429:                     
430:                     //short color=colWHITE;
431:                     //d->drawLine(0, 0, 319, 0, color);
432:                     //d->drawLine(319, 0, 319, 239, color);
433:                     //d->drawLine(319, 239, 0, 239, color);
434:                     //d->drawLine(0, 239, 0, 0, color);
435:                     
436:                 }
9D010F72      0FBE   MOVE SP, S8
9D010F74      4BC1   LW S8, 4(SP)
9D010F76      4C05   ADDIU SP, SP, 8
9D010F78      45BF   JRC RA
9D010F7A      0C00   NOP
437:                 
438:                 void usb_reaction(char command[], char data_out[])
439:                 {
9D010F7C      4FB0   ADDIU SP, SP, -8
9D010F7E      CBC1   SW S8, 4(SP)
9D010F80      0FDD   MOVE S8, SP
9D010F82  F89E0008   SW A0, 8(S8)
9D010F86  F8BE000C   SW A1, 12(S8)
440:                     /*
441:                     if(command[0]==1)
442:                     {
443:                         dispText(&dispA, txt1);
444:                     }
445:                     else if(command[0]==2)
446:                     {
447:                         dispText(&dispA, txt2);
448:                     }
449:                     else if(command[0]==3)
450:                     {
451:                         dispText(&dispA, txt3);
452:                     }
453:                     else if(command[0]==4)
454:                     {
455:                         x=command[1];
456:                         y=command[2];
457:                     }
458:                     else if(command[0]==10)
459:                     {
460:                         dispA.setOrientation(command[1]);
461:                     }
462:                     else if(command[0]==11)
463:                     {
464:                         
465:                         dispA.setBrightness(command[1]);
466:                         
467:                         int a=command[1];
468:                         a=a*10;
469:                         //pwm_setPower(3, a);
470:                     }
471:                     else if(command[0]==20)
472:                     {
473:                         char t[2];
474:                         t[0]=command[1];
475:                         t[1]=0;
476:                         dispText(&dispA, t);
477:                     }
478:                     else if(command[0]==96)
479:                     {
480:                         //COLOR color;
481:                         short* c=(short*)&COLOR;
482:                         short col=c[command[1]];
483:                        
484:                         dispA.fillBox(command[2], command[3], command[4], command[5], col);
485:                     }    
486:                     else if(command[0]==97)
487:                     {
488:                         short* c=(short*)&COLOR;
489:                         short col=c[command[1]];
490:                         dispA.clear(col);
491:                     }
492:                     else if(command[0]==98)
493:                     {
494:                         dispA.clear(COLOR.White);
495:                     }
496:                     else if(command[0]==99)
497:                     {
498:                         dispA.clear(COLOR.Black);
499:                     }
500:                     else if(command[0]==100)
501:                     {
502:                         dispA.controlDisplay(command[1], command[2], command[3], command[4]);
503:                     }
504:                     */
505:                 
506:                 }
9D010F8A      0FBE   MOVE SP, S8
9D010F8C      4BC1   LW S8, 4(SP)
9D010F8E      4C05   ADDIU SP, SP, 8
9D010F90      45BF   JRC RA
9D010F92      0C00   NOP
507:                 void blick2()
508:                 {
9D010F94      4FF1   ADDIU SP, SP, -32
9D010F96      CBE7   SW RA, 28(SP)
9D010F98      CBC6   SW S8, 24(SP)
9D010F9A      0FDD   MOVE S8, SP
509:                     //RB7 
510:                 
511:                     LATBINV=0b10000000;
9D010F9C  41A2BF80   LUI V0, 0xBF80
9D010F9E  BF803060   LDC1 F28, 12384(ZERO)
9D010FA0  30600080   ADDIU V1, ZERO, 128
9D010FA4  F8622CEC   SW V1, 11500(V0)
9D010FA6      2CEC   ANDI S1, A2, 0x40
512:                     
513:                     while(1)
514:                     {
515:                         int a, b;
516:                         for(a=0; a<300000; a++)
9D010FA8  F81E0010   SW ZERO, 16(S8)
9D010FAC      CC26   B 0x9D010FFA
9D010FAE      0C00   NOP
9D010FF0  FC5E0010   LW V0, 16(S8)
9D010FF2  00106D20   ADD T5, S0, ZERO
9D010FF4      6D20   ADDIU V0, V0, 1
9D010FF6  F85E0010   SW V0, 16(S8)
9D010FFA  FC7E0010   LW V1, 16(S8)
9D010FFE  41A20004   LUI V0, 0x4
9D011002  504293E0   ORI V0, V0, -27680
9D011004  93E00043   SLTI RA, ZERO, 67
9D011006  00431350   SLT V0, V1, V0
9D011008  135040A2   ADDI K0, S0, 16546
9D01100A  40A2FFD1   BNEZC V0, 0x9D010FB0
9D01100C  FFD141A2   LW S8, 16802(S1)
517:                         {
518:                             b=a+1;
9D010FB0  FC5E0010   LW V0, 16(S8)
9D010FB2  00106D20   ADD T5, S0, ZERO
9D010FB4      6D20   ADDIU V0, V0, 1
9D010FB6  F85E0014   SW V0, 20(S8)
519:                             if(a % 1000 == 0)
9D010FBA  FCBE0010   LW A1, 16(S8)
9D010FBE  41A21062   LUI V0, 0x1062
9D010FC0  10625042   ADDI V1, V0, 20546
9D010FC2  50424DD3   ORI V0, V0, 19923
9D010FC4      4DD3   ADDIU SP, SP, 932
9D010FC6  00458B3C   MULT A1, V0
9D010FC8      8B3C   SB A2, 12(V1)
9D010FCA      4602   MFHI V0
9D010FCC  00623080   SRA V1, V0, 6
9D010FCE  30800045   ADDIU A0, ZERO, 69
9D010FD0  0045F880   SRA V0, A1, 31
9D010FD2  F88005A7   SW A0, 1447(ZERO)
9D010FD4      05A7   SUBU V1, V1, V0
9D010FD6      0C83   MOVE A0, V1
9D010FD8      2544   SLL V0, A0, 2
9D010FDA      0C82   MOVE A0, V0
9D010FDC      254A   SLL V0, A0, 5
9D010FDE      0545   SUBU V0, V0, A0
9D010FE0      0534   ADDU V0, V0, V1
9D010FE2      2526   SLL V0, V0, 3
9D010FE4      05AB   SUBU V1, A1, V0
9D010FE6  40A30003   BNEZC V1, 0x9D010FF0
9D010FE8  00037680   OR T6, V1, ZERO
520:                             {
521:                                 doEvents();
9D010FEA  76807F8E   JALS doEvents
9D010FEE      0C00   NOP
522:                             }
523:                         }
524:                         
525:                         LATBINV=0b10000000;
9D01100E  41A2BF80   LUI V0, 0xBF80
9D011010  BF803060   LDC1 F28, 12384(ZERO)
9D011012  30600080   ADDIU V1, ZERO, 128
9D011016  F8622CEC   SW V1, 11500(V0)
9D011018      2CEC   ANDI S1, A2, 0x40
526:                     }
9D01101A      CFC6   B 0x9D010FA8
9D01101C      0C00   NOP
9D01101E      0C00   NOP
527:                     
528:                 }
529:                 
530:                 void loadColorMap(short cm[])
531:                 {
9D011020      4FF1   ADDIU SP, SP, -32
9D011022      CBE7   SW RA, 28(SP)
9D011024      CBC6   SW S8, 24(SP)
9D011026      CA05   SW S0, 20(SP)
9D011028      0FDD   MOVE S8, SP
9D01102A  F89E0020   SW A0, 32(S8)
9D01102C  00200C80   SRA AT, ZERO, 1
532:                 
533:                     //green
534:                     cm[0]=RGB16(0, 0, 0);
9D01102E      0C80   MOVE A0, ZERO
9D011030      0CA0   MOVE A1, ZERO
9D011032      0CC0   MOVE A2, ZERO
9D011034  768078E2   JALS RGB16
9D011036  78E20C00   ADDIUPC AT, 25702400
9D011038      0C00   NOP
9D01103A  00623B3C   SEH V1, V0
9D01103C  3B3CFC5E   SH T9, -930(GP)
9D01103E  FC5E0020   LW V0, 32(S8)
9D011040  0020A9A0   SUB S5, ZERO, AT
9D011042      A9A0   SH V1, 0(V0)
535:                     cm[1]=RGB16(0, 4, 0);
9D011044  FC5E0020   LW V0, 32(S8)
9D011048  32020002   ADDIU S0, V0, 2
9D01104A  00020C80   SRA ZERO, V0, 1
9D01104C      0C80   MOVE A0, ZERO
9D01104E      EE84   LI A1, 4
9D011050      0CC0   MOVE A2, ZERO
9D011052  768078E2   JALS RGB16
9D011054  78E20C00   ADDIUPC AT, 25702400
9D011056      0C00   NOP
9D011058  00423B3C   SEH V0, V0
9D01105A  3B3CA900   SH T9, -22272(GP)
9D01105C      A900   SH V0, 0(S0)
536:                     cm[2]=RGB16(0, 8, 0);
9D01105E  FC5E0020   LW V0, 32(S8)
9D011062      6C22   ADDIU S0, V0, 4
9D011064      0C80   MOVE A0, ZERO
9D011066      EE88   LI A1, 8
9D011068      0CC0   MOVE A2, ZERO
9D01106A  768078E2   JALS RGB16
9D01106C  78E20C00   ADDIUPC AT, 25702400
9D01106E      0C00   NOP
9D011070  00423B3C   SEH V0, V0
9D011072  3B3CA900   SH T9, -22272(GP)
9D011074      A900   SH V0, 0(S0)
537:                     cm[3]=RGB16(0, 12, 0);
9D011076  FC5E0020   LW V0, 32(S8)
9D01107A  32020006   ADDIU S0, V0, 6
9D01107C  00060C80   SRA ZERO, A2, 1
9D01107E      0C80   MOVE A0, ZERO
9D011080      EE8C   LI A1, 12
9D011082      0CC0   MOVE A2, ZERO
9D011084  768078E2   JALS RGB16
9D011086  78E20C00   ADDIUPC AT, 25702400
9D011088      0C00   NOP
9D01108A  00423B3C   SEH V0, V0
9D01108C  3B3CA900   SH T9, -22272(GP)
9D01108E      A900   SH V0, 0(S0)
538:                 
539:                     cm[4]=RGB16(0, 16, 0);
9D011090  FC5E0020   LW V0, 32(S8)
9D011094      6C24   ADDIU S0, V0, 8
9D011096      0C80   MOVE A0, ZERO
9D011098      EE90   LI A1, 16
9D01109A      0CC0   MOVE A2, ZERO
9D01109C  768078E2   JALS RGB16
9D01109E  78E20C00   ADDIUPC AT, 25702400
9D0110A0      0C00   NOP
9D0110A2  00423B3C   SEH V0, V0
9D0110A4  3B3CA900   SH T9, -22272(GP)
9D0110A6      A900   SH V0, 0(S0)
540:                     cm[5]=RGB16(0, 20, 0);
9D0110A8  FC5E0020   LW V0, 32(S8)
9D0110AC  3202000A   ADDIU S0, V0, 10
9D0110AE  000A0C80   SRA ZERO, T2, 1
9D0110B0      0C80   MOVE A0, ZERO
9D0110B2      EE94   LI A1, 20
9D0110B4      0CC0   MOVE A2, ZERO
9D0110B6  768078E2   JALS RGB16
9D0110B8  78E20C00   ADDIUPC AT, 25702400
9D0110BA      0C00   NOP
9D0110BC  00423B3C   SEH V0, V0
9D0110BE  3B3CA900   SH T9, -22272(GP)
9D0110C0      A900   SH V0, 0(S0)
541:                     cm[6]=RGB16(0, 24, 0);
9D0110C2  FC5E0020   LW V0, 32(S8)
9D0110C6      6C26   ADDIU S0, V0, 12
9D0110C8      0C80   MOVE A0, ZERO
9D0110CA      EE98   LI A1, 24
9D0110CC      0CC0   MOVE A2, ZERO
9D0110CE  768078E2   JALS RGB16
9D0110D0  78E20C00   ADDIUPC AT, 25702400
9D0110D2      0C00   NOP
9D0110D4  00423B3C   SEH V0, V0
9D0110D6  3B3CA900   SH T9, -22272(GP)
9D0110D8      A900   SH V0, 0(S0)
542:                     cm[7]=RGB16(0, 28, 0);
9D0110DA  FC5E0020   LW V0, 32(S8)
9D0110DE  3202000E   ADDIU S0, V0, 14
9D0110E0  000E0C80   SRA ZERO, T6, 1
9D0110E2      0C80   MOVE A0, ZERO
9D0110E4      EE9C   LI A1, 28
9D0110E6      0CC0   MOVE A2, ZERO
9D0110E8  768078E2   JALS RGB16
9D0110EA  78E20C00   ADDIUPC AT, 25702400
9D0110EC      0C00   NOP
9D0110EE  00423B3C   SEH V0, V0
9D0110F0  3B3CA900   SH T9, -22272(GP)
9D0110F2      A900   SH V0, 0(S0)
543:                 
544:                     cm[8]=RGB16(0, 32, 0);
9D0110F4  FC5E0020   LW V0, 32(S8)
9D0110F6  00206C28   MOVN T5, ZERO, AT
9D0110F8      6C28   ADDIU S0, V0, 16
9D0110FA      0C80   MOVE A0, ZERO
9D0110FC      EEA0   LI A1, 32
9D0110FE      0CC0   MOVE A2, ZERO
9D011100  768078E2   JALS RGB16
9D011102  78E20C00   ADDIUPC AT, 25702400
9D011104      0C00   NOP
9D011106  00423B3C   SEH V0, V0
9D011108  3B3CA900   SH T9, -22272(GP)
9D01110A      A900   SH V0, 0(S0)
545:                     cm[9]=RGB16(0, 36, 0);
9D01110C  FC5E0020   LW V0, 32(S8)
9D011110  32020012   ADDIU S0, V0, 18
9D011112  00120C80   SRA ZERO, S2, 1
9D011114      0C80   MOVE A0, ZERO
9D011116      EEA4   LI A1, 36
9D011118      0CC0   MOVE A2, ZERO
9D01111A  768078E2   JALS RGB16
9D01111C  78E20C00   ADDIUPC AT, 25702400
9D01111E      0C00   NOP
9D011120  00423B3C   SEH V0, V0
9D011122  3B3CA900   SH T9, -22272(GP)
9D011124      A900   SH V0, 0(S0)
546:                     cm[10]=RGB16(0, 40, 0);
9D011126  FC5E0020   LW V0, 32(S8)
9D01112A      6C2A   ADDIU S0, V0, 20
9D01112C      0C80   MOVE A0, ZERO
9D01112E      EEA8   LI A1, 40
9D011130      0CC0   MOVE A2, ZERO
9D011132  768078E2   JALS RGB16
9D011134  78E20C00   ADDIUPC AT, 25702400
9D011136      0C00   NOP
9D011138  00423B3C   SEH V0, V0
9D01113A  3B3CA900   SH T9, -22272(GP)
9D01113C      A900   SH V0, 0(S0)
547:                     cm[11]=RGB16(0, 44, 0);
9D01113E  FC5E0020   LW V0, 32(S8)
9D011142  32020016   ADDIU S0, V0, 22
9D011144  00160C80   SRA ZERO, S6, 1
9D011146      0C80   MOVE A0, ZERO
9D011148      EEAC   LI A1, 44
9D01114A      0CC0   MOVE A2, ZERO
9D01114C  768078E2   JALS RGB16
9D01114E  78E20C00   ADDIUPC AT, 25702400
9D011150      0C00   NOP
9D011152  00423B3C   SEH V0, V0
9D011154  3B3CA900   SH T9, -22272(GP)
9D011156      A900   SH V0, 0(S0)
548:                 
549:                     cm[12]=RGB16(0, 48, 0);
9D011158  FC5E0020   LW V0, 32(S8)
9D01115A  00206C2C   EXT AT, ZERO, 16, 14
9D01115C      6C2C   ADDIU S0, V0, 24
9D01115E      0C80   MOVE A0, ZERO
9D011160      EEB0   LI A1, 48
9D011162      0CC0   MOVE A2, ZERO
9D011164  768078E2   JALS RGB16
9D011166  78E20C00   ADDIUPC AT, 25702400
9D011168      0C00   NOP
9D01116A  00423B3C   SEH V0, V0
9D01116C  3B3CA900   SH T9, -22272(GP)
9D01116E      A900   SH V0, 0(S0)
550:                     cm[13]=RGB16(0, 52, 0);
9D011170  FC5E0020   LW V0, 32(S8)
9D011174  3202001A   ADDIU S0, V0, 26
9D011176  001A0C80   SRA ZERO, K0, 1
9D011178      0C80   MOVE A0, ZERO
9D01117A      EEB4   LI A1, 52
9D01117C      0CC0   MOVE A2, ZERO
9D01117E  768078E2   JALS RGB16
9D011180  78E20C00   ADDIUPC AT, 25702400
9D011182      0C00   NOP
9D011184  00423B3C   SEH V0, V0
9D011186  3B3CA900   SH T9, -22272(GP)
9D011188      A900   SH V0, 0(S0)
551:                     cm[14]=RGB16(0, 56, 0);
9D01118A  FC5E0020   LW V0, 32(S8)
9D01118E  3202001C   ADDIU S0, V0, 28
9D011190  001C0C80   SRA ZERO, GP, 1
9D011192      0C80   MOVE A0, ZERO
9D011194      EEB8   LI A1, 56
9D011196      0CC0   MOVE A2, ZERO
9D011198  768078E2   JALS RGB16
9D01119A  78E20C00   ADDIUPC AT, 25702400
9D01119C      0C00   NOP
9D01119E  00423B3C   SEH V0, V0
9D0111A0  3B3CA900   SH T9, -22272(GP)
9D0111A2      A900   SH V0, 0(S0)
552:                     cm[15]=RGB16(0, 60, 0); 
9D0111A4  FC5E0020   LW V0, 32(S8)
9D0111A8  3202001E   ADDIU S0, V0, 30
9D0111AA  001E0C80   SRA ZERO, S8, 1
9D0111AC      0C80   MOVE A0, ZERO
9D0111AE      EEBC   LI A1, 60
9D0111B0      0CC0   MOVE A2, ZERO
9D0111B2  768078E2   JALS RGB16
9D0111B4  78E20C00   ADDIUPC AT, 25702400
9D0111B6      0C00   NOP
9D0111B8  00423B3C   SEH V0, V0
9D0111BA  3B3CA900   SH T9, -22272(GP)
9D0111BC      A900   SH V0, 0(S0)
553:                     
554:                     /*
555:                     //White 
556:                     cm[0]=RGB16(0, 0, 0);
557:                     cm[1]=RGB16(2, 4, 2);
558:                     cm[2]=RGB16(4, 8, 4);
559:                     cm[3]=RGB16(6, 12, 6);
560:                 
561:                     cm[4]=RGB16(8, 16, 8);
562:                     cm[5]=RGB16(10, 20, 10);
563:                     cm[6]=RGB16(12, 24, 12);
564:                     cm[7]=RGB16(14, 28, 14);
565:                 
566:                     cm[8]=RGB16(16, 32, 16);
567:                     cm[9]=RGB16(18, 36, 18);
568:                     cm[10]=RGB16(20, 40, 20);
569:                     cm[11]=RGB16(22, 44, 22);
570:                 
571:                     cm[12]=RGB16(24, 48, 24);
572:                     cm[13]=RGB16(26, 52, 26);
573:                     cm[14]=RGB16(28, 56, 28);
574:                     cm[15]=RGB16(30, 60, 30);    
575:                     */
576:                 }
9D0111BE      0FBE   MOVE SP, S8
9D0111C0      4BE7   LW RA, 28(SP)
9D0111C2      4BC6   LW S8, 24(SP)
9D0111C4      4A05   LW S0, 20(SP)
9D0111C6      4C11   ADDIU SP, SP, 32
9D0111C8      45BF   JRC RA
9D0111CA      0C00   NOP
577:                 
578:                 void testDisp1306()
579:                 {
9D0111CC      4FCD   ADDIU SP, SP, -104
9D0111CE      CBF9   SW RA, 100(SP)
9D0111D0      CBD8   SW S8, 96(SP)
9D0111D2      0FDD   MOVE S8, SP
580:                     //test ssd1306 SPI, def.h definuje USE_DISP1306, SYSDISPLAY_1306SPI, USE_SYSTEMFONT_FIXEDx
581:                     //modul globals inicializuje driver, portWriter a fontSys
582:                     //x v nazvu fontu znamena, ze se nejedna o std. font (fileID=0x3)
583:                     
584:                     
585:                     //pouzije v globals definovany fontSys
586:                     //char txt[]="\x9Fslo \x7F\x43 ";
587:                     //graphics.drawString("ABCdefghijklmnop", NULL, 0, 0);
588:                     //graphics.drawString("1234567890-+*/WW", NULL, 0, 16);
589:                     //graphics.drawString(txt, NULL, 0, 32);
590:                 
591:                     //velky font 32x16
592:                     
593:                     //IMAGE_SRC f;
594:                     //setFontSrc(&font_rock32x, &f);
595:                     //f.foreColor=RGB16(31, 63, 31);
596:                     //graphics.drawString("12345678", &f, 0, 0);
597:                     //graphics.drawString("ABC def", &f, 0, 32);
598:                     
599:                     //maximalni font 48x22 (max. 5 znaku za radek)
600:                     //IMAGE_SRC fs;
601:                     //setFontSrc(&font_rock48x, &fs);
602:                     //fs.foreColor=RGB16(31, 63, 31);
603:                     //graphics.drawString("12:55", &fs, 8, 8);
604:                     
605:                     //nejmensi font 8x8
606:                     //IMAGE_SRC fs;
607:                     //setFontSrc(&font_fixed8x, &fs);
608:                     //fs.foreColor=RGB16(31, 63, 31);
609:                     //graphics.drawString("ABCDEFGHIJKLMNOP", &fs, 0, 40);
610:                     //graphics.drawString("abcdefghijklmnop", &fs, 0, 48);
611:                     
612:                     //image 128x64
613:                     IMAGE_SRC im;
614:                     setImageSrc(&image1306x, &im);
9D0111D4  41A29D00   LUI V0, 0x9D00
9D0111D6  9D003082   LWC1 F8, 12418(ZERO)
9D0111D8  30825DD8   ADDIU A0, V0, 24024
9D0111DC  305E0010   ADDIU V0, S8, 16
9D0111E0      0CA2   MOVE A1, V0
9D0111E2  76807574   JALS setImageSrc
9D0111E4  75740C00   JALS 0x9AE81800
9D0111E6      0C00   NOP
615:                     graphics.drawImage(&im, 0, 0);
9D0111E8  41A28000   LUI V0, 0x8000
9D0111EC  304206C0   ADDIU V0, V0, 1728
9D0111EE      06C0   ADDU A1, S0, A0
9D0111F0      6925   LW V0, 20(V0)
9D0111F2  307E0010   ADDIU V1, S8, 16
9D0111F6      0C83   MOVE A0, V1
9D0111F8      0CA0   MOVE A1, ZERO
9D0111FA      0CC0   MOVE A2, ZERO
9D0111FC      45E2   JALRS16 V0
9D0111FE      0C00   NOP
616:                     
617:                     //regulace neni temer poznat
618:                     //dispSys.setBrightness(255);
619:                     
620:                     //inverze
621:                     //dispSys.controlDisplay(0xff, 0xff, 0xff, 1);
622:                     
623:                     //fill box
624:                     //graphics.fillBox(0, 0, 128, 64, 0b10101010);
625:                     
626:                     //print, musi byt nastaven systemovy font
627:                     //graphics.print("Radek c.1");
628:                     //graphics.print("Radek c.2");
629:                     //graphics.print("Radek c.3");
630:                     //graphics.print("Radek c.4");
631:                     //graphics.print("Radek c.5");
632:                     //graphics.print("Radek c.6");
633:                     graphics.print(txt1);
9D011200  41A28000   LUI V0, 0x8000
9D011204  304206C0   ADDIU V0, V0, 1728
9D011206      06C0   ADDU A1, S0, A0
9D011208      6927   LW V0, 28(V0)
9D01120A  41A38000   LUI V1, 0x8000
9D01120E  30830B70   ADDIU A0, V1, 2928
9D011210      0B70   LBU A2, 0(A3)
9D011212      45E2   JALRS16 V0
9D011214      0C00   NOP
634:                 }
9D011216      0FBE   MOVE SP, S8
---  d:/bos/bos/app1.c  ---------------------------------------------------------------------------------
1:                   #include <xc.h>
2:                   #include <stdio.h>
3:                   //#include <stdlib.h>
4:                   #include "asm.h"
5:                   #include "def.h"
6:                   #include "fnc.h"
7:                   #include "graphics.h"
8:                   #include "timer.h"
9:                   
10:                  #ifdef PIC32MZ
11:                  
12:                  #define     _LED_INV_REG    LATHINV
13:                  #define     _LED_INV_VAL    0b001
14:                  
15:                  #endif
16:                  
17:                  #ifdef PIC32MM0064
18:                  
19:                  #define     _LED_INV_REG    LATBINV
20:                  #define     _LED_INV_VAL    0b100000
21:                  
22:                  #endif  
23:                  
24:                  #ifdef PIC32MM0256
25:                  
26:                  #define     _LED_INV_REG    LATBINV
27:                  #define     _LED_INV_VAL    0b100000          //RB5                
28:                  
29:                  #endif
30:                  
31:                  
32:                  int power=1;
33:                  
34:                  void m1_start();
35:                  void floatToString(float f, char* ret, int dec);
36:                  void floatToStringFormat(float f, char* ret, int len, int dec);
37:                  float rndFloat(float f, int dec);
38:                  float rnd4(float f);
39:                  void write_ad();
40:                  
41:                  void draw();
42:                  void on_button(int, int, int);
43:                  void write_button(int, int, int);
44:                  void write_power();
45:                  
46:                  //#define     STACK_SIZE       1024
47:                  //int m1_stackSize=STACK_SIZE;
48:                  //char  m1_stackBase[STACK_SIZE];
49:                  
50:                  //char* m1_stack=stack+STACK_SIZE-4;
51:                  
52:                  inline void setSP();
53:                  
54:                  //extern int drawString(char font, char x, char y, char* string);
55:                  
56:                  char result[17];
57:                  char h1_string[8];
58:                  char h2_string[8];
59:                  char h3_string[8];
60:                  //stringCreator sc={result, 17, NULL, NULL, NULL, NULL};
61:                  int time_s=0;
62:                  int time_m=0;
63:                  char interval_ad=0;
64:                  char interval_bar=0;
65:                  int prew_point=-1;
66:                  
67:                  extern int usb_value;
68:                  
69:                  static void blick1();
70:                  void drawGraph();
71:                  
72:                  void m1_start()
73:                  {
9D012A5C      4FE9   ADDIU SP, SP, -48
9D012A5E      CBEB   SW RA, 44(SP)
9D012A60      CBCA   SW S8, 40(SP)
9D012A62      0FDD   MOVE S8, SP
74:                      blick1();
9D012A64  76809632   JALS blick1
9D012A66  96320C00   BEQ S2, S1, 0x9D01426A
9D012A68      0C00   NOP
75:                      
76:                      
77:                      //usbDevice_init();
78:                      
79:                      //drawText(0, "VELKA PISMENA", 0, 1, FONT1306_MID);
80:                      //blick();
81:                      
82:                      //char num[8];
83:                      //char volt[]="Voltage is \0";
84:                      
85:                      
86:                      /*
87:                      //char test1[]={"test 1\0"};
88:                      printString(0, "test 1\0");
89:                      
90:                      //char test2[]={"test 1\0"};
91:                      printString(0, "test 1\0");
92:                      
93:                      //char test3[]={"test 3\0"};
94:                      printString(0, "test 3\0");
95:                      
96:                      //char test4[]={"dlouhy test 4.15\0"};
97:                      printString(0, "dlouhy test 4.15\0");
98:                      
99:                      //char test5[]={"Display 1306\0"};
100:                     printString(0, "Display 1306\0");
101:                     
102:                     
103:                     //char test6[]={"A/D conv. v.1\0"};
104:                     printString(0, "A/D conv. v.1\0");    
105:                     
106:                     //char test7[]={"OS-MM v.4\0"};
107:                     printString(0, "OS-MM v.4\0");  
108:                       
109:                     displayClear(0);
110:                     */
111:                     
112:                     float f=1.1111;
9D012A6A  41A29D00   LUI V0, 0x9D00
9D012A6C  9D00FC42   LWC1 F8, -958(ZERO)
9D012A6E  FC4201FC   LW V0, 508(V0)
9D012A72  F85E0014   SW V0, 20(S8)
113:                     floatToString(f, result, 8);
9D012A76  FC9E0014   LW A0, 20(S8)
9D012A7A  41A28000   LUI V0, 0x8000
9D012A7E  30A20400   ADDIU A1, V0, 1024
9D012A80      0400   ADDU S0, S0, S0
9D012A82      EF08   LI A2, 8
9D012A84  76808546   JALS floatToString
9D012A86      8546   MOVEP A2, A3, V1, S0
9D012A88      0C00   NOP
114:                     
115:                              
116:                     int x=0xFF;
9D012A8A  304000FF   ADDIU V0, ZERO, 255
9D012A8E  F85E0018   SW V0, 24(S8)
117:                     byteToChar(x, result, 1);
9D012A92  FC9E0018   LW A0, 24(S8)
9D012A96  41A28000   LUI V0, 0x8000
9D012A9A  30A20400   ADDIU A1, V0, 1024
9D012A9C      0400   ADDU S0, S0, S0
9D012A9E      EF01   LI A2, 1
9D012AA0  768081CA   JALS byteToChar
9D012AA4      0C00   NOP
118:                     
119:                     x=1;
9D012AA6      ED01   LI V0, 1
9D012AA8  F85E0018   SW V0, 24(S8)
120:                     byteToChar(x, result, 3);
9D012AAC  FC9E0018   LW A0, 24(S8)
9D012AB0  41A28000   LUI V0, 0x8000
9D012AB4  30A20400   ADDIU A1, V0, 1024
9D012AB6      0400   ADDU S0, S0, S0
9D012AB8      EF03   LI A2, 3
9D012ABA  768081CA   JALS byteToChar
9D012ABE      0C00   NOP
121:                     
122:                     x=158;
9D012AC0  3040009E   ADDIU V0, ZERO, 158
9D012AC4  F85E0018   SW V0, 24(S8)
123:                     byteToChar(x, result, 1);
9D012AC8  FC9E0018   LW A0, 24(S8)
9D012ACC  41A28000   LUI V0, 0x8000
9D012AD0  30A20400   ADDIU A1, V0, 1024
9D012AD2      0400   ADDU S0, S0, S0
9D012AD4      EF01   LI A2, 1
9D012AD6  768081CA   JALS byteToChar
9D012ADA      0C00   NOP
124:                     
125:                     
126:                     uintToChar(x, result, 1);
9D012ADC  FC5E0018   LW V0, 24(S8)
9D012AE0      0C82   MOVE A0, V0
9D012AE2  41A28000   LUI V0, 0x8000
9D012AE6  30A20400   ADDIU A1, V0, 1024
9D012AE8      0400   ADDU S0, S0, S0
9D012AEA      EF01   LI A2, 1
9D012AEC  76808196   JALS uintToChar
9D012AF0      0C00   NOP
127:                     
128:                     ubtn_regEvent(&on_button);
9D012AF2  41A29D01   LUI V0, 0x9D01
9D012AF4  9D013082   LWC1 F8, 12418(AT)
9D012AF6  30822BCD   ADDIU A0, V0, 11213
9D012AF8      2BCD   LHU A3, 26(A0)
9D012AFA  76809200   JALS ubtn_regEvent
9D012AFC  92000C00   SLTI S0, ZERO, 3072
9D012AFE      0C00   NOP
129:                     
130:                     //char* img=displayGetImageData(0, 5);
131:                     //drawImage(0, img, 0, 0);                        //BAT. icon
132:                     
133:                     //disp1306_drawHBar8(0, 20, 40, 0, 16);
134:                     
135:                     //drawText(0, "VELKA PISMENA", 0, 1, FONT1306_MID);
136:                     
137:                     //drawText(0, "Tady je nejaky", 0, 2, FONT1306_MID);
138:                     
139:                     //drawText(0, "Temp.", 0, 3, FONT1306_MID);
140:                     //disp1306_drawHBar16(0, 20, 40, 48, 12);
141:                     
142:                     
143:                     //drawText(0, "I  I  I  I  I  I", 0, 1, FONT1306_MID);
144:                     //drawText(0, "0  1  2  3  4  5", 0, 2, FONT1306_MID);
145:                     //drawGraph();
146:                     //printString(0, "Jedna");
147:                     //printString(0, "Dva");
148:                     //printString(0, "Tri");
149:                     //drawText(0, "11111", 0, 0, FONT1306_MID);
150:                     //drawText(0, "22222", 0, 1, FONT1306_MID);
151:                     //drawText(0, "33333", 0, 3, FONT1306_MID);
152:                     
153:                     timer1_regEventInterval(&interval_ad, 500);
9D012B00  309C8038   ADDIU A0, GP, -32712
9D012B04  30A001F4   ADDIU A1, ZERO, 500
9D012B06  01F47680   OR T6, S4, T7
9D012B08  76800036   JALS timer1_regEventInterval
9D012B0A  00360C00   SLL AT, S6, 1
9D012B0C      0C00   NOP
154:                     timer1_regEventInterval(&interval_bar, 100);
9D012B0E  309C8039   ADDIU A0, GP, -32711
9D012B12      EEE4   LI A1, 100
9D012B14  76800036   JALS timer1_regEventInterval
9D012B16  00360C00   SLL AT, S6, 1
9D012B18      0C00   NOP
155:                     
156:                     //pwm_on(1, 1);
157:                     //pwm_on(2, 1);
158:                     
159:                     drawGraph();
9D012B1A  768095D6   JALS drawGraph
9D012B1C  95D60C00   BEQ S6, T6, 0x9D014320
9D012B1E      0C00   NOP
160:                     
161:                     int c=5, b=0;
9D012B20      ED05   LI V0, 5
9D012B22  F85E001C   SW V0, 28(S8)
9D012B26  F81E0020   SW ZERO, 32(S8)
162:                     int s=0;
9D012B2A  F81E0024   SW ZERO, 36(S8)
163:                     while(1)
164:                     {
165:                         //do LATxINV zapise 1 na prislusnou pozici
166:                         _LED_INV_REG = _LED_INV_VAL;
9D012B2E  41A2BF80   LUI V0, 0xBF80
9D012B30  BF80EDA0   LDC1 F28, -4704(ZERO)
9D012B32      EDA0   LI V1, 32
9D012B34  F8622CEC   SW V1, 11500(V0)
9D012B36      2CEC   ANDI S1, A2, 0x40
167:                         
168:                         int a;
169:                         for(a=1; a<500000; a++)
9D012B38      ED01   LI V0, 1
9D012B3A  F85E0010   SW V0, 16(S8)
9D012B3E      CC2A   B 0x9D012B94
9D012B40      0C00   NOP
9D012B8A  FC5E0010   LW V0, 16(S8)
9D012B8C  00106D20   ADD T5, S0, ZERO
9D012B8E      6D20   ADDIU V0, V0, 1
9D012B90  F85E0010   SW V0, 16(S8)
9D012B94  FC7E0010   LW V1, 16(S8)
9D012B98  41A20007   LUI V0, 0x7
9D012B9C  5042A120   ORI V0, V0, -24288
9D012BA0  00431350   SLT V0, V1, V0
9D012BA2  135040A2   ADDI K0, S0, 16546
9D012BA4  40A2FFCD   BNEZC V0, 0x9D012B42
9D012BA6  FFCDCFC2   LW S8, -12350(T5)
170:                         {
171:                             if(a % 500 == 0) { doEvents(); } 
9D012B42  FCBE0010   LW A1, 16(S8)
9D012B46  41A21062   LUI V0, 0x1062
9D012B48  10625042   ADDI V1, V0, 20546
9D012B4A  50424DD3   ORI V0, V0, 19923
9D012B4C      4DD3   ADDIU SP, SP, 932
9D012B4E  00458B3C   MULT A1, V0
9D012B50      8B3C   SB A2, 12(V1)
9D012B52      4602   MFHI V0
9D012B54  00622880   SRA V1, V0, 5
9D012B56      2880   LHU S1, 0(S0)
9D012B58  0045F880   SRA V0, A1, 31
9D012B5A  F88005A7   SW A0, 1447(ZERO)
9D012B5C      05A7   SUBU V1, V1, V0
9D012B5E      0C83   MOVE A0, V1
9D012B60      2544   SLL V0, A0, 2
9D012B62      0C82   MOVE A0, V0
9D012B64      254A   SLL V0, A0, 5
9D012B66      0545   SUBU V0, V0, A0
9D012B68      0534   ADDU V0, V0, V1
9D012B6A      2524   SLL V0, V0, 2
9D012B6C      05AB   SUBU V1, A1, V0
9D012B6E  40A30003   BNEZC V1, 0x9D012B78
9D012B70  00037680   OR T6, V1, ZERO
9D012B72  76807F8E   JALS doEvents
9D012B76      0C00   NOP
172:                            
173:                             if(interval_ad>0)
9D012B78  145C8038   LBU V0, -32712(GP)
9D012B7C  40E20005   BEQZC V0, 0x9D012B8A
9D012B7E  00057680   OR T6, A1, ZERO
174:                             {
175:                                 write_ad();
9D012B80  768095DE   JALS write_ad
9D012B82  95DE0C00   BEQ S8, T6, 0x9D014386
9D012B84      0C00   NOP
176:                                 interval_ad=0;
9D012B86  181C8038   SB ZERO, -32712(GP)
177:                             }
178:                             
179:                             if(interval_bar>0)
180:                             {
181:                                 //s++;
182:                                 //if(s>20){s=0;}
183:                                 //disp1306_drawHBar8(0, 20, 40, 0, s);
184:                                 //interval_bar=0;
185:                                 
186:                                 //int pp=pwm_getProc(1);
187:                                 //if(pp!=power)
188:                                 //{
189:                                 //    power=pp;
190:                                 //    write_power();
191:                                 //}
192:                             }            
193:                         }
194:                         //b++;
195:                         //s++;
196:                         
197:                         //if(s==6){s=0;}
198:                         //disp1306_drawBattery(0, 46, 8, s);
199:                         
200:                         //if(s>20){s=0;}
201:                         //disp1306_drawHBar8(0, 20, 40, 0, s);
202:                         //disp1306_drawHBar16(0, 20, 40, 48, s);
203:                         
204:                         
205:                         //time_s++;
206:                         //if(time_s==60) { time_s=0; time_m++; }
207:                         //if(time_m==60){time_m=0;}
208:                         //draw();
209:                         
210:                         //if()
211:                         //displaySetContrast(0, b);
212:                         
213:                         //write_ad();
214:                         
215:                         //sprintf(num, "%d", b);
216:                         //createString(result, 17, "Vyltaje is ", num, NULL);
217:                         //printString(0, result); 
218:                         
219:                         //createStringStruct(sc);
220:                         //printString(0, sc.result); 
221:                         
222:                         /*
223:                         //sprintf(num, "%d", c);
224:                         floatToString((float)c*0.1, num, 1);
225:                         drawString(FONT1306_MID, 0, 3, num);
226:                         doEvents();
227:                         
228:                 
229:                         sprintf(num, "%d", c);
230:                         createString(res, 17, volt, num, unit);
231:                         drawString(FONT1306_MID, 0, 2, res);
232:                         */
233:                         
234:                         //c+=11;
235:                 
236:                     }
9D012BA8      CFC2   B 0x9D012B2E
9D012BAA      0C00   NOP
237:                 }
238:                 
239:                 void drawGraph()
240:                 {
9D012BAC      4FB0   ADDIU SP, SP, -8
9D012BAE      CBC1   SW S8, 4(SP)
9D012BB0      0FDD   MOVE S8, SP
241:                    
242:                     /*
243:                    //stupnice 0 ... 40 
244:                    drawText(0, "0             40", 0, 0, FONT1306_MID);         //zadava row a col
245:                    drawString(0, "10", 24, 0, FONT1306_MID);       //zadava se x a y
246:                    drawString(0, "20", 54, 0, FONT1306_MID);       //zadava se x a y
247:                    drawString(0, "30", 84, 0, FONT1306_MID);       //zadava se x a y
248:                    disp1306_drawScale8(0, 0, 16); 
249:                    
250:                    */
251:                    //stupnice min ... 0 ... max 
252:                     /*
253:                    drawText(0, "-      0       +", 0, 0, FONT1306_MID);         //zadava row a col
254:                    char* img=displayGetImageData(0, 21);
255:                    drawImage(0, img, 3, 16); 
256:                    */
257:                 }
9D012BB2      0FBE   MOVE SP, S8
9D012BB4      4BC1   LW S8, 4(SP)
9D012BB6      4C05   ADDIU SP, SP, 8
9D012BB8      45BF   JRC RA
9D012BBA      0C00   NOP
258:                 
259:                 void write_ad()
260:                 {
9D012BBC      4FB0   ADDIU SP, SP, -8
9D012BBE      CBC1   SW S8, 4(SP)
9D012BC0      0FDD   MOVE S8, SP
261:                     /*
262:                     int v1=usb_value; //adcscan_getValue(6);
263:                     int v2=adcscan_getValue(28);
264:                     //int v3=adcscan_getValue(4);
265:                     
266:                     char result[12];
267:                     char num[12];
268:                     
269:                     char* img;
270:                     int y=24;
271:                     //drawImage(0, img, 0, 0);                        
272:                     
273:                     int x=(int)((float)v1/4096.0 * (float)(128-7));
274:                     
275:                     if(x != prew_point)
276:                     {
277:                         if(prew_point > -1)
278:                         {
279:                             img=displayGetImageData(0, 20);
280:                             drawImage(0, img, prew_point, y);   
281:                         }
282:                         
283:                         //if(x>prew_point){x+=(x-prew_point)/4;}
284:                         //else {x-=(prew_point-x)/4;}
285:                         
286:                         img=displayGetImageData(0, 19);
287:                         drawImage(0, img, x, y);      
288:                         prew_point=x;
289:                     }
290:                     
291:                     
292:                 
293:                     
294:                     
295:                     intToChar(x, num, 1);
296:                     //formatRight(result, 5, num);
297:                     drawText(0, num, 0, 3, FONT1306_MID);
298:                     
299:                     intToChar(v1, num, 1);
300:                     //formatRight(result, 5, num);
301:                     drawText(0, num, 8, 3, FONT1306_MID);
302:                     */
303:                     
304:                     
305:                     
306:                     //intToChar(v2, num, 1);
307:                     //formatRight(result, 5, num);
308:                     //drawText(0, result, 0, 2, FONT1306_MID);
309:                     
310:                     //double max_graph=30;
311:                     //int val=(int) ((double)v1 / 4096.0 * max_graph);
312:                     //disp1306_drawHBar8(0, 30, 0, 0, val);
313:                     
314:                     //intToChar(v3, num, 1);
315:                     //formatRight(result, 5, num);
316:                     //drawText(0, result, 0, 3, FONT1306_MID);    
317:                 }
9D012BC2      0FBE   MOVE SP, S8
9D012BC4      4BC1   LW S8, 4(SP)
9D012BC6      4C05   ADDIU SP, SP, 8
9D012BC8      45BF   JRC RA
9D012BCA      0C00   NOP
318:                 
319:                 void on_button(int event, int button_value, int cnt)
320:                 {
9D012BCC      4FB0   ADDIU SP, SP, -8
9D012BCE      CBC1   SW S8, 4(SP)
9D012BD0      0FDD   MOVE S8, SP
9D012BD2  F89E0008   SW A0, 8(S8)
9D012BD6  F8BE000C   SW A1, 12(S8)
9D012BDA  F8DE0010   SW A2, 16(S8)
321:                     //write_button(event, button_value, cnt);
322:                     
323:                     if(event==UBTN_DOWN | event==UBTN_REPEAT)
324:                     {
325:                         /*
326:                         if(button_value==32)
327:                         {
328:                             //power = power << 1;//  (power*power) ;
329:                             //power=100;
330:                             //pwm_setPowerTarget(1, power, 95, 0);
331:                             //pwm_setPowerTarget(1, 0, power, 5, 50);
332:                             pwm_setPowerExp(1, 37, 3);
333:                             pwm_setPowerLinearProc(2, 100, 1, 5);
334:                             
335:                         }
336:                         else if(button_value==33)
337:                         {
338:                             //power = power >> 1; //(power*power) ;
339:                             //power=0;
340:                             //pwm_setPowerTarget(1, power, 95, 0);
341:                             //pwm_setPowerTarget(1, 0, power, 8, 50);
342:                             pwm_setPowerExp(1, 0, 1);
343:                             pwm_setPowerLinearProc(2, 0, 1, 5);
344:                         }
345:                         */
346:                     
347:                         //pwm_setPower(1, power);
348:                     
349:                         //char c[12];
350:                         //intToChar(power, c, 1);
351:                         //formatRight(c, 5, c);
352:                         //drawText(0, c, 10, 3, FONT1306_MID);
353:                     }
354:                 }
9D012BDE      0FBE   MOVE SP, S8
9D012BE0      4BC1   LW S8, 4(SP)
9D012BE2      4C05   ADDIU SP, SP, 8
9D012BE4      45BF   JRC RA
9D012BE6      0C00   NOP
355:                 
356:                 void write_power()
357:                 {
9D012BE8      4FED   ADDIU SP, SP, -40
9D012BEA      CBE9   SW RA, 36(SP)
9D012BEC      CBC8   SW S8, 32(SP)
9D012BEE      0FDD   MOVE S8, SP
358:                         char c[12];
359:                         intToChar(power, c, 1);
9D012BF0  FC5C8010   LW V0, -32752(GP)
9D012BF4      0C82   MOVE A0, V0
9D012BF6  305E0010   ADDIU V0, S8, 16
9D012BFA      0CA2   MOVE A1, V0
9D012BFC      EF01   LI A2, 1
9D012BFE  7680818A   JALS intToChar
9D012C02      0C00   NOP
360:                         formatRight(c, 5, c);
9D012C04  305E0010   ADDIU V0, S8, 16
9D012C08      0C82   MOVE A0, V0
9D012C0A      EE85   LI A1, 5
9D012C0C  305E0010   ADDIU V0, S8, 16
9D012C10      0CC2   MOVE A2, V0
9D012C12  768080DA   JALS formatRight
9D012C16      0C00   NOP
361:                         concat(c,"%", 12);
9D012C18  305E0010   ADDIU V0, S8, 16
9D012C1C      0C82   MOVE A0, V0
9D012C1E  41A29D00   LUI V0, 0x9D00
9D012C20  9D0030A2   LWC1 F8, 12450(ZERO)
9D012C22  30A201F8   ADDIU A1, V0, 504
9D012C24  01F8EF0C   INS T7, T8, 28, 2
9D012C26      EF0C   LI A2, 12
9D012C28  76808031   JALS concat
9D012C2C      0C00   NOP
362:                         //drawText(0, c, 10, 3, FONT1306_MID);    
363:                 }
9D012C2E      0FBE   MOVE SP, S8
9D012C30      4BE9   LW RA, 36(SP)
9D012C32      4BC8   LW S8, 32(SP)
9D012C34      4C15   ADDIU SP, SP, 40
9D012C36      45BF   JRC RA
364:                 
365:                 void write_button(int event, int button_value, int cnt)
366:                 {
9D012C38      4FB0   ADDIU SP, SP, -8
9D012C3A      CBC1   SW S8, 4(SP)
9D012C3C      0FDD   MOVE S8, SP
9D012C3E  F89E0008   SW A0, 8(S8)
9D012C42  F8BE000C   SW A1, 12(S8)
9D012C46  F8DE0010   SW A2, 16(S8)
367:                 
368:                     /*
369:                     char* s;
370:                     int l=0;
371:                     if(event==UBTN_DOWN)          {s="DOWN            ";}
372:                     else if(event==UBTN_UP)       {s="UP              ";}
373:                     else if(event==UBTN_DOWN_LONG){s="DOWN_LONG       ";}
374:                     else if(event==UBTN_UP_LONG)  {s="UP_LONG         ";}
375:                     else if(event==UBTN_REPEAT)   {s="REPEAT          ";}    
376:                 
377:                     
378:                     char c[12];
379:                 
380:                    
381:                     intToChar(cnt, c, 1);
382:                 
383:                     //sprintf(c, "%d", cnt);
384:                     
385:                     if(button_value==32)
386:                     {
387:                         drawText(0, s, 0, 1, FONT1306_MID);
388:                         drawText(0, c, 12, 1, FONT1306_MID);
389:                     }
390:                     
391:                     if(button_value==33)
392:                     {
393:                         drawText(0, s, 0, 2, FONT1306_MID);
394:                         drawText(0, c, 12, 2, FONT1306_MID);
395:                     }
396:                     */
397:                 
398:                 }
9D012C4A      0FBE   MOVE SP, S8
9D012C4C      4BC1   LW S8, 4(SP)
9D012C4E      4C05   ADDIU SP, SP, 8
9D012C50      45BF   JRC RA
9D012C52      0C00   NOP
399:                 
400:                 void draw()
401:                 {
9D012C54      4FB0   ADDIU SP, SP, -8
9D012C56      CBC1   SW S8, 4(SP)
9D012C58      0FDD   MOVE S8, SP
402:                     //date, time
403:                     /*
404:                     int date_d=21;
405:                     int date_m=7;
406:                     int date_y=17;
407:                     
408:                     int time_h=15;
409:                     //int time_m=32;
410:                     
411:                     sprintf(h1_string, "%02d", date_d);
412:                     sprintf(h2_string, "%02d", date_m);
413:                     sprintf(h3_string, "%4d", 2000 + date_y);
414:                     
415:                     createString(result, 17, h1_string, "/", h2_string, "/", h3_string, NULL);
416:                     drawString(0, result, 0, 0, FONT1306_MID);
417:                     
418:                     
419:                     sprintf(h1_string, "%02d", time_h);
420:                     sprintf(h2_string, "%02d", time_m);
421:                     sprintf(h3_string, "%02d", time_s);
422:                     
423:                     createString(result, 17, h1_string, ".", h2_string, ".", h3_string, NULL); // ":", h3_string, NULL);
424:                     drawString(0, result, 0, 1, FONT1306_BIG);
425:                     //drawString(0, h3_string, 14, 3, FONT1306_MID);
426:                     
427:                     */
428:                 }
9D012C5A      0FBE   MOVE SP, S8
9D012C5C      4BC1   LW S8, 4(SP)
9D012C5E      4C05   ADDIU SP, SP, 8
9D012C60      45BF   JRC RA
9D012C62      0C00   NOP
429:                 
430:                 static void blick1()
431:                 {
9D012C64      4FF1   ADDIU SP, SP, -32
9D012C66      CBE7   SW RA, 28(SP)
9D012C68      CBC6   SW S8, 24(SP)
9D012C6A      0FDD   MOVE S8, SP
432:                     while(1)
433:                     {
434:                         //do LATxINV zapise 1 na prislusnou pozici
435:                         _LED_INV_REG = _LED_INV_VAL;
9D012C6C  41A2BF80   LUI V0, 0xBF80
9D012C6E  BF80EDA0   LDC1 F28, -4704(ZERO)
9D012C70      EDA0   LI V1, 32
9D012C72  F8622CEC   SW V1, 11500(V0)
9D012C74      2CEC   ANDI S1, A2, 0x40
436:                         
437:                         int a, b=0;
9D012C76  F81E0014   SW ZERO, 20(S8)
438:                         for(a=0; a<190000; a++)
9D012C7A  F81E0010   SW ZERO, 16(S8)
9D012C7E      CC26   B 0x9D012CCC
9D012C80      0C00   NOP
9D012CC2  FC5E0010   LW V0, 16(S8)
9D012CC4  00106D20   ADD T5, S0, ZERO
9D012CC6      6D20   ADDIU V0, V0, 1
9D012CC8  F85E0010   SW V0, 16(S8)
9D012CCC  FC7E0010   LW V1, 16(S8)
9D012CD0  41A20002   LUI V0, 0x2
9D012CD4  5042E630   ORI V0, V0, -6608
9D012CD8  00431350   SLT V0, V1, V0
9D012CDA  135040A2   ADDI K0, S0, 16546
9D012CDC  40A2FFD1   BNEZC V0, 0x9D012C82
9D012CDE  FFD1CFC5   LW S8, -12347(S1)
439:                         {
440:                             b++;
9D012C82  FC5E0014   LW V0, 20(S8)
9D012C84  00146D20   ADD T5, S4, ZERO
9D012C86      6D20   ADDIU V0, V0, 1
9D012C88  F85E0014   SW V0, 20(S8)
441:                             if(a % 1000 == 0)
9D012C8C  FCBE0010   LW A1, 16(S8)
9D012C90  41A21062   LUI V0, 0x1062
9D012C92  10625042   ADDI V1, V0, 20546
9D012C94  50424DD3   ORI V0, V0, 19923
9D012C96      4DD3   ADDIU SP, SP, 932
9D012C98  00458B3C   MULT A1, V0
9D012C9A      8B3C   SB A2, 12(V1)
9D012C9C      4602   MFHI V0
9D012C9E  00623080   SRA V1, V0, 6
9D012CA0  30800045   ADDIU A0, ZERO, 69
9D012CA2  0045F880   SRA V0, A1, 31
9D012CA4  F88005A7   SW A0, 1447(ZERO)
9D012CA6      05A7   SUBU V1, V1, V0
9D012CA8      0C83   MOVE A0, V1
9D012CAA      2544   SLL V0, A0, 2
9D012CAC      0C82   MOVE A0, V0
9D012CAE      254A   SLL V0, A0, 5
9D012CB0      0545   SUBU V0, V0, A0
9D012CB2      0534   ADDU V0, V0, V1
9D012CB4      2526   SLL V0, V0, 3
9D012CB6      05AB   SUBU V1, A1, V0
9D012CB8  40A30003   BNEZC V1, 0x9D012CC2
9D012CBA  00037680   OR T6, V1, ZERO
442:                             {
443:                                 doEvents();
9D012CBC  76807F8E   JALS doEvents
9D012CC0      0C00   NOP
444:                             }
445:                         }
446:                     }    
9D012CE0      CFC5   B 0x9D012C6C
447:                 }
448:                 
449:                 
450:                 
451:                 
452:                 
---  d:/bos/bos/adc_scan.c  -----------------------------------------------------------------------------
1:                   #include <xc.h>
2:                   #include <stdio.h>
3:                   //#include <stdlib.h>
4:                   #include "def.h"
5:                   
6:                   /*
7:                    * 28 pin SOIC, SSOP
8:                    * ANx   pin
9:                    * AN0 - 2  RA0  
10:                   * AN1 - 3  RA1
11:                   * AN2 - 4  RB0
12:                   * AN3 - 5  RB1
13:                   * AN4 - 6  RB2
14:                   * AN5 - 9  RA2
15:                   * AN6 - 10 RA3
16:                   * AN7 - 23 RB12
17:                   * AN8 - 24 RB13
18:                   * AN9 - 25 RB14
19:                   * AN10- 26 RB15 
20:                   * AN11- 7  RB3
21:                   * AN12- 
22:                   * AN13-
23:                   * AVdd-28 (+)
24:                   * AVss-27 (gnd)
25:                  */         
26:                  
27:                  //Pouze nastaveni ADC prevodniku - scan mode
28:                  //nove spusteni se provede Timer1 (vynulovani), tzn 1/10s
29:                  //dokonceni prevodu vsech inputs vyvola interrupt, ktery
30:                  //- nuluje IF
31:                  //- ulozi hodnoty do pole ADResult, kde vyplni platne polozky, ostatni maji hodnotu -1
32:                  //sw cte hodnotu AD prevodu volanim fce adcscan_getValue(input_numbe=ANx)
33:                  
34:                  #if (defined ADC_SCAN_INIT && defined PIC32MM)
35:                  
36:                  int  adc_counter=0;          //zvyseni o 1 pri kazdem dokonceni ADC prevodu
37:                  int  adc_values[]={-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
38:                                     -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 };
39:                  uint calibData=0;
40:                  
41:                  int adcScan_getValue(int index)
42:                  {
9D0127A4      4FB0   ADDIU SP, SP, -8
9D0127A6      CBC1   SW S8, 4(SP)
9D0127A8      0FDD   MOVE S8, SP
9D0127AA  F89E0008   SW A0, 8(S8)
43:                      return  adc_values[index];
9D0127AE  41A28000   LUI V0, 0x8000
9D0127B2  FC7E0008   LW V1, 8(S8)
9D0127B6      25B4   SLL V1, V1, 2
9D0127B8  30420368   ADDIU V0, V0, 872
9D0127BC      0526   ADDU V0, V1, V0
9D0127BE      6920   LW V0, 0(V0)
44:                  }
9D0127C0      0FBE   MOVE SP, S8
9D0127C2      4BC1   LW S8, 4(SP)
9D0127C4      4C05   ADDIU SP, SP, 8
9D0127C6      45BF   JRC RA
45:                  
46:                  void adcScan_init()
47:                  {
9D0127C8      4FF9   ADDIU SP, SP, -16
9D0127CA      CBC3   SW S8, 12(SP)
9D0127CC      0FDD   MOVE S8, SP
48:                      char int_after=-1;   
9D0127CE      ED7F   LI V0, -1
9D0127D0  185E0000   SB V0, 0(S8)
49:                      unsigned int css=0;
9D0127D4  F81E0004   SW ZERO, 4(S8)
50:                      
51:                      //NASTAVENI DEFINOVANYCH ANx VSTUPU
52:                      // <editor-fold defaultstate="collapsed" desc="setting AN0 - AN19">
53:                  #ifdef AN0   
54:                      // Set RA0/AN0 as an analog input (pin 2)
55:                      ANSELAbits.ANSA0 = 1;
56:                      TRISAbits.TRISA0 = 1;
57:                      css |= 1;
58:                      int_after++;
59:                  #endif     
60:                  #ifdef AN1   
61:                      // Set RA1/AN1 as an analog input (pin 3)
62:                      ANSELAbits.ANSA1 = 1;
63:                      TRISAbits.TRISA1 = 1;
64:                      css |= (1 << 1);
65:                      int_after++;
66:                  #endif     
67:                  #ifdef AN2    
68:                      // Set RB0/AN2 as an analog input (pin 4)
69:                      ANSELBbits.ANSB0 = 1;
70:                      TRISBbits.TRISB0 = 1;
71:                      css |= (1 << 2);
72:                      int_after++;
73:                  #endif     
74:                  #ifdef AN3    
75:                      // Set RB1/AN3 as an analog input (pin 5)
76:                      ANSELBbits.ANSB1 = 1;
77:                      TRISBbits.TRISB1 = 1;
78:                      css |= (1 << 3);
79:                      int_after++;
80:                  #endif     
81:                  #ifdef AN4    
82:                      // Set RB2/AN4 as an analog input (pin 6)
83:                      ANSELBbits.ANSB2 = 1;
9D0127D8  41A3BF80   LUI V1, 0xBF80
9D0127DA  BF803443   LDC1 F28, 13379(ZERO)
9D0127DC  34432CB0   LHU V0, 11440(V1)
9D0127DE      2CB0   ANDI S1, V1, 0x80
9D0127E0      EE01   LI A0, 1
9D0127E2  0044108C   INS V0, A0, 2, 1
9D0127E4  108C3843   ADDI A0, T4, 14403
9D0127E6  38432CB0   SH V0, 11440(V1)
9D0127E8      2CB0   ANDI S1, V1, 0x80
84:                      TRISBbits.TRISB2 = 1;
9D0127EA  41A3BF80   LUI V1, 0xBF80
9D0127EC  BF803443   LDC1 F28, 13379(ZERO)
9D0127EE  34432CC0   LHU V0, 11456(V1)
9D0127F0      2CC0   ANDI S1, A0, 0x80
9D0127F2      EE01   LI A0, 1
9D0127F4  0044108C   INS V0, A0, 2, 1
9D0127F6  108C3843   ADDI A0, T4, 14403
9D0127F8  38432CC0   SH V0, 11456(V1)
9D0127FA      2CC0   ANDI S1, A0, 0x80
85:                      css |= (1 << 4);
9D0127FC  FC5E0004   LW V0, 4(S8)
9D012800  50420010   ORI V0, V0, 16
9D012804  F85E0004   SW V0, 4(S8)
86:                      int_after++;
9D012808  145E0000   LBU V0, 0(S8)
9D01280A  00006D20   ADD T5, ZERO, ZERO
9D01280C      6D20   ADDIU V0, V0, 1
9D01280E  185E0000   SB V0, 0(S8)
87:                  #endif    
88:                  
89:                  #ifdef AN5    
90:                      // Set RA2/AN5 as an analog input (pin 9)
91:                      ANSELAbits.ANSA2 = 1;
9D012812  41A3BF80   LUI V1, 0xBF80
9D012814  BF801443   LDC1 F28, 5187(ZERO)
9D012816  14432BB0   LBU V0, 11184(V1)
9D012818      2BB0   LHU A3, 0(V1)
9D01281A      EE01   LI A0, 1
9D01281C  0044108C   INS V0, A0, 2, 1
9D01281E  108C1843   ADDI A0, T4, 6211
9D012820  18432BB0   SB V0, 11184(V1)
9D012822      2BB0   LHU A3, 0(V1)
92:                      TRISAbits.TRISA2 = 1;
9D012824  41A3BF80   LUI V1, 0xBF80
9D012826  BF803443   LDC1 F28, 13379(ZERO)
9D012828  34432BC0   LHU V0, 11200(V1)
9D01282A      2BC0   LHU A3, 0(A0)
9D01282C      EE01   LI A0, 1
9D01282E  0044108C   INS V0, A0, 2, 1
9D012830  108C3843   ADDI A0, T4, 14403
9D012832  38432BC0   SH V0, 11200(V1)
9D012834      2BC0   LHU A3, 0(A0)
93:                      //CNPDAbits.CNPDA2 = 1;               //pull down rezistor
94:                      CNPUAbits.CNPUA2 = 1;               //pull up rezistor    
9D012836  41A3BF80   LUI V1, 0xBF80
9D012838  BF803443   LDC1 F28, 13379(ZERO)
9D01283A  34432C00   LHU V0, 11264(V1)
9D01283C      2C00   ANDI S0, S0, 0x80
9D01283E      EE01   LI A0, 1
9D012840  0044108C   INS V0, A0, 2, 1
9D012842  108C3843   ADDI A0, T4, 14403
9D012844  38432C00   SH V0, 11264(V1)
9D012846      2C00   ANDI S0, S0, 0x80
95:                      css |= (1 << 5);
9D012848  FC5E0004   LW V0, 4(S8)
9D01284C  50420020   ORI V0, V0, 32
9D012850  F85E0004   SW V0, 4(S8)
96:                      int_after++;
9D012854  145E0000   LBU V0, 0(S8)
9D012856  00006D20   ADD T5, ZERO, ZERO
9D012858      6D20   ADDIU V0, V0, 1
9D01285A  185E0000   SB V0, 0(S8)
97:                  #endif
98:                  
99:                  #ifdef AN6     
100:                     // Set RA3/AN6 as an analog input (pin 10)
101:                     ANSELAbits.ANSA3 = 1;
9D01285E  41A3BF80   LUI V1, 0xBF80
9D012860  BF801443   LDC1 F28, 5187(ZERO)
9D012862  14432BB0   LBU V0, 11184(V1)
9D012864      2BB0   LHU A3, 0(V1)
9D012866      EE01   LI A0, 1
9D012868  004418CC   INS V0, A0, 3, 1
9D01286A  18CC1843   SB A2, 6211(T4)
9D01286C  18432BB0   SB V0, 11184(V1)
9D01286E      2BB0   LHU A3, 0(V1)
102:                     TRISAbits.TRISA3 = 1;
9D012870  41A3BF80   LUI V1, 0xBF80
9D012872  BF803443   LDC1 F28, 13379(ZERO)
9D012874  34432BC0   LHU V0, 11200(V1)
9D012876      2BC0   LHU A3, 0(A0)
9D012878      EE01   LI A0, 1
9D01287A  004418CC   INS V0, A0, 3, 1
9D01287C  18CC3843   SB A2, 14403(T4)
9D01287E  38432BC0   SH V0, 11200(V1)
9D012880      2BC0   LHU A3, 0(A0)
103:                     //CNPDBbits.CNPDB13=1;
104:                     CNPUAbits.CNPUA3=1;
9D012882  41A3BF80   LUI V1, 0xBF80
9D012884  BF803443   LDC1 F28, 13379(ZERO)
9D012886  34432C00   LHU V0, 11264(V1)
9D012888      2C00   ANDI S0, S0, 0x80
9D01288A      EE01   LI A0, 1
9D01288C  004418CC   INS V0, A0, 3, 1
9D01288E  18CC3843   SB A2, 14403(T4)
9D012890  38432C00   SH V0, 11264(V1)
9D012892      2C00   ANDI S0, S0, 0x80
105:                     css |= (1 << 6);
9D012894  FC5E0004   LW V0, 4(S8)
9D012898  50420040   ORI V0, V0, 64
9D01289C  F85E0004   SW V0, 4(S8)
106:                     int_after++;
9D0128A0  145E0000   LBU V0, 0(S8)
9D0128A2  00006D20   ADD T5, ZERO, ZERO
9D0128A4      6D20   ADDIU V0, V0, 1
9D0128A6  185E0000   SB V0, 0(S8)
107:                 #endif    
108:                 #ifdef AN7     
109:                     // Set RB12/AN7 as an analog input (pin 23)
110:                     ANSELBbits.ANSB4 = 1;
9D0128AA  41A3BF80   LUI V1, 0xBF80
9D0128AC  BF803443   LDC1 F28, 13379(ZERO)
9D0128AE  34432CB0   LHU V0, 11440(V1)
9D0128B0      2CB0   ANDI S1, V1, 0x80
9D0128B2      EE01   LI A0, 1
9D0128B4  0044210C   INS V0, A0, 4, 1
9D0128B6  210C3843   ASET 0, -1981(T4)
9D0128B8  38432CB0   SH V0, 11440(V1)
9D0128BA      2CB0   ANDI S1, V1, 0x80
111:                     TRISBbits.TRISB4 = 1;
9D0128BC  41A3BF80   LUI V1, 0xBF80
9D0128BE  BF803443   LDC1 F28, 13379(ZERO)
9D0128C0  34432CC0   LHU V0, 11456(V1)
9D0128C2      2CC0   ANDI S1, A0, 0x80
9D0128C4      EE01   LI A0, 1
9D0128C6  0044210C   INS V0, A0, 4, 1
9D0128C8  210C3843   ASET 0, -1981(T4)
9D0128CA  38432CC0   SH V0, 11456(V1)
9D0128CC      2CC0   ANDI S1, A0, 0x80
112:                     css |= (1 << 7);
9D0128CE  FC5E0004   LW V0, 4(S8)
9D0128D2  50420080   ORI V0, V0, 128
9D0128D6  F85E0004   SW V0, 4(S8)
113:                     int_after++;
9D0128DA  145E0000   LBU V0, 0(S8)
9D0128DC  00006D20   ADD T5, ZERO, ZERO
9D0128DE      6D20   ADDIU V0, V0, 1
9D0128E0  185E0000   SB V0, 0(S8)
114:                 #endif    
115:                 #ifdef AN8     
116:                     // Set RB13/AN8 as an analog input (pin 24)
117:                     ANSELBbits.ANSB13 = 1;
118:                     TRISBbits.TRISB13 = 1;
119:                     //CNPDBbits.CNPDB13=1;
120:                     //CNPUBbits.CNPUB13=0;
121:                     //ODCBbits.ODCB13=0;    
122:                     css |= (1 << 8);
123:                     int_after++;
124:                 #endif      
125:                 #ifdef AN9     
126:                     // Set RB14/AN9 as an analog input (pin 25)
127:                     ANSELBbits.ANSB14 = 1;
128:                     TRISBbits.TRISB14 = 1;
129:                     //CNPDBbits.CNPDB14=1;
130:                     //CNPUBbits.CNPUB14=0;
131:                     //ODCBbits.ODCB14=0;
132:                     css |= (1 << 9);
133:                     int_after++;
134:                 #endif 
135:                 #ifdef AN10     
136:                     // Set RB15/AN10 as an analog input (pin 26)
137:                     ANSELBbits.ANSB15 = 1;
138:                     TRISBbits.TRISB15 = 1;
139:                     //CNPDBbits.CNPDB15=1;
140:                     //CNPUBbits.CNPUB15=0;
141:                     //ODCBbits.ODCB15=0;
142:                     css |= (1 << 10);
143:                     int_after++;
144:                 #endif
145:                 #ifdef AN11     
146:                     // Set RB3/AN11 as an analog input (pin 7)
147:                     ANSELBbits.ANSB3 = 1;
148:                     TRISBbits.TRISB3 = 1;
149:                     css |= (1 << 11);
150:                     int_after++;
151:                 #endif   
152:                 
153:                 
154:                 #ifdef AN12     
155:                     // Set RC0/AN12 as an analog input
156:                     ANSELCbits.ANSC0 = 1;
157:                     TRISCbits.TRISC0 = 1;
158:                     css |= (1 << 12);
159:                     int_after++;
160:                 #endif       
161:                 
162:                 #ifdef AN13     
163:                     // Set RC1/AN13 as an analog input
164:                     ANSELCbits.ANSC1 = 1;
165:                     TRISCbits.TRISC1 = 1;
166:                     css |= (1 << 13);
167:                     int_after++;
168:                 #endif     
169:                 
170:                 #ifdef AN14     
171:                     // Set RC8/AN14 as an analog input
172:                     ANSELCbits.ANSC8 = 1;
173:                     TRISCbits.TRISC8 = 1;
174:                     css |= (1 << 14);
175:                     int_after++;
176:                 #endif     
177:                 
178:                 #ifdef AN15     
179:                     // Set RC5/AN15 as an analog input
180:                     ANSELCbits.ANSC5 = 1;
181:                     TRISCbits.TRISC5 = 1;
182:                     css |= (1 << 15);
183:                     int_after++;
184:                 #endif     
185:                 
186:                 #ifdef AN16     
187:                     // Set RA13/AN16 as an analog input
188:                     ANSELAbits.ANSA13 = 1;
189:                     TRISAbits.TRISA13 = 1;
190:                     css |= (1 << 16);
191:                     int_after++;
192:                 #endif     
193:                 
194:                 #ifdef AN17     
195:                     // Set RA12/AN17 as an analog input
196:                     ANSELAbits.ANSA12 = 1;
197:                     TRISAbits.TRISA12 = 1;
198:                     css |= (1 << 17);
199:                     int_after++;
200:                 #endif     
201:                 
202:                 #ifdef AN18     
203:                     // Set RA11/AN18 as an analog input
204:                     ANSELAbits.ANSA11 = 1;
205:                     TRISAbits.TRISA11 = 1;
206:                     css |= (1 << 18);
207:                     int_after++;
208:                 #endif       
209:                 
210:                 #ifdef AN19     
211:                     // Set RA6/AN19 as an analog input
212:                     ANSELAbits.ANSA6 = 1;
213:                     TRISAbits.TRISA6 = 1;
214:                     css |= (1 << 19);
215:                     int_after++;
216:                 #endif      
217:                     // </editor-fold>
218:                 
219:                     // <editor-fold defaultstate="collapsed" desc="ANVDDCORE, ANVBG, ANVSS, ANVDD">
220:                 #ifdef ANVDDCORE
221:                     //VDD (core Vcc) AN27
222:                     css |= (1 << 27);
223:                     int_after++;
224:                 #endif 
225:                 
226:                 #ifdef ANVBG
227:                     //AV Band Gap - interni ref 1.2V AN28
228:                     css |= (1 << 28);
9D0128E4  FC7E0004   LW V1, 4(S8)
9D0128E8  41A21000   LUI V0, 0x1000
9D0128EA  100044D3   ADDI ZERO, ZERO, 17619
9D0128EC      44D3   OR16 V0, V1
9D0128EE  F85E0004   SW V0, 4(S8)
229:                     int_after++;
9D0128F2  145E0000   LBU V0, 0(S8)
9D0128F4  00006D20   ADD T5, ZERO, ZERO
9D0128F6      6D20   ADDIU V0, V0, 1
9D0128F8  185E0000   SB V0, 0(S8)
230:                 #endif    
231:                 
232:                 #ifdef ANVSS
233:                     //AVSS (GND) AN29
234:                     css |= (1 << 29);
235:                     int_after++;
236:                 #endif    
237:                 
238:                 #ifdef ANVDD
239:                     //AVDD (Vcc) AN30
240:                     css |= (1 << 30);
241:                     int_after++;
242:                 #endif        
243:                     // </editor-fold>
244:                     
245:                     //zapnuti interni reference 1.2V VBGADC=1, vypnuti VBGADC=0
246:                     ANCFGbits.VBGADC=1;
9D0128FC  41A3BF80   LUI V1, 0xBF80
9D0128FE  BF801443   LDC1 F28, 5187(ZERO)
9D012900  14432910   LBU V0, 10512(V1)
9D012902      2910   LHU V0, 0(S1)
9D012904      EE01   LI A0, 1
9D012906  0044108C   INS V0, A0, 2, 1
9D012908  108C1843   ADDI A0, T4, 6211
9D01290A  18432910   SB V0, 10512(V1)
9D01290C      2910   LHU V0, 0(S1)
247:                     
248:                     //AD1CHSbits.CH0SA=0b11101;
249:                     //scan inputs
250:                     AD1CON2bits.CSCNA=1;            //scan inputs
9D01290E  41A3BF80   LUI V1, 0xBF80
9D012910  BF803443   LDC1 F28, 13379(ZERO)
9D012912  34432270   LHU V0, 8816(V1)
9D012916      EE01   LI A0, 1
9D012918  0044528C   INS V0, A0, 10, 1
9D01291A  528C3843   ORI S4, T4, 14403
9D01291C  38432270   SH V0, 8816(V1)
251:                     //AutoScan disable
252:                     AD1CON5bits.ASEN=0;             //auto scan (skenovani vstupu pro threshold detect)
9D012920  41A3BF80   LUI V1, 0xBF80
9D012922  BF803443   LDC1 F28, 13379(ZERO)
9D012924  344322C0   LHU V0, 8896(V1)
9D012926  22C00040   LWC2 $22, 64(ZERO)
9D012928  00407BCC   INS V0, ZERO, 15, 1
9D01292A  7BCC3843   ADDIUPC A3, 19980556
9D01292C  384322C0   SH V0, 8896(V1)
253:                     AD1CSS=css;
9D012930  41A2BF80   LUI V0, 0xBF80
9D012932  BF80FC7E   LDC1 F28, -898(ZERO)
9D012934  FC7E0004   LW V1, 4(S8)
9D012938  F86222A0   SW V1, 8864(V0)
9D01293A  22A0145E   LWP S5, 1118(ZERO)
254:                     AD1CON2bits.SMPI=int_after;     //interrupt po X prevodech (0=po 1, 1=po 2, 2=po 3, ...)
9D01293C  145E0000   LBU V0, 0(S8)
9D012940      2D29   ANDI V0, V0, 0x1F
9D012942      2E2D   ANDI A0, V0, 0xFF
9D012944  41A3BF80   LUI V1, 0xBF80
9D012946  BF803443   LDC1 F28, 13379(ZERO)
9D012948  34432270   LHU V0, 8816(V1)
9D01294A  22700044   LWC2 $19, 68(S0)
9D01294C  0044308C   INS V0, A0, 2, 5
9D01294E  308C3843   ADDIU A0, T4, 14403
9D012950  38432270   SH V0, 8816(V1)
255:                    
256:                     //test jednoho vstupu, musi byt nastaveno AD1CON2bits.CSCNA=0
257:                     AD1CHSbits.CH0NA=0;             //vref- = Vss
9D012954  41A3BF80   LUI V1, 0xBF80
9D012956  BF801443   LDC1 F28, 5187(ZERO)
9D012958  14432290   LBU V0, 8848(V1)
9D01295A  22900040   LWC2 $20, 64(S0)
9D01295C  0040394C   INS V0, ZERO, 5, 3
9D01295E  394C1843   SH T2, 6211(T4)
9D012960  18432290   SB V0, 8848(V1)
258:                     //AD1CHSbits.CH0SA=0b11101;       //input = Vss (test zero) val=0
259:                     //AD1CHSbits.CH0SA=0b11011;       //input = Vdd (core) val=3370
260:                     //AD1CHSbits.CH0SA=0b11110;       //input = AVdd (+) val=4090
261:                     //AD1CHSbits.CH0SA=0b11100;       //input = Vbg (internal ref. 1.2V) val=1750 (musi byt zapnuto Vbg - viz. ANCFG)
262:                     
263:                     //timing
264:                     AD1CON3bits.ADRC = 1;           //Clock from peripheral clock FRC 8MHz
9D012964  41A3BF80   LUI V1, 0xBF80
9D012966  BF803443   LDC1 F28, 13379(ZERO)
9D012968  34432280   LHU V0, 8832(V1)
9D01296C      EE01   LI A0, 1
9D01296E  00447BCC   INS V0, A0, 15, 1
9D012970  7BCC3843   ADDIUPC A3, 19980556
9D012972  38432280   SH V0, 8832(V1)
265:                     AD1CON3bits.ADCS = 8;//8;       //ADC clock TAD = 8 peripheral clock, 1us/1MHz
9D012976  41A2BF80   LUI V0, 0xBF80
9D012978  BF80ED88   LDC1 F28, -4728(ZERO)
9D01297A      ED88   LI V1, 8
9D01297C  18622280   SB V1, 8832(V0)
266:                     AD1CON3bits.SAMC = 10;//10;     //sample time 10 TAD, 10us/0.1MHz
9D012980  41A3BF80   LUI V1, 0xBF80
9D012982  BF803443   LDC1 F28, 13379(ZERO)
9D012984  34432280   LHU V0, 8832(V1)
9D012988      EE0A   LI A0, 10
9D01298A  0044620C   INS V0, A0, 8, 5
9D01298C  620C3843   LL S0, -1981(T4)
9D01298E  38432280   SH V0, 8832(V1)
267:                     
268:                     //AVdd/ss
269:                     AD1CON2bits.VCFG=0;             //AVdd, AVss
9D012992  41A3BF80   LUI V1, 0xBF80
9D012994  BF803443   LDC1 F28, 13379(ZERO)
9D012996  34432270   LHU V0, 8816(V1)
9D012998  22700040   LWC2 $19, 64(S0)
9D01299A  00407B4C   INS V0, ZERO, 13, 3
9D01299C  7B4C3843   ADDIUPC A2, 19980556
9D01299E  38432270   SH V0, 8816(V1)
270:                     AD1CON2bits.OFFCAL=1;           //kalibrace (nefunguje)
9D0129A2  41A3BF80   LUI V1, 0xBF80
9D0129A4  BF803443   LDC1 F28, 13379(ZERO)
9D0129A6  34432270   LHU V0, 8816(V1)
9D0129AA      EE01   LI A0, 1
9D0129AC  0044630C   INS V0, A0, 12, 1
9D0129AE  630C3843   LL T8, -1981(T4)
9D0129B0  38432270   SH V0, 8816(V1)
271:                     
272:                     //AN1CON1
273:                     AD1CON1bits.MODE12=1;           //1=12 bit, 0=10 bit 
9D0129B4  41A3BF80   LUI V1, 0xBF80
9D0129B6  BF803443   LDC1 F28, 13379(ZERO)
9D0129B8  34432260   LHU V0, 8800(V1)
9D0129BC      EE01   LI A0, 1
9D0129BE  004418CC   INS V0, A0, 3, 1
9D0129C0  18CC3843   SB A2, 14403(T4)
9D0129C2  38432260   SH V0, 8800(V1)
274:                     AD1CON1bits.ASAM = 1;           //auto sample po skonceni predchoziho
9D0129C6  41A3BF80   LUI V1, 0xBF80
9D0129C8  BF803443   LDC1 F28, 13379(ZERO)
9D0129CA  34432260   LHU V0, 8800(V1)
9D0129CE      EE01   LI A0, 1
9D0129D0  0044108C   INS V0, A0, 2, 1
9D0129D2  108C3843   ADDI A0, T4, 14403
9D0129D4  38432260   SH V0, 8800(V1)
275:                     AD1CON1bits.SSRC = 7;           //sample time - auto, podle AD1CON3.SAMC
9D0129D8  41A3BF80   LUI V1, 0xBF80
9D0129DA  BF803443   LDC1 F28, 13379(ZERO)
9D0129DC  34432260   LHU V0, 8800(V1)
9D0129E0      EE07   LI A0, 7
9D0129E2  0044390C   INS V0, A0, 4, 4
9D0129E4  390C3843   SH T0, 14403(T4)
9D0129E6  38432260   SH V0, 8800(V1)
276:                     AD1CON1bits.ON = 1;             //Turn on the ADC
9D0129EA  41A3BF80   LUI V1, 0xBF80
9D0129EC  BF803443   LDC1 F28, 13379(ZERO)
9D0129EE  34432260   LHU V0, 8800(V1)
9D0129F2      EE01   LI A0, 1
9D0129F4  00447BCC   INS V0, A0, 15, 1
9D0129F6  7BCC3843   ADDIUPC A3, 19980556
9D0129F8  38432260   SH V0, 8800(V1)
277:                     
278:                 #ifdef PIC32MM0256
279:                     IPC8bits.AD1IP=1;
9D0129FC  41A3BF81   LUI V1, 0xBF81
9D0129FE  BF813443   LDC1 F28, 13379(AT)
9D012A00  3443F1C0   LHU V0, -3648(V1)
9D012A02  F1C0EE01   JALX 0x9F03B804
9D012A04      EE01   LI A0, 1
9D012A06  0044628C   INS V0, A0, 10, 3
9D012A08  628C3843   LL S4, -1981(T4)
9D012A0A  3843F1C0   SH V0, -3648(V1)
9D012A0C  F1C041A3   JALX 0x9F01068C
280:                     IPC8bits.AD1IS=0;
9D012A0E  41A3BF81   LUI V1, 0xBF81
9D012A10  BF813443   LDC1 F28, 13379(AT)
9D012A12  3443F1C0   LHU V0, -3648(V1)
9D012A14  F1C00040   JALX 0x9F000100
9D012A16  00404A0C   INS V0, ZERO, 8, 2
9D012A18      4A0C   LW S0, 48(SP)
9D012A1A  3843F1C0   SH V0, -3648(V1)
9D012A1C  F1C041A3   JALX 0x9F01068C
281:                     IFS1bits.AD1IF=0;
9D012A1E  41A3BF81   LUI V1, 0xBF81
9D012A20  BF81FC43   LDC1 F28, -957(AT)
9D012A22  FC43F050   LW V0, -4016(V1)
9D012A24  F0500040   JALX 0x99400100
9D012A26  0040084C   INS V0, ZERO, 1, 1
9D012A28      084C   LBU S0, 12(A0)
9D012A2A  F843F050   SW V0, -4016(V1)
9D012A2C  F05041A3   JALX 0x9941068C
282:                     IEC1bits.AD1IE=1;
9D012A2E  41A3BF81   LUI V1, 0xBF81
9D012A30  BF81FC43   LDC1 F28, -957(AT)
9D012A32  FC43F0D0   LW V0, -3888(V1)
9D012A34  F0D0EE01   JALX 0x9B43B804
9D012A36      EE01   LI A0, 1
9D012A38  0044084C   INS V0, A0, 1, 1
9D012A3A      084C   LBU S0, 12(A0)
9D012A3C  F843F0D0   SW V0, -3888(V1)
9D012A3E  F0D041A3   JALX 0x9B41068C
283:                 #endif
284:                 
285:                 #ifdef PIC32MM0064    
286:                     //interrupt
287:                     IPC3bits.AD1IP=2;               //interrupt prior
288:                     IPC3bits.AD1IS=0;               //interrupt subprior    
289:                     IFS0bits.AD1IF=0;               //int flag=0
290:                     IEC0bits.AD1IE=1;               //int enable=1
291:                 #endif
292:                     
293:                     //start
294:                     AD1CON1bits.SAMP = 1;           //Start the first sampling cycle
9D012A40  41A3BF80   LUI V1, 0xBF80
9D012A42  BF803443   LDC1 F28, 13379(ZERO)
9D012A44  34432260   LHU V0, 8800(V1)
9D012A48      EE01   LI A0, 1
9D012A4A  0044084C   INS V0, A0, 1, 1
9D012A4C      084C   LBU S0, 12(A0)
9D012A4E  38432260   SH V0, 8800(V1)
9D012A50  22600FBE   LWC2 $19, 4030(ZERO)
295:                 }
9D012A52      0FBE   MOVE SP, S8
296:                 
297:                 #endif
---  D:/bos/bos/ubtn2.S  --------------------------------------------------------------------------------
                                                  1:     #include "xc.h"
                                                  2:     #include "asm_macro.S"
                                                  3:     #include "def.h"       
                                                  4:     
                                                  5:         
                                                  6:     //<editor-fold defaultstate="collapsed" desc="popis">
                                                  7:         
                                                  8:     //pracuje v modu 0, 1, nebo 2
                                                  9:     //mod 0
                                                  10:    //je-li btn stisknuto delsi dobu, odesle jeden event UBTN_DOWN_LONG
                                                  11:    //a po uvolneni UBTN_UP_LONG    
                                                  12:    //app reaguje na tyto udalosti, tzn. ze reaguje az na UP (nebo UBTN_DOWN_LONG, nikoliv na DOWN)    
                                                  13:    //app rozlisuje mezi kratkym a dlouhym stisknutim    
                                                  14:    //mod 1
                                                  15:    //je-li btn stisknuto delsi dobu, odesilaji se periodicky UBTN_REPEAT (prvni pauza je delsi)    
                                                  16:    //app reaguje na UBTN_DOWN a UBTN_REPEAT    
                                                  17:    //app nerozlisuje kratke a dlouhe stisknuti  
                                                  18:        
                                                  19:    //mod 0+1 pri kratkem stisknuti odesila UBTN_DOWN a UBTN_UP v obou modech    
                                                  20:        
                                                  21:    //mod 2
                                                  22:    //mod pro vstupni pin. Odesila pouze UBTN_DOWN a UBTN_UP pri zmene stavu    
                                                  23:        
                                                  24:    //param0 je UBTN_UP/UBTN_DOWN/UBTN_LONG_DOWN/UBTN_LONG_UP/UBTN_REPEAT
                                                  25:    //param1 je value (= kod tlacitka, viz. buttons_table)    
                                                  26:        
                                                  27:    //stav je potvrzeny, pokud je prectena 10x stejna hodnota    
                                                  28:        
                                                  29:    //max. pocet buttons je omezen na BUTTONS_TABLE_CAPA (mozno zmenit)   
                                                  30:    //kazde tlacitko se definuje v buttons_table
                                                  31:        
                                                  32:    //app, ktera chce prijimat events tohoto modulu, musi volat ubtn_regEvent(&fn)
                                                  33:    //pak je fn volana pri kazde event
                                                  34:    //void fn(int event, int button_value, char cnt)    
                                                  35:    //cnt je poradi REPEAT, nebo DOWN_LONG (0-0xFF)
                                                  36:        
                                                  37:    //fce ubtn_start nastavuje TRIS(input), ANLSEL(digital), CNPU(pull-up povoli), CNPD(pull-down zakaze)    
                                                  38:    //tlacitko se pripojuje mezi pin a zem    
                                                  39:        
                                                  40:        
                                                  41:        
                                                  42:    //POZOR po dlouhem stisku (odesila DOWN_LONG) a uvolneni neodesila UP, ale pouze UP_LONG    
                                                  43:    //stisk                                                                                                  uvolneni    
                                                  44:    //DOWN...................................................................................................
                                                  45:    //..............REPEAT(0)....REPEAT(1)....REPEAT(2)....REPEAT(3)....REPEAT(4)....REPEAT(5)....REPEAT(6)..
                                                  46:    //...........................DOWN_LONG(0)...........................DOWN_LONG(1).........................UP_LONG    
                                                  47:    
                                                  48:    //stisk                    uvolneni    
                                                  49:    //DOWN..........REPEAT(0)..UP
                                                  50:        
                                                  51:    //stisk   uvolneni    
                                                  52:    //DOWN....UP       
                                                  53:        
                                                  54:    //</editor-fold>
                                                  55:        
                                                  56:    #ifdef UBTN
                                                  57:        
                                                  58:    #define		LONG_DOWN_MS	    3000			//po 3000 ms detekuje dlouhe stisknuti (mod 0)
                                                  59:    #define		REPEAT_FIRST_MS	    2000			//po 2000 ms poprve odesila REPEAT event (mod 0)
                                                  60:    #define		REPEAT_NEXT_MS	    200				//po 200 ms druhe a dalsi REPEAT event (mod 0)
                                                  61:        
                                                  62:      
                                                  63:    //RAM vars    
                                                  64:    .section .data
                                                  65:        
                                                  66:    #define		ITEM_SIZE	    12				//polozka v items: rep_time[4B], long_time[4B], rep_count[1B], long_count[1B], up_state[1B], down_state[1B]
                                                  67:    #define		BUTTONS_TABLE_ISIZE 8				//velikost polozky v buttons_table    
                                                  68:    #define		BUTTONS_TABLE_CAPA  8  
                                                  69:        
                                                  70:    #define		REP_TIME_OFF	    0
                                                  71:    #define		LONG_TIME_OFF	    4
                                                  72:    #define		REP_COUNT_OFF	    8
                                                  73:    #define		LONG_COUNT_OFF	    9
                                                  74:    #define		UP_STATE_OFF	    10
                                                  75:    #define		DOWN_STATE_OFF	    11    
                                                  76:        
                                                  77:    items:		.space		    BUTTONS_TABLE_CAPA * ITEM_SIZE   
                                                  78:        
                                                  79:    //events table    
                                                  80:    #define		EVENTS_CAPA	    8				//kapacita events tabulky
                                                  81:    events:	.space	EVENTS_CAPA * 4					//8 polozek (word) pro adresy fci volanych pri event
                                                  82:        
                                                  83:        
                                                  84:    .set micromips   
                                                  85:    .section .ubtn, code
                                                  86:    .align 2
                                                  87:    //STATE 0xF0=UP, 0x0F=DOWN (mode 0,2), 0x0E=DOWN (mode 1)
                                                  88:        
                                                  89:    //<editor-fold defaultstate="collapsed" desc="buttons_table">
                                                  90:        
                                                  91:    buttons_table:
                                                  92:    //tabulka obsahuje popis vsech tlacitek, je zakoncena 0x0
                                                  93:    //!!!POZOR v tabulce nesmi byt vice polozek, nez BUTTONS_TABLE_CAPA
                                                  94:        
                                                  95:    #ifdef PIC32MM
                                                  96:        
                                                  97:    //button 0 (A.2-pin 9)   
                                                  98:    .word	PORTA_BASE	//base addr portu 
                                                  99:    .byte	2		//bit_index (A0)
                                                  100:   .byte	0		//mode 0=down, repeat, long down, up, long up, 1=down, up
                                                  101:   .hword	32		//value, ktera bude odeslana v event, param1
                                                  102:       
                                                  103:   //button 1 (A.3-pin 10)   
                                                  104:   .word	PORTA_BASE	//base addr portu     
                                                  105:   .byte	3		//bit_index (A1)
                                                  106:   .byte	0		//mode 0=long up/down, 1=repeat down
                                                  107:   .hword	33		//value, ktera bude odeslana v event, param1    
                                                  108:       
                                                  109:   #endif    
                                                  110:       
                                                  111:   //konec tabulky    
                                                  112:   .word	0x0		//konec tabulky
                                                  113:       
                                                  114:   //</editor-fold>
                                                  115:       
                                                  116:   //<editor-fold defaultstate="collapsed" desc="ubtn_start">
                                                  117:   .align 2    
                                                  118:   .global ubtn_start
                                                  119:   .ent ubtn_start    
                                                  120:   ubtn_start:
                                                  121:   //nastavi bit v portu odpovidajicim tlacitku: TRIS=1(input), ANSEL=0(digital), CNPU=1(pull-up rezistor)    
                                                  122:   //tlacitko se zapoji mezi pin a GND, stisknuti = LOG 0
                                                  123:   //STATE nastavi na UP   
                                                  124:   //definice tlacitek je v buttons_table    
                                                  125:   
                                                  126:       //nastav TRIS bit=1 (input), ANSEL bit=0 digital
9D0121F0  9D0141A8   LUI T0, 0x9D01               127:       la	    t0, buttons_table
9D0121F8  800041B0   LUI S0, 0x8000               128:       la	    s0, items		    //RAM tabulka items
9D012200  000F3220   ADDIU S1, ZERO, 15           129:       addiu   s1, zero, 0xF	    //button UP state (nastavi u vsech tlacitek)
                                                  130:       
9D012204      ED81   LI V1, 1                     131:       li16    v1, 1
                                                  132:       
                                                  133:   1:  //cyklus pro vsechny tlacitka
                                                  134:       //nastav default hodnoty, nastav port
9D012206  0000FD28   LW T1, 0(T0)                 135:       lw	    t1, (t0)		//t1=base addr registru portu
9D01220A  00169409   BEQ T1, ZERO, 0x9D01223B     136:       beqz    t1, 9f		//skok, konec buttons_table
9D012210      0C00   NOP                          137:       nop
                                                  138:       
9D012212  00041728   LBU T9, 4(T0)                139:       lbu	    t9, 4(t0)		//load bit_index
9D012216  10100079   SLLV V0, V1, T9              140:       sllv    v0, v1, t9		//v0 ma nastaveny odpovidajici bit
                                                  141:       
                                                  142:       //TRISbit=1
9D01221A  0018F849   SW V0, 24(T1)                143:       sw32    v0, (TRIS_OFFSET + SET_OFFSET)(t1)
                                                  144:       //ANSELbit=0 
9D01221E  0004F849   SW V0, 4(T1)                 145:       sw32    v0, (ANSEL_OFFSET + CLR_OFFSET)(t1)
                                                  146:       //LAT
                                                  147:       //sw	    v0, (LAT_OFFSET + SET_OFFSET)(t1)
                                                  148:       //PORT
                                                  149:       //sw	    v0, (PORT_OFFSET + SET_OFFSET)(t1)
                                                  150:       //CNPU=1 (pull-up)
9D012222  0058F849   SW V0, 88(T1)                151:       sw32    v0, (CNPU_OFFSET + SET_OFFSET)(t1)
                                                  152:       //CNPD=0 (pull-down)
9D012226  0064F849   SW V0, 100(T1)               153:       sw32    v0, (CNPD_OFFSET + CLR_OFFSET)(t1)    
                                                  154:       
9D01222A      888A   SB S1, 10(S0)                155:       sb      s1, UP_STATE_OFF(s0)	    //UP_state=0xF  (button=UP)
9D01222C      880B   SB S0, 11(S0)                156:       sb	    zero, DOWN_STATE_OFF(s0)	    //DOWN_state=0x0
                                                  157:       
                                                  158:       
                                                  159:       //next button
9D01222E  00083108   ADDIU T0, T0, 8              160:       addiu   t0, BUTTONS_TABLE_ISIZE
9D012232      6C06   ADDIU S0, S0, 12             161:       addiu   s0, ITEM_SIZE	
                                                  162:   	
                                                  163:       nop
9D012234      CFE8   B 0x9D012207                 164:       b16	    1b
9D012238      0C00   NOP                          165:       nop
                                                  166:   9:    
                                                  167:       
                                                  168:       //doEvents
9D01223A  9D0141A4   LUI A0, 0x9D01               169:       la	    a0, ubtn_go
9D012242  EEBB4060   BGEZAL ZERO, 0x9D00FFBD      170:       bal	    doEventsL
9D01224A      0C00   NOP                          171:       nop
                                                  172:       
                                                  173:   .end ubtn_start  
                                                  174:       
                                                  175:   //</editor-fold>
                                                  176:       
                                                  177:   //<editor-fold defaultstate="collapsed" desc="ubtn_go">
                                                  178:   .align 2    
                                                  179:   .ent ubtn_go
                                                  180:   ubtn_go:
                                                  181:   //odesila event
                                                  182:   //1. btn_down,      param0=1, param1=buttons_table[6]    - okamzik stisknuti
                                                  183:   //2. btn_up,        param0=2, param1=buttons_table[6]	 - uvolneni po beznem stisknuti   
                                                  184:   //3. btn_down_long, param0=3, param1=buttons_table[6]    - trva down delsi dobu (pouze jeden event, nikoliv opakovane) mod 0
                                                  185:   //4. btn_up_long,   param0=4, param1=buttons_table[6]    - uvolneni po dlouhem stisknuti mod 0
                                                  186:   //5. btn_repeat     param0=5, param1=buttons_table[6]    - opakovane down mod 1
                                                  187:       
9D01224C  800041B0   LUI S0, 0x8000               188:       la	    s0, items
9D012254  000F3220   ADDIU S1, ZERO, 15           189:       addiu   s1, zero, 0xF	    //hodnota potvrzeny stav
9D012258  9D0141B2   LUI S2, 0x9D01               190:       la	    s2, buttons_table
                                                  191:   
                                                  192:   next:
9D012260  0000FD32   LW T1, 0(S2)                 193:       lw	    t1, (s2)		    //t1=base addr registru portu
9D012264  00C49409   BEQ T1, ZERO, 0x9D0123F1     194:       beqz    t1, end		    //skok konec
9D01226A      0C00   NOP                          195:       nop    
                                                  196:       
                                                  197:       //zjisti akt. stav pinu do v0
9D01226C  0020FC49   LW V0, 32(T1)                198:       lw32    v0, PORT_OFFSET(t1)		    //load port
9D012270  00041732   LBU T9, 4(S2)                199:       lbu	    t9, 4(s2)			    //load bit_index
9D012274  10500059   SRLV V0, V0, T9              200:       srlv    v0, v0, t9			    //cteny bit do b0
9D012278  002C0042   EXT V0, V0, 0, 1             201:       ext	    v0, v0, 0, 1		    //v0=stav pinu
                                                  202:       
9D01227C      8D31   BEQZ V0, 0x9D0122E1          203:       beqz    v0, pin_down		    //skok, pin=0-down
9D012280      0C00   NOP                          204:       nop    
                                                  205:       
                                                  206:       //pin je up
9D012282  000A1730   LBU T9, 10(S0)               207:       lbu	    t9, UP_STATE_OFF(s0)
9D012286  0006B639   BNE T9, S1, 0x9D012297       208:       bne	    t9, s1, up_test_change	    //skok, potencialni zmena stavu
9D01228C      0C00   NOP                          209:       nop
                                                  210:       
                                                  211:       //trva stav UP
9D01228E      880B   SB S0, 11(S0)                212:       sb	    zero, DOWN_STATE_OFF(s0)	    //down_state=0
                                                  213:       nop
9D012290      CCA9   B 0x9D0123E5                 214:       b16	    loop
9D012294      0C00   NOP                          215:       nop
                                                  216:       
                                                  217:   up_test_change:
                                                  218:       //mozna zmena stavu na UP
                                                  219:       //t9=up_state
9D012296      4F22   ADDIU T9, T9, 1              220:       addiu   t9, 1
                                                  221:       sb	    t9, UP_STATE_OFF(s0)	    //save novy up_state
9D012298  00A4B639   BNE T9, S1, 0x9D0123E5       222:       bne	    t9, s1, loop		    //skok, zmena stavu zatim nenastala (up_state != 0xF)
9D0122A0      0C00   NOP                          223:       nop
                                                  224:       
                                                  225:       //zmena stavu na UP
9D0122A2      880B   SB S0, 11(S0)                226:       sb	    zero, DOWN_STATE_OFF(s0)	    //down_state=0
9D0122A4  00091730   LBU T9, 9(S0)                227:       lbu	    t9, LONG_COUNT_OFF(s0)
9D0122A8  000E9419   BEQ T9, ZERO, 0x9D0122C9     228:       beqz    t9, send_up			    //skok, pri down nenastalo long_down, bude odesilat up
9D0122AE      0C00   NOP                          229:       nop
                                                  230:       
                                                  231:       //send long_up
9D0122B0      EE04   LI A0, 4                     232:       li16    a0, UBTN_UP_LONG		    //btn up long
9D0122B2  000634B2   LHU A1, 6(S2)                233:       lhu	    a1, 6(s2)			    //value z buttons_table
9D0122B6      0CC0   MOVE A2, ZERO                234:       move    a2, zero
9D0122B8  00E04060   BGEZAL ZERO, 0x9D01247D      235:       bal	    runEvent
9D0122C0      0C00   NOP                          236:       nop
                                                  237:       
                                                  238:       nop
9D0122C2      CC90   B 0x9D0123E5                 239:       b16	    loop
9D0122C6      0C00   NOP                          240:       nop
                                                  241:       
                                                  242:   send_up:
                                                  243:       //send up
9D0122C8      EE02   LI A0, 2                     244:       li16    a0, UBTN_UP			    //btn up long
9D0122CA  000634B2   LHU A1, 6(S2)                245:       lhu	    a1, 6(s2)			    //value z buttons_table
9D0122CE      0CC0   MOVE A2, ZERO                246:       move    a2, zero
9D0122D0  00D44060   BGEZAL ZERO, 0x9D01247D      247:       bal	    runEvent
9D0122D8      0C00   NOP                          248:       nop
                                                  249:       
                                                  250:       nop
9D0122DA      CC84   B 0x9D0123E5                 251:       b16	    loop
9D0122DE      0C00   NOP                          252:       nop    
                                                  253:   
                                                  254:       
                                                  255:   pin_down:
9D0122E0  000B1730   LBU T9, 11(S0)               256:       lbu	    t9, DOWN_STATE_OFF(s0)
9D0122E4  0064B639   BNE T9, S1, 0x9D0123B1       257:       bne	    t9, s1, down_test_change	    //skok, potencialni zmena stavu
9D0122EA      0C00   NOP                          258:       nop    
                                                  259:       
                                                  260:       //trva stav down
9D0122EC      880A   SB S0, 10(S0)                261:       sb	    zero, UP_STATE_OFF(s0)	    //up_state=0
9D0122EE      0C00   NOP                          262:       nop    
                                                  263:       
9D0122F0  00051732   LBU T9, 5(S2)                264:       lbu	    t9, 5(s2)			    //load mode
9D0122F4  0076B419   BNE T9, ZERO, 0x9D0123E5     265:       bnez    t9, loop			    //skok, mode=1
9D0122FA      0C00   NOP                          266:       nop
                                                  267:       
                                                  268:       lw32    a0, REP_TIME_OFF(s0)	    //load repeatTime
                                                  269:       
                                                  270:       //a0=time (vraci rozdil od now [ms])
9D0122FC  EFD64060   BGEZAL ZERO, 0x9D0102AD      271:       bal	    compareTimerMs		    //meni t8, t9
9D012304      0C00   NOP                          272:       nop
                                                  273:       
9D012306  00081670   LBU S3, 8(S0)                274:       lbu	    s3, REP_COUNT_OFF(s0)	    //load repeatCount
9D01230A  00239413   BEQ S3, ZERO, 0x9D012355     275:       beqz    s3, rep_0			    //skok, repeatCount=0 	
9D012310      0C00   NOP                          276:       nop
                                                  277:       
                                                  278:       //repeatCount > 0
9D012312  FF383042   ADDIU V0, V0, -200           279:       addiu   v0, (-REPEAT_NEXT_MS)
9D012316  00234002   BLTZ V0, 0x9D012361          280:       bltz    v0, test_long		    //skok, nevyprsel cas
9D01231C      0C00   NOP                          281:       nop
                                                  282:       
                                                  283:   send_rep:    
                                                  284:       //cas vyprsel, odeslat repeat
9D01231E      EE05   LI A0, 5                     285:       li16    a0, UBTN_REPEAT		    //btn repeat
9D012320  000634B2   LHU A1, 6(S2)                286:       lhu	    a1, 6(s2)			    //value z buttons_table    
9D012324      0CD3   MOVE A2, S3                  287:       move    a2, s3			    //repeat count
9D012326  00A94060   BGEZAL ZERO, 0x9D01247D      288:       bal	    runEvent
9D01232E      0C00   NOP                          289:       nop
                                                  290:       
9D012330  800041B9   LUI T9, 0x8000               291:       lw      t9, (timer_ms)
9D012338  0000FB30   SW T9, 0(S0)                 292:       sw32    t9, REP_TIME_OFF(s0)	    //nastav now repeatTime
9D01233C      4E62   ADDIU S3, S3, 1              293:       addiu   s3, 1			    //repeatC++
9D01233E  00FFD273   ANDI S3, S3, 255             294:       andi    s3, 0xFF			    //nuluj b8-b31	
9D012342  000D9413   BEQ S3, ZERO, 0x9D012361     295:       beqz    s3, test_long		    //skok, pokud doslo k preteceni repeatC
9D012348      0C00   NOP                          296:       nop
9D01234A  00081A70   SB S3, 8(S0)                 297:       sb	    s3, REP_COUNT_OFF(s0)	    //uloz repeatCount
                                                  298:       
                                                  299:       nop
9D01234E      CC08   B 0x9D012361                 300:       b16	    test_long
9D012352      0C00   NOP                          301:       nop
                                                  302:       
                                                  303:       
                                                  304:   rep_0:
                                                  305:       //repeat_count=0, v0=pocet ms
9D012354  F8303042   ADDIU V0, V0, -2000          306:       addiu   v0, (-REPEAT_FIRST_MS)
9D012358  FFE14042   BGEZ V0, 0x9D01231F          307:       bgez    v0, send_rep		    //skok, cas vyprsel
9D01235E      0C00   NOP                          308:       nop    
                                                  309:       
                                                  310:   test_long:    
                                                  311:       //test cas long
                                                  312:       lw32    a0, LONG_TIME_OFF(s0)	    //load longTime
                                                  313:       
                                                  314:       //a0=time (vraci rozdil od now [ms])
9D012360  EFA44060   BGEZAL ZERO, 0x9D0102AD      315:       bal	    compareTimerMs		    //meni t8, t9
9D012368      0C00   NOP                          316:       nop
                                                  317:       
9D01236A  F4483042   ADDIU V0, V0, -3000          318:       addiu   v0, (-LONG_DOWN_MS)
9D01236E  00394002   BLTZ V0, 0x9D0123E5          319:       bltz    v0, loop			    //skok, cas jeste nevyprsel
9D012374      0C00   NOP                          320:       nop
                                                  321:       
                                                  322:       //cas vyprsel
9D012376  00091670   LBU S3, 9(S0)                323:       lbu	    s3, LONG_COUNT_OFF(s0)	    //load longCount
9D01237A      EE03   LI A0, 3                     324:       li16    a0, UBTN_DOWN_LONG		    //btn long down
9D01237C  000634B2   LHU A1, 6(S2)                325:       lhu	    a1, 6(s2)			    //value z buttons_table    
9D012380      0CD3   MOVE A2, S3                  326:       move    a2, s3			    //longCount
9D012382  007B4060   BGEZAL ZERO, 0x9D01247D      327:       bal	    runEvent
9D01238A      0C00   NOP                          328:       nop    
                                                  329:       
9D01238C  800041B9   LUI T9, 0x8000               330:       lw      t9, (timer_ms)
9D012394  0004FB30   SW T9, 4(S0)                 331:       sw32    t9, LONG_TIME_OFF(s0)	    //nastav now longTime
9D012398      4E62   ADDIU S3, S3, 1              332:       addiu   s3, 1			    //longC++
9D01239A  00FFD273   ANDI S3, S3, 255             333:       andi    s3, 0xFF			    //nuluj b8-b31
9D01239E  00219413   BEQ S3, ZERO, 0x9D0123E5     334:       beqz    s3, loop			    //skok, pokud doslo k preteceni longC
9D0123A4      0C00   NOP                          335:       nop
9D0123A6  00091A70   SB S3, 9(S0)                 336:       sb	    s3, LONG_COUNT_OFF(s0)	    //uloz repeatCount
                                                  337:       
                                                  338:       nop
9D0123AA      CC1C   B 0x9D0123E5                 339:       b16	    loop
9D0123AE      0C00   NOP                          340:       nop    
                                                  341:       
                                                  342:   down_test_change:
                                                  343:       //mozna zmena stavu na down
                                                  344:       //t9=down_state
9D0123B0      4F22   ADDIU T9, T9, 1              345:       addiu   t9, 1
                                                  346:       sb	    t9, DOWN_STATE_OFF(s0)	    //save novy down_state
9D0123B2  0017B639   BNE T9, S1, 0x9D0123E5       347:       bne	    t9, s1, loop		    //skok, zmena stavu zatim nenastala (down_state != 0xF)
9D0123BA      0C00   NOP                          348:       nop    
                                                  349:   
                                                  350:       //nastala zmena na down
9D0123BC      880A   SB S0, 10(S0)                351:       sb	    zero, UP_STATE_OFF(s0)	    //up_state=0
9D0123BE  800041B9   LUI T9, 0x8000               352:       lw      t9, (timer_ms)		    //now	
9D0123C6  0000FB30   SW T9, 0(S0)                 353:       sw32    t9, REP_TIME_OFF(s0)	    //reteatTime=now
9D0123CA  0004FB30   SW T9, 4(S0)                 354:       sw32    t9, LONG_TIME_OFF(s0)	    //longTime=now
9D0123CE      8808   SB S0, 8(S0)                 355:       sb	    zero, REP_COUNT_OFF(s0)	    //nuluj repeatCount
9D0123D0      8809   SB S0, 9(S0)                 356:       sb	    zero, LONG_COUNT_OFF(s0)	    //nuluj longCount
                                                  357:       
                                                  358:       //send down
9D0123D2      EE01   LI A0, 1                     359:       li16    a0, UBTN_DOWN		    //btn down
9D0123D4  000634B2   LHU A1, 6(S2)                360:       lhu	    a1, 6(s2)			    //value z buttons_table
9D0123D8      0CC0   MOVE A2, ZERO                361:       move    a2, zero
9D0123DA  004F4060   BGEZAL ZERO, 0x9D01247D      362:       bal	    runEvent
9D0123E2      0C00   NOP                          363:       nop
                                                  364:       
                                                  365:       //pokracuje loop
                                                  366:      
                                                  367:   loop:    
                                                  368:       //next button
9D0123E4      6C06   ADDIU S0, S0, 12             369:       addiu   s0, ITEM_SIZE		    //items ++
9D0123E6  00083252   ADDIU S2, S2, 8              370:       addiu   s2, BUTTONS_TABLE_ISIZE	    //button_table ++
                                                  371:       
                                                  372:       nop
9D0123EA      CF3A   B 0x9D012261                 373:       b16	    next
9D0123EE      0C00   NOP                          374:       nop
                                                  375:       
                                                  376:   end:    
                                                  377:       //doEvents
9D0123F0  9D0141A4   LUI A0, 0x9D01               378:       la	    a0, ubtn_go
9D0123F4  EDE24060   BGEZAL ZERO, 0x9D00FFBD      379:       bal	    doEventsL
9D0123FC      0C00   NOP                          380:       nop    
                                                  381:   
                                                  382:   .end ubtn_go  
                                                  383:       
                                                  384:   //</editor-fold>
                                                  385:       
                                                  386:   //<editor-fold defaultstate="collapsed" desc="ubtn_regEvent">
                                                  387:       
                                                  388:   .align 2
                                                  389:   .global	ubtn_regEvent
                                                  390:   .ent ubtn_regEvent
                                                  391:   ubtn_regEvent:
                                                  392:   //a0=adresa fce
                                                  393:   //vraci v0=1 OK, tabulka plna vraci v0=0    
                                                  394:       
                                                  395:       
9D012400  00083100   ADDIU T0, ZERO, 8            396:       addiu   t0, zero, EVENTS_CAPA
9D012404  800041A9   LUI T1, 0x8000               397:       la	    t1, events
                                                  398:       
                                                  399:   1:    
9D01240C  0000FF29   LW T9, 0(T1)                 400:       lw	    t9, (t1)
9D012410  0006B419   BNE T9, ZERO, 0x9D012421     401:       bnez    t9, 2f	    //skok, polozka neni volna 
9D012416      0C00   NOP                          402:       nop
                                                  403:       
                                                  404:       //je vola, pouzit
9D012418  0000F889   SW A0, 0(T1)                 405:       sw	    a0, (t1)
9D01241C      ED01   LI V0, 1                     406:       li16    v0, 1
9D01241E      45BF   JRC RA                       407:       jrc	    ra
                                                  408:   
                                                  409:   2:    
9D012420      4D1E   ADDIU T0, T0, -1             410:       addiu   t0, -1	    //count--
                                                  411:       addiu   t1, 4	    //item++ (event table)
9D012422  FFF3B408   BNE T0, ZERO, 0x9D01240D     412:       bnez    t0, 1b	    //skok na dalsi item
9D012428      0C00   NOP                          413:       nop
                                                  414:       
                                                  415:       //chyba, tabulka je plna
9D01242A      0C40   MOVE V0, ZERO                416:       move    v0, zero
9D01242C      45BF   JRC RA                       417:       jrc	    ra    
                                                  418:       
                                                  419:   .end ubtn_regEvent 
                                                  420:       
                                                  421:   //</editor-fold>
                                                  422:       
                                                  423:   //<editor-fold defaultstate="collapsed" desc="ubtn_unregEvent">
                                                  424:       
                                                  425:   .align 2
                                                  426:   .global	ubtn_unregEvent    
                                                  427:   .ent ubtn_unregEvent
                                                  428:   ubtn_unregEvent:
                                                  429:   //a0=adresa fce, ktera bude unreg
                                                  430:       
9D012430      4FB8   ADDIU SP, SP, -4             431:       _PUSH   ra
                                                  432:       
9D012434  00083040   ADDIU V0, ZERO, 8            433:       addiu   v0, zero, EVENTS_CAPA
9D012438  800041A3   LUI V1, 0x8000               434:       la	    v1, events
                                                  435:   1:    
9D012440  0000FF23   LW T9, 0(V1)                 436:       lw	    t9, (v1)
9D012444  0011B499   BNE T9, A0, 0x9D01246B       437:       bne	    t9, a0, 3f
9D01244A      0C00   NOP                          438:       nop
                                                  439:       
                                                  440:       //nasel polozku
9D01244C      E830   SW S0, 0(V1)                 441:       sw	    zero, (v1)	    //vymazat
                                                  442:       
9D01244E  800041A4   LUI A0, 0x8000               443:       la	    a0, events
9D012456      EE84   LI A1, 4                     444:       li16    a1, 4
                                                  445:       addiu   a2, zero, EVENTS_CAPA
                                                  446:       //a0=adresa tabulky, a1=velikost polozky, a2=max. pocet polozek
9D012458  EFFE4060   BGEZAL ZERO, 0x9D010459      447:       bal	    defragTableW
9D012460      0C00   NOP                          448:       nop
                                                  449:       
                                                  450:   2:
9D012462      4BE0   LW RA, 0(SP)                 451:       _POP    ra
9D012466      45BF   JRC RA                       452:       jrc	    ra
9D012468      0C00   NOP                          453:       nop
                                                  454:       
                                                  455:   3:
9D01246A      6D2E   ADDIU V0, V0, -1             456:       addiu   v0, -1	    //count--
                                                  457:       addiu   v1, 4	    //item++ (event table)
9D01246C      AD69   BNEZ V0, 0x9D012441          458:       bnez    v0, 1b	    //skok na dalsi item
9D012470      0C00   NOP                          459:       nop
                                                  460:       
                                                  461:       //nenasel polozku
9D012472      4BE0   LW RA, 0(SP)                 462:       _POP    ra
9D012476      45BF   JRC RA                       463:       jrc	    ra
9D012478      0C00   NOP                          464:       nop
                                                  465:       
                                                  466:   .end ubtn_unregEvent    
                                                  467:       
                                                  468:   //</editor-fold>
                                                  469:      
                                                  470:   //<editor-fold defaultstate="collapsed" desc="runEvent">
                                                  471:       
                                                  472:   .align 2    
                                                  473:   .ent runEvent
                                                  474:   runEvent:
                                                  475:   //a0=udalost UBTN_UP/DOWN/LONG_DOWN/LONG_UP/REPEAT
                                                  476:   //a1=button value z buttons_table 
                                                  477:   //a2=cnt - index opakovani REPEAT a LONG_DOWN (0-0xFF)    
                                                  478:       
9D01247C      4FF5   ADDIU SP, SP, -24            479:       _PUSH_S04RA
                                                  480:      
9D012482      0E04   MOVE S0, A0                  481:       move    s0, a0			    //zaloha a0 (volana fce muze zmenit)
9D012484      0E25   MOVE S1, A1                  482:       move    s1, a1			    //zaloha a1 (volana fce muze zmenit)
9D012486      0E46   MOVE S2, A2                  483:       move    s2, a2
                                                  484:       
9D012488  800041B3   LUI S3, 0x8000               485:       la	    s3, events
9D012490  00083280   ADDIU S4, ZERO, 8            486:       addiu   s4, zero, EVENTS_CAPA
                                                  487:       
                                                  488:   1:    
9D012494  0000FF33   LW T9, 0(S3)                 489:       lw	    t9, (s3)
9D012498  00109419   BEQ T9, ZERO, 0x9D0124BD     490:       beqz    t9, 2f			    //nulova polozka, konec dat
9D01249E      0C00   NOP                          491:       nop
                                                  492:       
9D0124A0      0C90   MOVE A0, S0                  493:       move    a0, s0			    //nastav param0
9D0124A2      0CB1   MOVE A1, S1                  494:       move    a1, s1			    //nastav param1
9D0124A4      0CD2   MOVE A2, S2                  495:       move    a2, s2
                                                  496:      
                                                  497:       //volani c/c++ fce, argumenty:
                                                  498:       //pokud se vejdou do a0-a3, c fce predpoklada, ze jsou v a0-a3 (pouzije hodnoty v reg. a0-a3)
                                                  499:       //ale zaroven je ulozi do zasobniku, nad akt. pozici SP, kam by je mela ulozit volajici fce
                                                  500:       //protoze v prubehu fce se na ne muze odvolavat nikoliv v a0-a3, ale cist je ze zasobniku
                                                  501:       //v ASM kodu to znamena, ze musi posunout zasobnik o prislusnou velikost (nebo tyto argumenty 
                                                  502:       //do zasobniku ulozit - to neni nutne c/c++ to dela automaticky)
9D0124A6      4FFB   ADDIU SP, SP, -12            503:       addiu   sp, -12			    //3 argumenty int
9D0124A8      45D9   JALR16 T9                    504:       jalr    t9				    //volani fce (muze menit vse, krome s0-s7)
9D0124AE      0C00   NOP                          505:       nop
9D0124B0      4C07   ADDIU SP, SP, 12             506:       addiu   sp, 12
                                                  507:       
                                                  508:       //next
9D0124B2      4E9E   ADDIU S4, S4, -1             509:       addiu   s4, -1	    //count--
                                                  510:       addiu   s3, 4	    //item++ (event table)
9D0124B4  FFEEB414   BNE S4, ZERO, 0x9D012495     511:       bnez    s4, 1b
9D0124BA      0C00   NOP                          512:       nop
                                                  513:   
                                                  514:       
                                                  515:   2:    
9D0124BC  500022BD   LWM S0-S4, RA, 0(SP)         516:       _POP_S04RA
9D0124C2      45BF   JRC RA                       517:       jrc	    ra
                                                  518:       
                                                  519:   .end runEvent   
                                                  520:       
                                                  521:   //</editor-fold>
                                                  522:    
                                                  523:   #endif    
---  D:/bos/bos/timer1.S  -------------------------------------------------------------------------------
                                                  1:     #include "xc.h"
                                                  2:     #include "asm_macro.S"
                                                  3:     #include "def.h"  
                                                  4:         
                                                  5:         //timer_ms (uint) cita pocet ms od zapnuti
                                                  6:         //pouziva se k mereni doby udalosti
                                                  7:         //day_ms (uint) pocita pocet ms od zacatku dne
                                                  8:         //pri zmene casu RTC se zmeni, po startu se nastavi podle RTC
                                                  9:         //pouziva se ke spusteni udalosti v urcity cas
                                                  10:        //spolu s RTC DD/MM/YYYY urcuje den/cas    
                                                  11:    
                                                  12:    #ifdef PIC32MM0064
                                                  13:        
                                                  14:        
                                                  15:    #endif    
                                                  16:        
                                                  17:    .section .data    
                                                  18:    .global timer_ms
                                                  19:    timer_ms:	    .word	0x0			    //pocet ms od zapnuti
                                                  20:    .global day_ms   
                                                  21:    day_ms:		    .word	0x0			    //pocet ms v tomto dni, od 0:00:00 hod    
                                                  22:        
                                                  23:    .global timer1_events    
                                                  24:    timer1_events:	    .space	TIMER1_EVENT_CAPA * TIMER1_EVENT_ISIZE
                                                  25:        
                                                  26:        
                                                  27:    .set micromips
                                                  28:    .section .asm_timer1, code 
                                                  29:        
                                                  30:    //<editor-fold defaultstate="collapsed" desc="timer_init">
                                                  31:        
                                                  32:    .align 2
                                                  33:    .global timer1_init
                                                  34:    .ent timer1_init
                                                  35:    timer1_init:
                                                  36:        //timer1 je pripojen k LPRC oscilatoru, ten ma vzdy 32kHz, nezavisla na PBCLK 
                                                  37:        //stejne jako RTCC
                                                  38:        
9D000000      4FB8   ADDIU SP, SP, -4             39:        _PUSH   ra
9D000004  800041A1   LUI AT, 0x8000               40:        sw	    zero, (timer_ms)
                                                  41:        
                                                  42:    #ifdef RTC    
                                                  43:        //povoli RTC modul, nastavi 1/1/2001
                                                  44:        //nastav day_ms, podle aktualniho casu
                                                  45:    
9D000008  8F4EF680   JAL 0x9D011E9C               46:        jal	    rtc_init
9D000010      0C00   NOP                          47:        nop
                                                  48:    
                                                  49:    #endif     
                                                  50:    
                                                  51:        //OFF, setting
9D000012  BF8141A1   LUI AT, 0xBF81               52:        sw	    zero, (T1CON)	    //off (ON=0)
9D00001A  BF8141A1   LUI AT, 0xBF81               53:        sw	    zero, (TMR1)
9D000022  02023320   ADDIU T9, ZERO, 514          54:        li	    t9, 0x0202
9D000026  BF8141A1   LUI AT, 0xBF81               55:        sw	    t9, (T1CON)		    //set (ON=0), LPRC (32kHz 1:1), idle-run, 
                                                  56:        
                                                  57:    #ifdef PIC32MM0064    //IPC/IEC/IFS
                                                  58:        
                                                  59:        //prior 1, subprior 0
                                                  60:        li	    t9, (1<<26)
                                                  61:        sw	    t9, (IPC2SET) 
                                                  62:        
                                                  63:        //IFS=0, IEC=1
                                                  64:        li	    t9, (1<<11)
                                                  65:        sw	    t9, (IFS0CLR)
                                                  66:        sw	    t9, (IEC0SET)
                                                  67:    #endif
                                                  68:        
                                                  69:    #ifdef PIC32MM0256    //IPC/IEC/IFS
                                                  70:        
                                                  71:        //prior 1, subprior 0
9D00002E  10003320   ADDIU T9, ZERO, 4096         72:        li	    t9, (1<<12)
9D000032  BF8141A1   LUI AT, 0xBF81               73:        sw	    t9, (IPC4SET) 
                                                  74:        
                                                  75:        //IFS=0, IEC=1
9D00003A  000241B9   LUI T9, 0x2                  76:        li	    t9, (1<<17)
9D00003E  BF8141A1   LUI AT, 0xBF81               77:        sw	    t9, (IFS0CLR)
9D000046  BF8141A1   LUI AT, 0xBF81               78:        sw	    t9, (IEC0SET)
                                                  79:    #endif    
                                                  80:        
                                                  81:        //1/100 sec, 100x za sekundu 
9D00004E  01403320   ADDIU T9, ZERO, 320          82:        li	    t9, 320
9D000052  BF8141A1   LUI AT, 0xBF81               83:        sw	    t9, (PR1)
                                                  84:        
9D00005A  80005320   ORI T9, ZERO, -32768         85:        li	    t9, (1<<15)
9D00005E  BF8141A1   LUI AT, 0xBF81               86:        sw	    t9, (T1CONSET)
                                                  87:        
9D000066      4BE0   LW RA, 0(SP)                 88:        _POP    ra
9D00006A      45BF   JRC RA                       89:        jrc	    ra
                                                  90:        
                                                  91:        //
                                                  92:        
                                                  93:        //IEC0.11, IFS0.11
                                                  94:        
                                                  95:        //timer_ms (uint) cita pocet ms od zapnuti
                                                  96:        //pouziva se k mereni doby udalosti
                                                  97:        //day_ms (uint) pocita pocet ms od zacatku dne
                                                  98:        //pri zmene casu RTC se zmeni, po startu se nastavi podle RTC
                                                  99:        //pouziva se ke spusteni udalosti v urcitt cas
                                                  100:       //spolu s RTC DD/MM/YYYY urcuje den/cas
                                                  101:       
                                                  102:       /*
                                                  103:       timer_ms=0;
                                                  104:       
                                                  105:   #ifdef RTC    
                                                  106:       //povoli RTC modul, nastavi 1/1/2001
                                                  107:       rtc_init();
                                                  108:       //nastav day_ms, podle aktualniho casu
                                                  109:       //setDayMsFromRtc();
                                                  110:       
                                                  111:   #endif    
                                                  112:       T1CON=0x0;                  //off
                                                  113:       TMR1=0x0;
                                                  114:       T1CON=0x0202;               
                                                  115:       
                                                  116:       IFS0bits.T1IF=0;            //IFlag=0
                                                  117:       IEC0bits.T1IE=1;            //IEnable=1
                                                  118:       
                                                  119:       IPC2bits.T1IP=1;            //priority
                                                  120:       IPC2bits.T1IS=0;            //subpriority
                                                  121:       
                                                  122:       //1/10 sec, 10x za sekundu 
                                                  123:       PR1=3200;
                                                  124:       
                                                  125:       //ON, LPRC (32kHz 1:1), idle-run, 
                                                  126:       T1CONSET=0x8000;
                                                  127:       */
                                                  128:       
                                                  129:   .end timer1_init   
                                                  130:       
                                                  131:   //</editor-fold>
                                                  132:    
                                                  133:   //<editor-fold defaultstate="collapsed" desc="timer1_regEventInterval">
                                                  134:       
                                                  135:   .align 2
                                                  136:   .global timer1_regEventInterval
                                                  137:   .ent timer1_regEventInterval
                                                  138:   timer1_regEventInterval:
                                                  139:   //a0=adresa status byte
                                                  140:   //a1=interval ms 
                                                  141:   //vraci v0=1 OK, v0=0 chyba, plna tabulka  
                                                  142:       
                                                  143:   //po uplynuti casu nastavi status byte=1, nulovat ho pak musi app 
                                                  144:   //udalost nastava periodicky, pro zruseni ji musi app unreg
                                                  145:       
9D00006C  800041A3   LUI V1, 0x8000               146:       la	    v1, (timer1_events)
9D000074  00103040   ADDIU V0, ZERO, 16           147:       addiu   v0, zero, TIMER1_EVENT_CAPA
                                                  148:   
                                                  149:   1:    
9D000078  0000FF23   LW T9, 0(V1)                 150:       lw	    t9, (v1)
9D00007C  0007B419   BNE T9, ZERO, 0x9D00008F     151:       bnez    t9, 2f
9D000082      0C00   NOP                          152:       nop
                                                  153:       
                                                  154:       //volna polozka
9D000084      EA30   SW A0, 0(V1)                 155:       sw	    a0, (v1)				//adresa status byte
9D000086      EAB1   SW A1, 4(V1)                 156:       sw	    a1, 4(v1)				//default value
9D000088      EAB2   SW A1, 8(V1)                 157:       sw	    a1, 8(v1)				//value
                                                  158:      
9D00008A      ED01   LI V0, 1                     159:       li16    v0, 1				//vraci OK
9D00008C      45BF   JRC RA                       160:       jrc	    ra
                                                  161:       
                                                  162:   2:
9D00008E      6DB6   ADDIU V1, V1, 12             163:       addiu   v1, TIMER1_EVENT_ISIZE
9D000090      6D2E   ADDIU V0, V0, -1             164:       addiu   v0, -1
9D000092      AD72   BNEZ V0, 0x9D000079          165:       bnez    v0, 1b
9D000096      0C00   NOP                          166:       nop
                                                  167:       
                                                  168:       //v0=0, vraci chybu
9D000098      45BF   JRC RA                       169:       jrc	    ra
                                                  170:       
                                                  171:   .end timer1_regEventInterval    
                                                  172:       
                                                  173:   //</editor-fold>
                                                  174:   
                                                  175:   //<editor-fold defaultstate="collapsed" desc="timer1_regEventDelay">
                                                  176:       
                                                  177:   .align 2
                                                  178:   .global timer1_regEventDelay
                                                  179:   .ent timer1_regEventDelay
                                                  180:   timer1_regEventDelay:
                                                  181:   //a0=adresa status byte
                                                  182:   //a1=delay ms 
                                                  183:   //vraci v0=1 OK, v0=0 chyba, plna tabulka 
                                                  184:       
                                                  185:   //po uplynuti casu nastavi status byte=1, nulovat ho pak musi app  
                                                  186:   //udalost nastane pouze jednou, app ji pak nemusi unreg (provede se automaticky)    
                                                  187:       
                                                  188:       
9D00009C  800041A3   LUI V1, 0x8000               189:       la	    v1, (timer1_events)
9D0000A4  00103040   ADDIU V0, ZERO, 16           190:       addiu   v0, zero, TIMER1_EVENT_CAPA
                                                  191:   
                                                  192:   1:    
9D0000A8  0000FF23   LW T9, 0(V1)                 193:       lw	    t9, (v1)
9D0000AC  0007B419   BNE T9, ZERO, 0x9D0000BF     194:       bnez    t9, 2f
9D0000B2      0C00   NOP                          195:       nop
                                                  196:       
                                                  197:       //volna polozka
9D0000B4      EA30   SW A0, 0(V1)                 198:       sw	    a0, (v1)				//adresa status byte
9D0000B6      E831   SW S0, 4(V1)                 199:       sw	    zero, 4(v1)				//default value = 0, neni repeat
9D0000B8      EAB2   SW A1, 8(V1)                 200:       sw	    a1, 8(v1)				//value
                                                  201:      
9D0000BA      ED01   LI V0, 1                     202:       li16    v0, 1				//vraci OK
9D0000BC      45BF   JRC RA                       203:       jrc	    ra
                                                  204:       
                                                  205:   2:
9D0000BE      6DB6   ADDIU V1, V1, 12             206:       addiu   v1, TIMER1_EVENT_ISIZE
9D0000C0      6D2E   ADDIU V0, V0, -1             207:       addiu   v0, -1
9D0000C2      AD72   BNEZ V0, 0x9D0000A9          208:       bnez    v0, 1b
9D0000C6      0C00   NOP                          209:       nop
                                                  210:       
                                                  211:       //v0=0, vraci chybu
9D0000C8      45BF   JRC RA                       212:       jrc	    ra     
                                                  213:       
                                                  214:       
                                                  215:   .end timer1_regEventDelay
                                                  216:       
                                                  217:   //</editor-fold>
                                                  218:       
                                                  219:   //<editor-fold defaultstate="collapsed" desc="timer1_unregEvent">
                                                  220:       
                                                  221:   .align 2
                                                  222:   .global timer1_unregEvent
                                                  223:   .ent timer1_unregEvent
                                                  224:   timer1_unregEvent:
                                                  225:   //a0=adresa status byte    
                                                  226:       
9D0000CC      4FB8   ADDIU SP, SP, -4             227:       _PUSH ra
                                                  228:       
9D0000D0  00103040   ADDIU V0, ZERO, 16           229:       addiu   v0, zero, TIMER1_EVENT_CAPA
9D0000D4  800041A3   LUI V1, 0x8000               230:       la	    v1, timer1_events
                                                  231:   1:    
9D0000DC  0000FF23   LW T9, 0(V1)                 232:       lw	    t9, (v1)
9D0000E0  0016B499   BNE T9, A0, 0x9D000111       233:       bne	    t9, a0, 3f
9D0000E6      0C00   NOP                          234:       nop
                                                  235:       
                                                  236:       //nasel polozku
9D0000E8      E830   SW S0, 0(V1)                 237:       sw	    zero, (v1)	    //vymazat
                                                  238:       
9D0000EA  800041A4   LUI A0, 0x8000               239:       la	    a0, timer1_events
9D0000F2      EE8C   LI A1, 12                    240:       li16    a1, TIMER1_EVENT_ISIZE
9D0000F4  001030C0   ADDIU A2, ZERO, 16           241:       addiu   a2, zero, TIMER1_EVENT_CAPA
                                                  242:       //a0=adresa tabulky, a1=velikost polozky, a2=max. pocet polozek
9D0000F8  9D0141B9   LUI T9, 0x9D01               243:       la	    t9, (defragTableW)
9D000100      45D9   JALR16 T9                    244:       jalr    t9
                                                  245:       //bal	    defragTableW
9D000106      0C00   NOP                          246:       nop
                                                  247:       
                                                  248:   2:
9D000108      4BE0   LW RA, 0(SP)                 249:       _POP ra
9D00010C      45BF   JRC RA                       250:       jrc	    ra
9D00010E      0C00   NOP                          251:       nop
                                                  252:       
                                                  253:   3:
9D000110      6D2E   ADDIU V0, V0, -1             254:       addiu   v0, -1	    //count--
                                                  255:       addiu   v1, 4	    //item++ (event table)
9D000112      AD64   BNEZ V0, 0x9D0000DD          256:       bnez    v0, 1b	    //skok na dalsi item
9D000116      0C00   NOP                          257:       nop
                                                  258:       
                                                  259:       //nenasel polozku
9D000118      4BE0   LW RA, 0(SP)                 260:       _POP    ra
9D00011C      45BF   JRC RA                       261:       jrc	    ra
9D00011E      0C00   NOP                          262:       nop   
                                                  263:       
                                                  264:   .end timer1_unregEvent  
                                                  265:       
                                                  266:   //</editor-fold>
                                                  267:      
---  D:/bos/bos/rtc.S  ----------------------------------------------------------------------------------
                                                  1:     #include "xc.h"
                                                  2:     #include "def.h"    
                                                  3:     #include "asm_macro.S"    
                                                  4:        
                                                  5:     #ifdef RTC
                                                  6:     
                                                  7:         
                                                  8:     //<editor-fold defaultstate="collapsed" desc="Popis">
                                                  9:     //date a time se cte z RTC modulu
                                                  10:    //presny cas (ms 32-bit) od zacatku dne je v promene day_ms, kterou incrementuje timer1
                                                  11:    //day_ms se synchronizuje s RTC kazdou minutu (alarm interrupt)    
                                                  12:    //doba spusteni je v timer_ms (32-bit)
                                                  13:    
                                                  14:    //bcd format
                                                  15:    //   des  jed  des  jed  des  jed
                                                  16:    //0b RRRR.RRRR-MMMM.MMMM-DDDD.DDDD-xxxx xWWW - week day
                                                  17:    //0b HHHH.HHHH-MMMM.MMMM-SSSS.SSSS-xxxx xxxx      
                                                  18:        
                                                  19:    //</editor-fold>
                                                  20:    
                                                  21:    .set micromips
                                                  22:    .section .asm_rtc, code 
                                                  23:        
                                                  24:    //spolecne macro pro MM i MZ    
                                                  25:    
                                                  26:    //<editor-fold defaultstate="collapsed" desc="_GET_HOUR_FROM_BCD">
                                                  27:    .macro _GET_HOUR_FROM_BCD src, dest
                                                  28:        ext     \dest, \src, 28, 4		//desitky
                                                  29:        li      t9, 10	    
                                                  30:        mul     \dest, t9
                                                  31:        ext     t9, \src, 24, 4		//jednotky
                                                  32:        addu    \dest, t9        
                                                  33:    .endm
                                                  34:    //</editor-fold>
                                                  35:    
                                                  36:    //<editor-fold defaultstate="collapsed" desc="_GET_MIN_FROM_BCD">
                                                  37:    .macro _GET_MIN_FROM_BCD src, dest
                                                  38:        ext     \dest, \src, 20, 4		//desitky
                                                  39:        li      t9, 10	    
                                                  40:        mul     \dest, t9
                                                  41:        ext     t9, \src, 16, 4		//jednotky
                                                  42:        addu    \dest, t9    
                                                  43:    .endm
                                                  44:    //</editor-fold>
                                                  45:    
                                                  46:    //<editor-fold defaultstate="collapsed" desc="_GET_SEC_FROM_BCD">
                                                  47:    .macro _GET_SEC_FROM_BCD src, dest
                                                  48:        //sec 0-59
                                                  49:        ext     \dest, \src, 12, 4		//desitky
                                                  50:        li      t9, 10
                                                  51:        mul     \dest, t9
                                                  52:        ext     t9, \src, 8, 4		//jednotky
                                                  53:        addu    \dest, t9
                                                  54:    .endm
                                                  55:    //</editor-fold>
                                                  56:        
                                                  57:    //<editor-fold defaultstate="collapsed" desc="_GET_Y_FROM_BCD">
                                                  58:    .macro _GET_Y_FROM_BCD src, dest
                                                  59:        //do t0 year 2000-2099
                                                  60:        ext     \dest, \src, 28, 4		    //4 bits desitky
                                                  61:        li	    t9, 10
                                                  62:        mul     \dest, t9              
                                                  63:        ext     t9, \src, 24, 4		    //4 bits jednotky
                                                  64:        addu    \dest, t9			    //dest=rok 0-99
                                                  65:        
                                                  66:        //load stoleti z cfg
                                                  67:        //lw	    t9, (working_ffat)		    //adresa primarni ffat
                                                  68:        //lw	    t9, BOOT_CENTURY_OFFSET+4(t9)   //adresa polozky century
                                                  69:        //FFAT byla zmenena...
                                                  70:        //lw	    t9, (date_century)
                                                  71:        li	    t9, 2000			    //stoleti
                                                  72:        addu    \dest, t9			    //stoleti + RR 
                                                  73:    .endm
                                                  74:    //</editor-fold>
                                                  75:        
                                                  76:    //<editor-fold defaultstate="collapsed" desc="_GET_M_FROM_BCD">
                                                  77:    .macro _GET_M_FROM_BCD src, dest
                                                  78:        //month 1-12
                                                  79:        ext     \dest, \src, 20, 4	    //4 bits desitky
                                                  80:        li      t9, 10
                                                  81:        mul     \dest, t9
                                                  82:        ext     t9, \src, 16, 4         //4 bits jednotky
                                                  83:        addu    \dest, t9
                                                  84:    .endm
                                                  85:    //</editor-fold>
                                                  86:         
                                                  87:    //<editor-fold defaultstate="collapsed" desc="_GET_D_FROM_BCD">
                                                  88:    .macro _GET_D_FROM_BCD src, dest    
                                                  89:        //day 1-31
                                                  90:        ext     \dest, \src, 12, 4	    //4 bits desitky
                                                  91:        li      t9, 10
                                                  92:        mul     \dest, t9
                                                  93:        ext     t9, \src, 8, 4	    //4 bits jednotky
                                                  94:        addu    \dest, t9
                                                  95:    .endm  
                                                  96:    //</editor-fold>    
                                                  97:    
                                                  98:    //<editor-fold defaultstate="collapsed" desc="_BIN_TO_BCD">
                                                  99:    .macro _BIN_TO_BCD val   
                                                  100:   //val=number 0-99, prevede na v cislice 0-9(b7-b4), 0-9(b3-b0)
                                                  101:       move    t9, zero
                                                  102:   1001:
                                                  103:       addiu   t8, zero, 10
                                                  104:       slt	    t8, \val, t8
                                                  105:       bnez    t8, 1002f			//vysledek < 10
                                                  106:       nop
                                                  107:       
                                                  108:       //val>9
                                                  109:       addiu   t9, 1			//desitky ++
                                                  110:       addiu   \val, -10			//val -= 10
                                                  111:       nop
                                                  112:       b16	    1001b
                                                  113:       nop
                                                  114:   
                                                  115:   1002:    
                                                  116:       ins	    \val, t9, 4, 4
                                                  117:       
                                                  118:   .endm 
                                                  119:   //</editor-fold>   
                                                  120:   
                                                  121:       
                                                  122:       
                                                  123:   #ifdef PIC32MM 
                                                  124:       
                                                  125:   #define	    WRLOCK	    0x0800		//RTCCON1.b11  
                                                  126:   #define     TIME_SYNC	    0x0004
                                                  127:   #define	    ALARM_SYNC	    0x0002
                                                  128:   #define	    RTCCON1_SET	    0xC3FF0000		//ALARM enable, ON, ... 
                                                  129:   #define	    RTCCON1_ON	    0x00008000	    
                                                  130:   #define	    RTCCON2_SET	    0x3E800001		//clock=Low Power RC oscilator (32 kHz)  
                                                  131:       
                                                  132:   //<editor-fold defaultstate="collapsed" desc="_DISABLE_INT">
                                                  133:   .macro _DISABLE_INT
                                                  134:   //zakaza interrupt (DI)	      , zalohu bitu do t9
                                                  135:   //meni t8, t9, v0    
                                                  136:       
                                                  137:       mfc0    t9, _CP0_STATUS
                                                  138:       ext     t9, t9, 0, 1
                                                  139:       di
                                                  140:     
                                                  141:   .endm 
                                                  142:   //</editor-fold>
                                                  143:       
                                                  144:   //<editor-fold defaultstate="collapsed" desc="_RESTORE_INT">
                                                  145:   .macro _RESTORE_INT    
                                                  146:   //restore interrupt  , zaloha v t9   
                                                  147:      
                                                  148:       beqz    t9, 1001f			//skok pokud nema povolit interrupt (zaloha EI v t9)
                                                  149:       nop
                                                  150:       ei
                                                  151:       
                                                  152:   1001:
                                                  153:       
                                                  154:   .endm    
                                                  155:       
                                                  156:   //</editor-fold>  
                                                  157:       
                                                  158:   //<editor-fold defaultstate="collapsed" desc="_SYSKEY_WRLOCK">
                                                  159:   .macro _SYSKEY_WRLOCK   
                                                  160:   //nuluj RTCCON1.WRLock, pouze po syskey    
                                                  161:       
                                                  162:   1001:
                                                  163:       //nastavi RTCCON.3, ceka dokud neni nastaven
                                                  164:       move    v0, zero
                                                  165:       sw      v0, (SYSKEY)
                                                  166:       li      v0, 0xaa996655
                                                  167:       sw      v0, (SYSKEY)
                                                  168:       li      v0, 0x556699aa
                                                  169:       sw      v0, (SYSKEY)
                                                  170:       
                                                  171:       //nuluj WRLOCK
                                                  172:       li      v0, WRLOCK			//WRLOCK=0
                                                  173:       sw      v0, (RTCCON1CLR)
                                                  174:       sync
                                                  175:   
                                                  176:       lw      v0, (RTCCON1)		//ceka na WRLOCK=0 (obcas se musi opakovat unlock 2x)
                                                  177:       li	    v1, WRLOCK
                                                  178:       and	    v0, v1
                                                  179:       bnez    v0, 1001b			//skok, WRLOCK neni 0
                                                  180:       nop
                                                  181:    
                                                  182:   .endm    
                                                  183:   //</editor-fold>
                                                  184:       
                                                  185:   //<editor-fold defaultstate="collapsed" desc="_DATETIME_SYNC">
                                                  186:   
                                                  187:   .macro _DATETIME_SYNC
                                                  188:   //ceka, dokud RTCSTAT.b2 != 0 (pri 1 probiha zmena RTC)
                                                  189:       
                                                  190:   1001:    
                                                  191:       lw	    v0, (RTCSTAT)
                                                  192:       li	    v1, TIME_SYNC
                                                  193:       and	    v0, v1
                                                  194:       bnez    v0, 1001b
                                                  195:       nop
                                                  196:       
                                                  197:   .endm  
                                                  198:       
                                                  199:   //</editor-fold>
                                                  200:     
                                                  201:   //<editor-fold defaultstate="collapsed" desc="_ALARM_SYNC">
                                                  202:   
                                                  203:   .macro _ALARM_SYNC    
                                                  204:   //ceka, dokud RTCSTAT.b1 != 0 (pri 1 probiha zmena RTC)
                                                  205:       
                                                  206:   1001:    
                                                  207:       lw	    v0, (RTCSTAT)
                                                  208:       li	    v1, ALARM_SYNC
                                                  209:       and	    v0, v1
                                                  210:       bnez    v0, 1001b
                                                  211:       nop
                                                  212:       
                                                  213:   .endm  
                                                  214:       
                                                  215:   //</editor-fold>
                                                  216:   
                                                  217:      
                                                  218:   //<editor-fold defaultstate="collapsed" desc="rtc_init">
                                                  219:   .align 2    
                                                  220:   .global rtc_init
                                                  221:   .ent rtc_init
                                                  222:   rtc_init:
                                                  223:   //nastavi time_ms (long int) a date_century
                                                  224:   //vraci v0=ok, muze pokracovat, 1=chyba, nelze spustiti OS 
                                                  225:   
9D011E9C      4FB8   ADDIU SP, SP, -4             226:       _PUSH   ra
                                                  227:       //POZOR, v prubehu fce je t8 a t9 pouzito jako zaloha stavu interrupt a dma suspend
                                                  228:      
                                                  229:       
                                                  230:       
                                                  231:       //test, zda je RTC modul zapnuty, pokud ano, nemeni nastaveni date/time
                                                  232:       //RTC zustava zapnuty pri RESETu i probuzeni ze sleep modu
9D011EA0  BF8041A2   LUI V0, 0xBF80               233:       lw	    v0, (RTCCON1)
9D011EA8  03EC0042   EXT V0, V0, 15, 1            234:       ext	    v0, v0, 15, 1		//RTCCON.15=ON
9D011EAC  0089B402   BNE V0, ZERO, 0x9D011FC3     235:       bnez    v0, 1f
9D011EB2      0C00   NOP                          236:       nop
                                                  237:       
                                                  238:   #ifdef PIC32MM0064
                                                  239:       //prior=1, sub=0
                                                  240:       li	    v0, 0x1F0000
                                                  241:       sw	    v0, (IPC3CLR)
                                                  242:       li	    v0, 0x40000
                                                  243:       sw	    v0, (IPC3SET)
                                                  244:       
                                                  245:       //IE, flag
                                                  246:       li	    v0, (1 << 14)
                                                  247:       sw	    v0, (IFS0CLR)
                                                  248:       sw	    v0, (IEC0SET)
                                                  249:   #endif
                                                  250:       
                                                  251:   #ifdef PIC32MM0256
                                                  252:       //prior=1, sub=0
9D011EB4      ED1F   LI V0, 31                    253:       li	    v0, 0b11111
9D011EB6  BF8141A1   LUI AT, 0xBF81               254:       sw	    v0, (IPC3CLR)
9D011EBE      ED10   LI V0, 16                    255:       li	    v0, 0b10000
9D011EC0  BF8141A1   LUI AT, 0xBF81               256:       sw	    v0, (IPC8SET)
                                                  257:       
                                                  258:       //IE, flag
9D011EC8      ED01   LI V0, 1                     259:       li	    v0, (1 << 0)
9D011ECA  BF8141A1   LUI AT, 0xBF81               260:       sw	    v0, (IFS1CLR)
9D011ED2  BF8141A1   LUI AT, 0xBF81               261:       sw	    v0, (IEC1SET)
                                                  262:   #endif    
                                                  263:       
                                                  264:       
                                                  265:       
                                                  266:       //t9=stav CP0.STATUS.EI, disable interrupt
                                                  267:       //nastav WRLock=0
9D011EDA  00FC032C   MFC0 T9, Status              268:       _DISABLE_INT			//meni t8, t9, v0
                                                  269:       
                                                  270:       //nuluj RTCCON1.WRLOCK
9D011EE6      0C40   MOVE V0, ZERO                271:       _SYSKEY_WRLOCK			//meni v0, v1
9D011F34  BF8041A2   LUI V0, 0xBF80               272:       _DATETIME_SYNC			//nemi v0, v1
9D011F46  BF8041A2   LUI V0, 0xBF80               273:       _ALARM_SYNC				//meni v0, v1
                                                  274:   
                                                  275:       //set time, date
9D011F58      ED00   LI V0, 0                     276:       li      v0, 0x00000000              //00:00:00
9D011F5A  BF8041A1   LUI AT, 0xBF80               277:       sw      v0, (RTCTIME)
9D011F62  BF8041A1   LUI AT, 0xBF80               278:       sw	    v0, (ALMTIME)
9D011F6A  BF8041A1   LUI AT, 0xBF80               279:       sw	    v0, (ALMDATE)
9D011F72  010141A2   LUI V0, 0x101                280:       li      v0, 0x01010102              //2001, leden, 1, den v tydnu 7=SO (1=NE, 2=PO)
9D011F7A  BF8041A1   LUI AT, 0xBF80               281:       sw      v0, (RTCDATE)
                                                  282:   
                                                  283:       //input clock LPRC
9D011F82  3E8041A2   LUI V0, 0x3E80               284:       li	    v0, RTCCON2_SET		//LPRC
9D011F8A  BF8041A1   LUI AT, 0xBF80               285:       sw	    v0, (RTCCON2)
                                                  286:       
                                                  287:       //ON=1
9D011F92  C3FF41A2   LUI V0, 0xC3FF               288:       li      v0, RTCCON1_SET		//ON=1, WRLock=1
9D011F96  BF8041A1   LUI AT, 0xBF80               289:       sw      v0, (RTCCON1)
                                                  290:       
9D011F9E  80005040   ORI V0, ZERO, -32768         291:       li	    v0, RTCCON1_ON
9D011FA2  BF8041A1   LUI AT, 0xBF80               292:       sw	    v0, (RTCCON1SET)
                                                  293:   
                                                  294:       //WRLOCK=1
9D011FAA  08003040   ADDIU V0, ZERO, 2048         295:       li	    v0, WRLOCK			//set RTCCON1.WRLOCK
9D011FAE  BF8041A1   LUI AT, 0xBF80               296:       sw      v0, (RTCCON1SET)
                                                  297:   
                                                  298:        //restore interrupt
9D011FB6  00049419   BEQ T9, ZERO, 0x9D011FC3     299:       _RESTORE_INT			//ze zalohy t9, meni v0
                                                  300:       
                                                  301:   1:    
                                                  302:       //NASTAV var date_century, ktera definuje stoleti, RTC vraci pouze 2-mistny rok (napr. 16)
                                                  303:       //rok = date_century + RTC (2000 + 16)
                                                  304:       //li	    v0, 2000
                                                  305:       //sw	    v0, (date_century)
                                                  306:       //...
                                                  307:       
9D011FC2  00074060   BGEZAL ZERO, 0x9D011FD5      308:       bal	    rtc_setDayMs
9D011FCA      0C00   NOP                          309:       nop
                                                  310:       
9D011FCC      4BE0   LW RA, 0(SP)                 311:       _POP    ra
9D011FD0      45BF   JRC RA                       312:       jrc     ra
                                                  313:       
                                                  314:   .end rtc_init
                                                  315:   //</editor-fold>
                                                  316:   
                                                  317:   //<editor-fold defaultstate="collapsed" desc="rtc_setDayMs">
                                                  318:   .align 2     
                                                  319:   .global rtc_setDayMs    
                                                  320:   .ent rtc_setDayMs
                                                  321:   rtc_setDayMs:
                                                  322:   //meni a0, a1, v0, v1, (volane fce t0-t3, t8, t9)    
                                                  323:       
                                                  324:       //RTC sec * 1000
                                                  325:       //+ RTC min * 60
                                                  326:       //+ RTC hod * 60
                                                  327:       
9D011FD4  BF8041A4   LUI A0, 0xBF80               328:       lw      a0, (RTCTIME)
                                                  329:       //src, dest
9D011FDC  1B2C0104   EXT T0, A0, 12, 4            330:       _GET_SEC_FROM_BCD a0, t0		//meni t9
9D011FF0  1D2C0124   EXT T1, A0, 20, 4            331:       _GET_MIN_FROM_BCD a0, t1		//meni t9
9D012004  1F2C0144   EXT T2, A0, 28, 4            332:       _GET_HOUR_FROM_BCD a0, t2		//meni t9
                                                  333:       
9D012018  03E83320   ADDIU T9, ZERO, 1000         334:       li	    t9, 1000
9D01201C  003C3300   ADDIU T8, ZERO, 60           335:       li	    t8, 60
9D012020  3D7C0000   MTLO ZERO                    336:       mtlo    zero
9D012024  2D7C0000   MTHI ZERO                    337:       mthi    zero
                                                  338:       
9D012028  DB3C0328   MADDU T0, T9                 339:       maddu   t0, t9	//   sec  * 1000
9D01202C  DB3C0309   MADDU T1, T8                 340:       maddu   t1, t8	// + min  * 60
9D012030  DB3C030A   MADDU T2, T8                 341:       maddu   t2, t8	// + hour * 60
                                                  342:       
9D012034      4642   MFLO V0                      343:       mflo    v0
9D012036  800041A1   LUI AT, 0x8000               344:       sw	    v0, (day_ms)
                                                  345:       
9D01203E      45BF   JRC RA                       346:       jrc	    ra
                                                  347:       
                                                  348:   .end rtc_setDayMs 
                                                  349:   //</editor-fold>
                                                  350:     
                                                  351:   //<editor-fold defaultstate="collapsed" desc="rtc_getTime">
                                                  352:   
                                                  353:   .align 2    
                                                  354:   .global rtc_getTime
                                                  355:   .ent rtc_getTime
                                                  356:   rtc_getTime:
                                                  357:       
9D012040  BF8041A2   LUI V0, 0xBF80               358:       _DATETIME_SYNC			//nemi v0, v1
9D012052  BF8041A2   LUI V0, 0xBF80               359:       lw	    v0, (RTCTIME)
                                                  360:       
9D01205A      45BF   JRC RA                       361:       jrc	    ra
                                                  362:       
                                                  363:   .end rtc_getTime 
                                                  364:       
                                                  365:   //</editor-fold>
                                                  366:     
                                                  367:   //<editor-fold defaultstate="collapsed" desc="rtc_getDate">
                                                  368:       
                                                  369:   .align 2    
                                                  370:   .global rtc_getDate
                                                  371:   .ent rtc_getDate
                                                  372:   rtc_getDate:
                                                  373:       
9D01205C  BF8041A2   LUI V0, 0xBF80               374:       _DATETIME_SYNC			//nemi v0, v1
9D01206E  BF8041A2   LUI V0, 0xBF80               375:       lw	    v0, (RTCDATE)
                                                  376:       
9D012076      45BF   JRC RA                       377:       jrc	    ra
                                                  378:       
                                                  379:   .end rtc_getDate  
                                                  380:       
                                                  381:   //</editor-fold>
                                                  382:       
                                                  383:   //<editor-fold defaultstate="collapsed" desc="rtc_getHalfSecond">
                                                  384:   
                                                  385:   .align 2
                                                  386:   .global rtc_getHalfSecond
                                                  387:   .ent rtc_getHalfSecond
                                                  388:   rtc_getHalfSecond:    
                                                  389:       
                                                  390:       //RTCSTAT.b0
9D012078  BF8041A2   LUI V0, 0xBF80               391:       lw	    v0, (RTCSTAT)
9D012080  002C0042   EXT V0, V0, 0, 1             392:       ext	    v0, v0, 0, 1
                                                  393:       
9D012084      45BF   JRC RA                       394:       jrc	    ra
                                                  395:       
                                                  396:   .end rtc_getHalfSecond  
                                                  397:       
                                                  398:   //</editor-fold>
                                                  399:       
                                                  400:   //<editor-fold defaultstate="collapsed" desc="rtc_setTime">
                                                  401:       
                                                  402:   .align 2
                                                  403:   .global rtc_setTime    
                                                  404:   .ent rtc_setTime
                                                  405:   rtc_setTime:
                                                  406:   //a0=BCD time
                                                  407:       
                                                  408:   //bcd format
                                                  409:   //   des  jed  des  jed  des  jed
                                                  410:   //0b RRRR.RRRR-MMMM.MMMM-DDDD.DDDD-xxxx xWWW - week day
                                                  411:   //0b HHHH.HHHH-MMMM.MMMM-SSSS.SSSS-xxxx xxxx    
                                                  412:       
9D012088      4FB8   ADDIU SP, SP, -4             413:       _PUSH   ra
                                                  414:   
                                                  415:       
                                                  416:       
                                                  417:       //POZOR, v dalsim prubehu fce je t8 a t9 pouzito jako zaloha stavu interrupt a dma s
9D01208C  00FC032C   MFC0 T9, Status              418:       _DISABLE_INT			//meni t8, t9, v0
                                                  419:       
                                                  420:       //nuluj RTCCON1.WRLOCK
9D012098      0C40   MOVE V0, ZERO                421:       _SYSKEY_WRLOCK			//meni v0, v1
9D0120E6  BF8041A2   LUI V0, 0xBF80               422:       _DATETIME_SYNC			//nemi v0, v1
9D0120F8  BF8041A2   LUI V0, 0xBF80               423:       _ALARM_SYNC				//meni v0, v1
                                                  424:   
                                                  425:       //set time, date
9D01210A  BF8041A1   LUI AT, 0xBF80               426:       sw      a0, (RTCTIME)
                                                  427:       
                                                  428:       //WRLOCK=1
9D012112  08003040   ADDIU V0, ZERO, 2048         429:       li	    v0, WRLOCK			//set RTCCON1.WRLOCK
9D012116  BF8041A1   LUI AT, 0xBF80               430:       sw      v0, (RTCCON1SET)
                                                  431:       
                                                  432:       //restore interrupt
9D01211E  00049419   BEQ T9, ZERO, 0x9D01212B     433:       _RESTORE_INT			//ze zalohy t9, meni v0    
                                                  434:       
9D01212A  FF534060   BGEZAL ZERO, 0x9D011FD5      435:       bal	    rtc_setDayMs
9D012132      0C00   NOP                          436:       nop
                                                  437:       
9D012134      4BE0   LW RA, 0(SP)                 438:       _POP    ra
9D012138      45BF   JRC RA                       439:       jrc     ra
                                                  440:       
                                                  441:   .end rtc_setTime 
                                                  442:       
                                                  443:   //</editor-fold>
                                                  444:      
                                                  445:   //<editor-fold defaultstate="collapsed" desc="rtc_setDate">
                                                  446:       
                                                  447:   .align 2
                                                  448:   .global rtc_setDate    
                                                  449:   .ent rtc_setDate
                                                  450:   rtc_setDate:
                                                  451:   //a0=BCD time
                                                  452:       
                                                  453:   //bcd format
                                                  454:   //   des  jed  des  jed  des  jed
                                                  455:   //0b RRRR.RRRR-MMMM.MMMM-DDDD.DDDD-xxxx xWWW - week day
                                                  456:   //0b HHHH.HHHH-MMMM.MMMM-SSSS.SSSS-xxxx xxxx    
                                                  457:      
                                                  458:       
                                                  459:       //POZOR, v dalsim prubehu fce je t8 a t9 pouzito jako zaloha stavu interrupt a dma s
9D01213C  00FC032C   MFC0 T9, Status              460:       _DISABLE_INT			//meni t8, t9, v0
                                                  461:       
                                                  462:       //nuluj RTCCON1.WRLOCK
9D012148      0C40   MOVE V0, ZERO                463:       _SYSKEY_WRLOCK			//meni v0, v1
9D012196  BF8041A2   LUI V0, 0xBF80               464:       _DATETIME_SYNC			//nemi v0, v1
9D0121A8  BF8041A2   LUI V0, 0xBF80               465:       _ALARM_SYNC				//meni v0, v1
                                                  466:   
                                                  467:       //set time, date
9D0121BA  BF8041A1   LUI AT, 0xBF80               468:       sw      a0, (RTCDATE)
                                                  469:       
                                                  470:       //WRLOCK=1
9D0121C2  08003040   ADDIU V0, ZERO, 2048         471:       li	    v0, WRLOCK			//set RTCCON1.WRLOCK
9D0121C6  BF8041A1   LUI AT, 0xBF80               472:       sw      v0, (RTCCON1SET)
                                                  473:       
                                                  474:       //restore interrupt
9D0121CE  00049419   BEQ T9, ZERO, 0x9D0121DB     475:       _RESTORE_INT			//ze zalohy t9, meni v0    
                                                  476:       
9D0121DA      45BF   JRC RA                       477:       jrc     ra
                                                  478:       
                                                  479:   .end rtc_setDate 
                                                  480:       
                                                  481:   //</editor-fold>    
                                                  482:       
                                                  483:      
                                                  484:   #endif	    //MM    
                                                  485:       
                                                  486:   #endif	    //RTC
---  D:/bos/bos/fn.S  -----------------------------------------------------------------------------------
                                                  1:     #include "xc.h"
                                                  2:     #include "def.h"  
                                                  3:     #include "asm_macro.S"
                                                  4:        
                                                  5:     
                                                  6:     //.set mips32    
                                                  7:     #define MICROMIPS  
                                                  8:     .set micromips     
                                                  9:         
                                                  10:    .section os_alloc_stack_here
                                                  11:    //tuto sekci linker vlozi jako posledni v data RAM
                                                  12:    //definuje prvni volne misto v RAM    
                                                  13:    //stack_area:	    .dword	    0x0	    //dword proto, aby byla zarovnana na 8 bytes
                                                  14:    //v pripade, ze by linker umistoval tuto sekci jinam, bylo by mozne fci malloc alokovat
                                                  15:    //libovolna data v heap, kterou linker vzdy umistuje hned za data. Adresa techto dat
                                                  16:    //by definovala zacatek oblasti stacku    
                                                  17:        
                                                  18:    .section .asm_fn, code     
                                                  19:        
                                                  20:    //<editor-fold defaultstate="collapsed" desc="clearProcTable">
                                                  21:    .align 2
                                                  22:    .global clearProcTable
                                                  23:    .ent clearProcTable
                                                  24:    clearProcTable: 
                                                  25:        
                                                  26:        //Tato fce nuluje obsah proc_t
                                                  27:        
9D00FE04  800041A8   LUI T0, 0x8000               28:        la	    t0, proc_t			//proc_t
9D00FE0C  00083120   ADDIU T1, ZERO, 8            29:        li	    t1, PROC_T_CAPA
9D00FE10  00583320   ADDIU T9, ZERO, 88           30:        li	    t9, PROC_T_ISIZE
9D00FE14  4A100329   MUL T1, T1, T9               31:        mul	    t1, t9
9D00FE18  49500109   ADDU T1, T1, T0              32:        addu    t1, t0			//proc_t after
                                                  33:        
                                                  34:    1:    
9D00FE1C  0000F808   SW ZERO, 0(T0)               35:        sw32    zero, (t0)
9D00FE20      4D08   ADDIU T0, T0, 4              36:        addiu   t0, 4
9D00FE22  FFFBB528   BNE T0, T1, 0x9D00FE1D       37:        bne	    t0, t1, 1b
9D00FE28      0C00   NOP                          38:        nop
                                                  39:        
9D00FE2A      45BF   JRC RA                       40:        jrc	    ra
                                                  41:        
                                                  42:    .end clearProcTable   
                                                  43:    
                                                  44:    //</editor-fold>
                                                  45:     
                                                  46:    //<editor-fold defaultstate="collapsed" desc="allocStack">   
                                                  47:        
                                                  48:    .macro _TEST_COLLISION st1, af1, st2, af2, collide
                                                  49:        //st1 = start oblasti 1
                                                  50:        //af1 = after oblast 1
                                                  51:        //st2 = start oblasti 2
                                                  52:        //af2 = after oblast 2
                                                  53:        
                                                  54:        //meni t9
                                                  55:        _BAL_FBE \st2, \af1, 1001f		//meni t9
                                                  56:        _BAL_FLE \af2, \st1, 1001f		//meni t9
                                                  57:        
                                                  58:        nop
                                                  59:        b16	    \collide
                                                  60:        nop
                                                  61:        
                                                  62:    1001:
                                                  63:       
                                                  64:    .endm     
                                                  65:        
                                                  66:    .align 2
                                                  67:    .global allocStack
                                                  68:    .ent allocStack
                                                  69:    allocStack:
                                                  70:    //a0=pozadovana velikost stacku
                                                  71:    //a1=thread table, adresa akt. polozky 
                                                  72:        
                                                  73:        //meni t0-t9, v0, v1
                                                  74:        //vraci 0=ok, 1=chyba nenasel volny stack
                                                  75:        
                                                  76:        //Prochazi polozky proc_t a hleda oblast v stack_area, kterou muze pouzit.
                                                  77:        //
                                                  78:        //Nejprve urci zacatek oblasti stacku pro app (za interrupt stack)
                                                  79:        //Pokusi se pouzit tuto oblast od zacatku
                                                  80:        //Je-li zacatek obsazeny, prochazi jednotlive polozky proc_t a pokusi se stack umistit 
                                                  81:        //tesne za stack kazde z nich.
                                                  82:        //V t4 ma pocatecni adresu a v t5 adresu za testovanou oblasti
                                                  83:        //Oblast testuje tak, ze prochazi polozky v proc_t a kontroluje zda nejsou v kolizi
                                                  84:        
                                                  85:        //Tato metoda funguje i v pripade, ze dochazi k ukonceni procesu a start novych za behu OS,
                                                  86:        //ale neprovadi se defragmentace oblasti
                                                  87:        
                                                  88:        
                                                  89:        //top adresu oblasti vlozi do TH_T_START_SP, coz je vrchol zasobniku, do ktereho ale tento
                                                  90:        //proces nikdy nezapisuje, protoze PUSH provede nejprve SP-4. TH_T_START_SP - tato hodnota 
                                                  91:        //se pouzije pro inicializaci registru sp pri startu procesu.
                                                  92:        //Top adresa je zaroven dno dalsiho zasobniku, kde ma tento nasledujici ulozenu STACK_CHECK_VALUE
                                                  93:        //pro kontrolu stack-overflow
                                                  94:        //stack-overflow se kontroluje pri prepnuti procesu tak, ze prave ukonceny proces musi mit
                                                  95:        //v TH_T_STACK_BASE (dno stacku) prave STACK_CHECK_VALUE, pokud ne, pak ji musel prespat
                                                  96:        //a dostat se tak mimo svuj zasobnik
                                                  97:        
                                                  98:        //nastav proc_t-start(t0) a proc_t-after(t1)
9D00FE2C  800041A8   LUI T0, 0x8000               99:        la	    t0, proc_t			//proc_t-start
9D00FE34  00083120   ADDIU T1, ZERO, 8            100:       li	    t1, PROC_T_CAPA
9D00FE38  00583320   ADDIU T9, ZERO, 88           101:       li	    t9, PROC_T_ISIZE
9D00FE3C  4A100329   MUL T1, T1, T9               102:       mul	    t1, t9
9D00FE40  49500109   ADDU T1, T1, T0              103:       addu    t1, t0			//proc_t-after
                                                  104:       
                                                  105:       //nastav oblast pro app stack app-stack-start(t2) a stack_area-after(t3)
9D00FE44  800041AA   LUI T2, 0x8000               106:       la	    t2, stack_area		//zacatek oblasti zasobniku v RAM
9D00FE4C  20003320   ADDIU T9, ZERO, 8192         107:       li	    t9, STACK_SIZE
9D00FE50  5950032A   ADDU T3, T2, T9              108:       addu    t3, t2, t9			//stack_area-after
                                                  109:       
                                                  110:       //zjisti pocet SRS 
9D00FE54  10FC004C   MFC0 V0, SRSCtl              111:       mfc0    v0, _CP0_SRSCTL
9D00FE58  1EAC0042   EXT V0, V0, 26, 4            112:       ext	    v0, v0, 26, 4		//Number of Shadow Set (MM=1, MZ=7)
9D00FE5C  02003060   ADDIU V1, ZERO, 512          113:       li	    v1, SRS_STACK_SIZE		//dolni cast stack_area pro interrupt stack (interrupt level 1 MM, nebo 1-7 MZ)
9D00FE60  12100062   MUL V0, V0, V1               114:       mul	    v0, v1			//SIZE * Number of SRS
9D00FE64  5150004A   ADDU T2, T2, V0              115:       addu    t2, v0			//app-stack-start
                                                  116:      
                                                  117:       //t0 = proc_t, t1=proc_t after
                                                  118:       //t2 = stack_start (za SRS), t3=stack_after
                                                  119:   
                                                  120:       //pokusi se alokovat prvni cast app-stack-start 
9D00FE68      0D8A   MOVE T4, T2                  121:       move    t4, t2			//testovana oblast (start) do t4
9D00FE6A      0DE0   MOVE T7, ZERO                122:       move    t7, zero			
                                                  123:       nop
9D00FE6C      CC0A   B 0x9D00FE83                 124:       b16	    2f 
9D00FE70      0C00   NOP                          125:       nop
                                                  126:   
                                                  127:   1:
                                                  128:       //pouzije dalsi polozku proc_t, za jejiz stack se pokusi vlozit novy stack
                                                  129:       
9D00FE72  0000172F   LBU T9, 0(T7)                130:       lbu32    t9, TH_T_ID*4(t7)
9D00FE76  00489419   BEQ T9, ZERO, 0x9D00FF0B     131:       beqz    t9, 6f 			//skok, polozka neni pouzita
9D00FE7C      0C00   NOP                          132:       nop
                                                  133:       
9D00FE7E  0008FD8F   LW T4, 8(T7)                 134:       lw	    t4, TH_T_START_SP*4(t7)	//top stacku = start adresa noveho stacku
                                                  135:   
                                                  136:       
                                                  137:       //nyni bude prochazi vsechny polozky proc_t, vynecha aktualni (a1), (s7) a prazdnou
                                                  138:       //a bude zjistovat, zda novy stack (t4-t5) neni v kolizi s jiz existujicim
                                                  139:   2:     
                                                  140:       //nastav t5 (start+size)
9D00FE82  6950008C   ADDU T5, T4, A0              141:       addu    t5, t4, a0			//t5 new-stack-after addr.
9D00FE86      0DC8   MOVE T6, T0                  142:       move    t6, t0			//t6 = testovana polozka proc_t (nyni nastav prvni)
                                                  143:       
                                                  144:       //kontrola, zda testovana oblast neni mimo stack_area
                                                  145:       //reg1, reg2, skok
9D00FE88  C9D0016D   SUBU T9, T5, T3              146:       _BAL_FBT t5, t3, 5f			//skok, testovana oblast je mimo stack_area
                                                  147:       
                                                  148:   3:  //prochazeni proc_t    
9D00FE94  0000172E   LBU T9, 0(T6)                149:       lbu32    t9, TH_T_ID*4(t6)
9D00FE98  001B9419   BEQ T9, ZERO, 0x9D00FED3     150:       beqz    t9, 4f			//skok, prazdna polozka
                                                  151:       nop
9D00FE9E  001894AE   BEQ T6, A1, 0x9D00FED3       152:       beq	    t6, a1, 4f			//skok, toto je nova polozka (pro kterou se hleda stack)	    
                                                  153:       nop
9D00FEA4  001595EE   BEQ T6, T7, 0x9D00FED3       154:       beq	    t6, t7, 4f			//skok, za touto polozkou je test oblast (proto nemuze byt v kolizi)
9D00FEAA      0C00   NOP                          155:       nop
9D00FEAC  0008FC6E   LW V1, 8(T6)                 156:       lw32    v1, TH_T_START_SP*4(t6)	//stack TOP (after)
9D00FEB0  000CFC4E   LW V0, 12(T6)                157:       lw32    v0, TH_T_STACK_BASE*4(t6)	//stack BOTTOM (start)
                                                  158:       
                                                  159:       //macro, v pripade kolize skok na 5f
                                                  160:       //start1, after1, start2, after2, err
9D00FEB4  C9D0006C   SUBU T9, T4, V1              161:       _TEST_COLLISION v0, v1, t4, t5, 5f 
                                                  162:       
                                                  163:   4:    
                                                  164:       //ok, neni v kolizi, nebo prekoceni testu
9D00FED2  005831CE   ADDIU T6, T6, 88             165:       addiu   t6, PROC_T_ISIZE
9D00FED6  FFDDB52E   BNE T6, T1, 0x9D00FE95       166:       bne	    t6, t1, 3b			//skok, dalsi polozka proc_t
9D00FEDC      0C00   NOP                          167:       nop
                                                  168:       
                                                  169:       //probehl test vsech polozek, neni zadna kolize
                                                  170:       //t4=start oblasti (stack BOTTOM), t5=after (stack TOP)
                                                  171:       
                                                  172:       //BOTTOM
9D00FEDE  000CF985   SW T4, 12(A1)                173:       sw32    t4, TH_T_STACK_BASE*4(a1)	//save bottom addr
9D00FEE2  F01041A3   LUI V1, 0xF010               174:       li	    v1, STACK_CHECK_VALUE	//check_value
9D00FEEA  0000F86C   SW V1, 0(T4)                 175:       sw32    v1, (t4)			//save check_value
                                                  176:       
                                                  177:       //TOP
9D00FEEE  004CF9A5   SW T5, 76(A1)                178:       sw32    t5, TH_T_SP*4(a1)		//save top addr
9D00FEF2  0008F9A5   SW T5, 8(A1)                 179:       sw32    t5, TH_T_START_SP*4(a1)	//save top addr
                                                  180:       
9D00FEF6      ED00   LI V0, 0                     181:       li16    v0, 0			//return 0 (ok)
9D00FEF8      45BF   JRC RA                       182:       jrc	    ra
                                                  183:       
                                                  184:   5: 
                                                  185:       //dalsi polozka proc_t
9D00FEFA  0006B40F   BNE T7, ZERO, 0x9D00FF0B     186:       bnez    t7, 6f			//skok, pokud neprobihal test zacatku oblasti
9D00FF00      0C00   NOP                          187:       nop
                                                  188:       
                                                  189:       //probehl test na zacatek oblasti 
9D00FF02      0DE8   MOVE T7, T0                  190:       move    t7, t0
                                                  191:       nop
9D00FF04      CFB6   B 0x9D00FE73                 192:       b16	    1b
9D00FF08      0C00   NOP                          193:       nop
                                                  194:       
                                                  195:   6:     
9D00FF0A  005831EF   ADDIU T7, T7, 88             196:       addiu   t7, PROC_T_ISIZE
9D00FF0E  FFB0B52F   BNE T7, T1, 0x9D00FE73       197:       bne	    t7, t1, 1b 
9D00FF14      0C00   NOP                          198:       nop
                                                  199:       
                                                  200:       //konec, nenasel volnou oblast
9D00FF16      ED01   LI V0, 1                     201:       li16    v0, 1			//return 1 (error)
9D00FF18      45BF   JRC RA                       202:       jrc	    ra
                                                  203:      
                                                  204:   .end allocStack    
                                                  205:   //</editor-fold>    
                                                  206:       
                                                  207:   //<editor-fold defaultstate="collapsed" desc="doEvents">     
                                                  208:   .align 2	
                                                  209:   .global doEvents    
                                                  210:   .ent doEvents    
                                                  211:   doEvents:
                                                  212:       //prepnuti procesu
                                                  213:       //ra obsahuje navratovou adresu
                                                  214:       
                                                  215:   #ifdef SAFE_PROCESS    
                                                  216:       //nuluj count
                                                  217:       mtc0    zero, _CP0_COUNT 
                                                  218:   #endif    
                                                  219:       
9D00FF1C  800041B9   LUI T9, 0x8000               220:       la	    t9, proc_t_pos	    //zde je ulozena akt. pozice v proc_t
9D00FF24  0000FF19   LW T8, 0(T9)                 221:       lw	    t8, (t9)		    //process table
                                                  222:       
                                                  223:   #ifdef ENABLE_CHECK_STACK_OVERFLOW
                                                  224:       //test, zda posledni (nejnizsi) word ve stacku na kontrolni hodnotu
                                                  225:       //pokud ne, nastalo stack overflow
9D00FF28  000CFDD8   LW T6, 12(T8)                226:       lw	    t6, TH_T_STACK_BASE*4(t8)	//adresa stack_base
9D00FF2C  0000FDCE   LW T6, 0(T6)                 227:       lw	    t6, (t6)			//load data
9D00FF30  F01041AF   LUI T7, 0xF010               228:       li	    t7, STACK_CHECK_VALUE
9D00FF38  0C3C01EE   TNE T6, T7                   229:       tne	    t6, t7		    //trap
9D00FF3C      0C00   NOP                          230:       nop
                                                  231:       
                                                  232:   #endif   
                                                  233:       
                                                  234:       //<editor-fold defaultstate="collapsed" desc="save regs">
9D00FF3E  90202058   SWP V0, 32(T8)               235:       swp     v0, TH_T_V0*4(t8)	    //v0, v1
9D00FF42  90102098   SWP A0, 16(T8)               236:       swp     a0, TH_T_A0*4(t8)	    //a0, a1
9D00FF46  901820D8   SWP A2, 24(T8)               237:       swp     a2, TH_T_A2*4(t8)	    //a2, a3
                                                  238:   
9D00FF4A  D0282118   SWM S0-S7, 40(T8)            239:       swm32   s0-s7, TH_T_S0*4(t8)	    //s0-s7
                                                  240:   
9D00FF4E  90482398   SWP GP, 72(T8)               241:       swp     gp, TH_T_GP*4(t8)	    //gp, sp
9D00FF52  905023D8   SWP S8, 80(T8)               242:       swp     fp, TH_T_FP*4(t8)	    //fp, ra
                                                  243:   
                                                  244:       //HI/LO
                                                  245:       //mflo    t0
                                                  246:       //mfhi    t1
                                                  247:       //swp	    t0, TH_T_LO*4(t8)
                                                  248:       //</editor-fold>
                                                  249:       
9D00FF56  800041A2   LUI V0, 0x8000               250:       la	    v0, proc_t_max	    //proc_t_max
9D00FF5E      6920   LW V0, 0(V0)                 251:       lw	    v0, (v0)		    //v0=process_max
9D00FF60  000AB702   BNE V0, T8, 0x9D00FF79       252:       bne	    v0, t8, 1f		    //skok, neni na posl. pozici proc_t
9D00FF66      0C00   NOP                          253:       nop
                                                  254:       
                                                  255:       //je na posl.
9D00FF68      0C00   NOP                          256:       nop
9D00FF6A  800041B8   LUI T8, 0x8000               257:       la	    t8, proc_t		    //nastav prvni polozku proc_t
                                                  258:       nop
9D00FF72      CC04   B 0x9D00FF7D                 259:       b16	    2f
9D00FF76      0C00   NOP                          260:       nop
                                                  261:   1:    
                                                  262:       //
9D00FF78  00583318   ADDIU T8, T8, 88             263:       addu    t8, PROC_T_ISIZE	    //dalsi polozka proc_t
                                                  264:       
                                                  265:   2:    
                                                  266:       //t8=adresa polozky v proc_t
9D00FF7C  0000FB19   SW T8, 0(T9)                 267:       sw	    t8, (t9)		    //ulozit adresu akt. polozky proc_t
                                                  268:       
                                                  269:       //<editor-fold defaultstate="collapsed" desc="load regs"> 
                                                  270:       //HI/LO
                                                  271:       //lwp	    v0, TH_T_LO*4(t8)
                                                  272:       //mtlo    v0
                                                  273:       //mthi    v1 
                                                  274:   
                                                  275:       //lw      $1,  TH_T_REGS + 4 (t8)       //at
9D00FF80  10202058   LWP V0, 32(T8)               276:       lwp     v0, TH_T_V0*4(t8)	    //v0, v1
9D00FF84  10102098   LWP A0, 16(T8)               277:       lwp     a0, TH_T_A0*4(t8)	    //a0, a1
9D00FF88  101820D8   LWP A2, 24(T8)               278:       lwp     a2, TH_T_A2*4(t8)	    //a2, a3
                                                  279:   
                                                  280:       //s0-s7 v memory model
9D00FF8C  50282118   LWM S0-S7, 40(T8)            281:       lwm32   s0-s7, TH_T_S0*4(t8)
                                                  282:   
9D00FF90  10482398   LWP GP, 72(T8)               283:       lwp     gp, TH_T_GP*4(t8)	    //gp, sp
9D00FF94  105023D8   LWP S8, 80(T8)               284:       lwp     fp, TH_T_FP*4(t8)	    //fp, ra
                                                  285:       
                                                  286:       //</editor-fold>   
                                                  287:   
9D00FF98      45BF   JRC RA                       288:       jrc	    ra
9D00FF9A      0C00   NOP                          289:       nop
                                                  290:   .end doEvents    
                                                  291:   //</editor-fold>    
                                                  292:       
                                                  293:   //<editor-fold defaultstate="collapsed" desc="startEvents">    
                                                  294:   .align 2    
                                                  295:   .global startEvents
                                                  296:   .ent startEvents    
                                                  297:   startEvents:
                                                  298:       //start, spusti prvni proces v process table
                                                  299:       
                                                  300:   #ifdef SAFE_PROCESS    
                                                  301:       //nuluj count
                                                  302:       mtc0    zero, _CP0_COUNT 
                                                  303:       ehb
                                                  304:       
                                                  305:       //nastav compare
                                                  306:       li	    v0, 0xFFFFF
                                                  307:       mtc0    v0, _CP0_COMPARE
                                                  308:       ehb
                                                  309:       
                                                  310:   #endif      
                                                  311:       
9D00FF9C  800041BA   LUI K0, 0x8000               312:       la	    k0, proc_t		//process table
9D00FFA4  800041BB   LUI K1, 0x8000               313:       la	    k1, proc_t_pos	//zde je ulozena akt. pozice v proc_t
9D00FFAC  0000FB5B   SW K0, 0(K1)                 314:       sw	    k0, (k1)		//uloz prvni pozici
                                                  315:       
9D00FFB0  0054FFFA   LW RA, 84(K0)                316:       lw	    ra, TH_T_RA*4(k0)
9D00FFB4  004CFFBA   LW SP, 76(K0)                317:       lw	    sp, TH_T_SP*4(k0)
                                                  318:       
9D00FFB8      45BF   JRC RA                       319:       jrc	    ra
9D00FFBA      0C00   NOP                          320:       nop				//musi zde zustat
                                                  321:   .end startEvents
                                                  322:   //</editor-fold>    
                                                  323:       
                                                  324:   //<editor-fold defaultstate="collapsed" desc="doEventsL">     
                                                  325:   .align 2    
                                                  326:   .global doEventsL    
                                                  327:   .ent doEventsL 
                                                  328:   doEventsL:
                                                  329:       //prepnuti procesu
                                                  330:       //a0 obsahuje navratovou adresu, kam se skoci v dalsim cyklu
                                                  331:       	
                                                  332:   #ifdef SAFE_PROCESS    
                                                  333:       //nuluj count
                                                  334:       mtc0    zero, _CP0_COUNT 
                                                  335:   #endif      
                                                  336:       
                                                  337:       //di
9D00FFBC      0FE4   MOVE RA, A0                  338:       move    ra, a0			//a0 pouzije jako ra
                                                  339:       
                                                  340:   #ifdef MICROMIPS    
9D00FFBE  000153FF   ORI RA, RA, 1                341:       ori	    ra, 0x1			//micromips
                                                  342:   #endif    
                                                  343:       
9D00FFC2  800041B9   LUI T9, 0x8000               344:       la	    t9, proc_t_pos		//zde je ulozena akt. pozice v proc_t
9D00FFCA  0000FF19   LW T8, 0(T9)                 345:       lw	    t8, (t9)			//process table
                                                  346:       
                                                  347:   #ifdef ENABLE_CHECK_STACK_OVERFLOW
                                                  348:       //test, zda posledni (nejnizsi) word ve stacku na kontrolni hodnotu
                                                  349:       //pokud ne, nastalo stack overflow
9D00FFCE  000CFDD8   LW T6, 12(T8)                350:       lw	    t6, TH_T_STACK_BASE*4(t8)
9D00FFD2  0000FDCE   LW T6, 0(T6)                 351:       lw	    t6, (t6)			//load data
9D00FFD6  F01041AF   LUI T7, 0xF010               352:       li	    t7, STACK_CHECK_VALUE
9D00FFDE  0C3C01EE   TNE T6, T7                   353:       tne	    t6, t7			//trap
9D00FFE2      0C00   NOP                          354:       nop
                                                  355:       
                                                  356:   #endif      
                                                  357:       
                                                  358:       //<editor-fold defaultstate="collapsed" desc="save regs">
9D00FFE4  90202058   SWP V0, 32(T8)               359:       swp     v0, TH_T_V0*4(t8)	    //v0, v1
9D00FFE8  90102098   SWP A0, 16(T8)               360:       swp     a0, TH_T_A0*4(t8)	    //a0, a1
9D00FFEC  901820D8   SWP A2, 24(T8)               361:       swp     a2, TH_T_A2*4(t8)	    //a2, a3
                                                  362:   
9D00FFF0  D0282118   SWM S0-S7, 40(T8)            363:       swm32   s0-s7, TH_T_S0*4(t8)	    //s0-s7
                                                  364:   
                                                  365:       //26,27 = t8,t9
9D00FFF4  90482398   SWP GP, 72(T8)               366:       swp     gp, TH_T_GP*4(t8)	    //gp, sp
9D00FFF8  905023D8   SWP S8, 80(T8)               367:       swp     fp, TH_T_FP*4(t8)	    //fp, ra
                                                  368:   
                                                  369:       //HI/LO
                                                  370:       //mflo    t0
                                                  371:       //mfhi    t1
                                                  372:       //swp	    t0, TH_T_LO*4(t8)
                                                  373:       //</editor-fold>
                                                  374:       
9D00FFFC  800041A2   LUI V0, 0x8000               375:       la	    v0, proc_t_max	    //proc_t_max
9D010004      6920   LW V0, 0(V0)                 376:       lw	    v0, (v0)		    //v0=process_max
9D010006  000AB702   BNE V0, T8, 0x9D01001F       377:       bne	    v0, t8, 1f		    //skok, neni na posl. pozici proc_t
9D01000C      0C00   NOP                          378:       nop
                                                  379:       
                                                  380:       //je na posl.
9D01000E      0C00   NOP                          381:       nop
9D010010  800041B8   LUI T8, 0x8000               382:       la	    t8, proc_t		    //nastav prvni polozku proc_t
                                                  383:       nop
9D010018      CC04   B 0x9D010023                 384:       b16	    2f
9D01001C      0C00   NOP                          385:       nop
                                                  386:   1:    
                                                  387:       //
9D01001E  00583318   ADDIU T8, T8, 88             388:       addu    t8, PROC_T_ISIZE	    //dalsi polozka proc_t
                                                  389:       
                                                  390:   2:    
                                                  391:       //t8=adresa polozky v proc_t
9D010022  0000FB19   SW T8, 0(T9)                 392:       sw	    t8, (t9)		    //ulozit adresu akt. polozky proc_t
                                                  393:       
                                                  394:       //<editor-fold defaultstate="collapsed" desc="load regs"> 
                                                  395:       //HI/LO
                                                  396:       //lwp	    v0, TH_T_LO*4(t8)
                                                  397:       //mtlo    v0
                                                  398:       //mthi    v1 
                                                  399:   
9D010026  10202058   LWP V0, 32(T8)               400:       lwp     v0, TH_T_V0*4(t8)	    //v0, v1
9D01002A  10102098   LWP A0, 16(T8)               401:       lwp     a0, TH_T_A0*4(t8)	    //a0, a1
9D01002E  101820D8   LWP A2, 24(T8)               402:       lwp     a2, TH_T_A2*4(t8)	    //a2, a3
                                                  403:   
                                                  404:       //s0-s7 v memory model
9D010032  50282118   LWM S0-S7, 40(T8)            405:       lwm32   s0-s7, TH_T_S0*4(t8)
                                                  406:   
9D010036  10482398   LWP GP, 72(T8)               407:       lwp     gp, TH_T_GP*4(t8)	    //gp, sp
9D01003A  105023D8   LWP S8, 80(T8)               408:       lwp     fp, TH_T_FP*4(t8)	    //fp, ra
                                                  409:       
                                                  410:       //nop
                                                  411:       //nop
                                                  412:       //nop
                                                  413:       //nop
                                                  414:       //</editor-fold>   
                                                  415:   
                                                  416:       
                                                  417:       //ori	    ra, 0x1
                                                  418:       
                                                  419:       //ei
9D01003E      45BF   JRC RA                       420:       jrc	    ra
9D010040      0C00   NOP                          421:       nop
                                                  422:   .end doEventsL    
                                                  423:   //</editor-fold>        
                                                  424:       
                                                  425:   //<editor-fold defaultstate="collapsed" desc="getGP">         
                                                  426:   .align 2    
                                                  427:   .global getGP    
                                                  428:   .ent getGP 
                                                  429:   getGP:
                                                  430:       //vraci hodnotu GP, nastavi se pro kazdy process v proc_t
9D010044      0C5C   MOVE V0, GP                  431:       move    v0, gp
9D010046      45BF   JRC RA                       432:       jrc	    ra
                                                  433:       
                                                  434:   .end getGP    
                                                  435:   //</editor-fold>   
                                                  436:      
                                                  437:       
                                                  438:   //<editor-fold defaultstate="collapsed" desc="strLen">
                                                  439:   .align 2    
                                                  440:   .global strLen    
                                                  441:   .ent strLen
                                                  442:   strLen:
                                                  443:   //a0=adresa stringu \0
                                                  444:       
                                                  445:       //vraci delku
9D010048      ED00   LI V0, 0                     446:       li16    v0, 0
                                                  447:       nop
9D01004A      CC04   B 0x9D010055                 448:       b16	    2f
9D01004E      0C00   NOP                          449:       nop
                                                  450:   1:
9D010050      6D20   ADDIU V0, V0, 1              451:       addiu   v0, 1
9D010052      6E40   ADDIU A0, A0, 1              452:       addiu   a0, 1
                                                  453:       
                                                  454:   2:    
9D010054  00001724   LBU T9, 0(A0)                455:       lbu	    t9, (a0)
9D010058  FFFAB419   BNE T9, ZERO, 0x9D010051     456:       bnez    t9, 1b
9D01005E      0C00   NOP                          457:       nop
                                                  458:       
9D010060      45BF   JRC RA                       459:       jrc	    ra
                                                  460:       
                                                  461:   .end strLen 
                                                  462:       
                                                  463:   //</editor-fold>
                                                  464:       
                                                  465:   //<editor-fold defaultstate="collapsed" desc="concat">
                                                  466:   .global concat
                                                  467:   .ent concat
                                                  468:   concat:
                                                  469:   //a0=dest	    //pole, ke kteremu prida src (obsahuje string \0)
                                                  470:   //a1=src	    //obsahuje string \0
                                                  471:   //a2=desl len	    //max. velikost pole dest, vc. \0   
                                                  472:   //meni a0-a2, v0    
                                                  473:       
                                                  474:       //vraci v0=1 OK, v0=0 chyba
                                                  475:       //k prvnimu (a0) pripoji druhy string (a1)
                                                  476:       //prvni i druhy musi koncit \0
                                                  477:       //pokud prvni nekonci \0 (nebo je delsi nez len (a2) ) nic se neprovede
                                                  478:       //pokud se po slouceni nevejdou do len(a2) druhy bude zkraceny, \0 bude jako posledni znak
                                                  479:       
                                                  480:       nop
9D010062      CC07   B 0x9D010073                 481:       b16	    2f
9D010066      0C00   NOP                          482:       nop
                                                  483:       
                                                  484:   1:  
9D010068      6E40   ADDIU A0, A0, 1              485:       addiu   a0, 1
9D01006A      6F6E   ADDIU A2, A2, -1             486:       addiu   a2, -1;
9D01006C      8F15   BEQZ A2, 0x9D010099          487:       beqz    a2, 98f		//skok, je na konci, nenasel \0
9D010070      0C00   NOP                          488:       nop
                                                  489:   2:    
                                                  490:       //hleda \0 v prvnim stringu
9D010072      0940   LBU V0, 0(A0)                491:       lbu	    v0, (a0)
9D010074      AD79   BNEZ V0, 0x9D010069          492:       bnez    v0, 1b		//skok, neni \0 
9D010078      0C00   NOP                          493:       nop
                                                  494:       
                                                  495:       //nasel /0 (a0)
                                                  496:   3:    
9D01007A      0950   LBU V0, 0(A1)                497:       lbu	    v0, (a1)
9D01007C      8940   SB V0, 0(A0)                 498:       sb	    v0, (a0)
                                                  499:       
9D01007E      8D0E   BEQZ V0, 0x9D01009D          500:       beqz    v0, 99f		//skok, druhy text je na konci vc. \0
9D010082      0C00   NOP                          501:       nop
                                                  502:       
9D010084      6F6E   ADDIU A2, A2, -1             503:       addiu   a2, -1
9D010086      8F07   BEQZ A2, 0x9D010097          504:       beqz    a2, 97f		//nenasel \0 na konci druheho textu
9D01008A      0C00   NOP                          505:       nop
                                                  506:       
9D01008C      6E40   ADDIU A0, A0, 1              507:       addiu   a0, 1
9D01008E      6ED0   ADDIU A1, A1, 1              508:       addiu   a1, 1
                                                  509:       nop
9D010090      CFF4   B 0x9D01007B                 510:       b16	    3b			//dalsi znak
9D010094      0C00   NOP                          511:       nop
                                                  512:       
                                                  513:   97:
                                                  514:       //vlozi \0 na konec
9D010096      8840   SB S0, 0(A0)                 515:       sb	    zero, (a0)
                                                  516:       
                                                  517:   98:
9D010098      0C40   MOVE V0, ZERO                518:       move    v0, zero
9D01009A      45BF   JRC RA                       519:       jrc	    ra
                                                  520:       
                                                  521:   99:
                                                  522:       //konec
9D01009C      ED01   LI V0, 1                     523:       li16    v0, 1
9D01009E      45BF   JRC RA                       524:       jrc	    ra
                                                  525:       
                                                  526:   .end concat 
                                                  527:       
                                                  528:   //</editor-fold>
                                                  529:       
                                                  530:   //<editor-fold defaultstate="collapsed" desc="lTrim">
                                                  531:   .align 2    
                                                  532:   .global lTrim    
                                                  533:   .ent lTrim
                                                  534:   lTrim:
                                                  535:   //a0=adresa input  string, zakoncene \0
                                                  536:   //a1=adresa output string, zakoncene \0   
                                                  537:       
                                                  538:       //meni v0, v1, t8, t9
                                                  539:       //kopiruje input string do output, bez mezer na zacatku
                                                  540:   
9D0100A0      0C44   MOVE V0, A0                  541:       move    v0, a0
9D0100A2      0C65   MOVE V1, A1                  542:       move    v1, a1
9D0100A4  00203300   ADDIU T8, ZERO, 32           543:       addiu   t8, zero, _CHAR_SPACE
                                                  544:       
                                                  545:   1:    
9D0100A8  00001722   LBU T9, 0(V0)                546:       lbu	    t9, (v0)
9D0100AC  0006B719   BNE T9, T8, 0x9D0100BD       547:       bne	    t9, t8, 2f			    //skok, neni mezera
9D0100B2      0C00   NOP                          548:       nop
                                                  549:       //je mezera
9D0100B4      6D20   ADDIU V0, V0, 1              550:       addiu   v0, 1
                                                  551:       nop
9D0100B6      CFF8   B 0x9D0100A9                 552:       b16	    1b
9D0100BA      0C00   NOP                          553:       nop
                                                  554:       
                                                  555:   2:
                                                  556:       //jiz vynechal leve mezery
                                                  557:       sb	    t9, (v1)
9D0100BC  000A9419   BEQ T9, ZERO, 0x9D0100D5     558:       beqz    t9, 9f			    //skok, input je na konci
9D0100C4      0C00   NOP                          559:       nop
                                                  560:       
9D0100C6      6DB0   ADDIU V1, V1, 1              561:       addiu   v1, 1
9D0100C8      6D20   ADDIU V0, V0, 1              562:       addiu   v0, 1
9D0100CA  00001722   LBU T9, 0(V0)                563:       lbu	    t9, (v0)
                                                  564:       nop
9D0100CE      CFF6   B 0x9D0100BD                 565:       b16	    2b
9D0100D2      0C00   NOP                          566:       nop
                                                  567:       
                                                  568:   9:
                                                  569:       //za output vlozi 0x0
9D0100D4      45BF   JRC RA                       570:       jrc	    ra
                                                  571:       
                                                  572:   .end lTrim 
                                                  573:       
                                                  574:   //</editor-fold>
                                                  575:   
                                                  576:   //<editor-fold defaultstate="collapsed" desc="rTrim">
                                                  577:   .align 2     
                                                  578:   .global rTrim    
                                                  579:   .ent rTrim    
                                                  580:   rTrim:
                                                  581:   //a0=adresa input  string, zakoncene \0
                                                  582:   //a1=adresa output string, zakoncene \0
                                                  583:       
                                                  584:       //meni t6-t9, v0, v1
                                                  585:       
9D0100D8      0C44   MOVE V0, A0                  586:       move    v0, a0
9D0100DA      0DE0   MOVE T7, ZERO                587:       move    t7, zero
9D0100DC  002031C0   ADDIU T6, ZERO, 32           588:       addiu   t6, zero, _CHAR_SPACE
                                                  589:       
                                                  590:   1:    
9D0100E0  00001702   LBU T8, 0(V0)                591:       lbu	    t8, (v0)
9D0100E4  000A9418   BEQ T8, ZERO, 0x9D0100FD     592:       beqz    t8, 5f				//skok, je na konci input str
                                                  593:       nop
                                                  594:       
9D0100EA  000395D8   BEQ T8, T6, 0x9D0100F5       595:       beq	    t8, t6, 2f				//skok, je mezera
9D0100F0      0C00   NOP                          596:       nop
                                                  597:       
                                                  598:       //neni mezera
9D0100F2      0DE2   MOVE T7, V0                  599:       move    t7, v0				//zalohuj posledni pocizi znaku
                                                  600:   2:
9D0100F4      6D20   ADDIU V0, V0, 1              601:       addiu   v0, 1
                                                  602:       nop
9D0100F6      CFF4   B 0x9D0100E1                 603:       b16	    1b
9D0100FA      0C00   NOP                          604:       nop
                                                  605:       
                                                  606:   5:  
                                                  607:       move    v1, a1
9D0100FC  000F940F   BEQ T7, ZERO, 0x9D01011F     608:       beqz    t7, 9f				//skok, zadny znak v output
9D010102      0C00   NOP                          609:       nop
                                                  610:       
                                                  611:       //t7=adresa posledniho znaku
9D010104      0C44   MOVE V0, A0                  612:       move    v0, a0
                                                  613:       
                                                  614:   6:
9D010106  00001702   LBU T8, 0(V0)                615:       lbu	    t8, (v0)
9D01010A  00001B03   SB T8, 0(V1)                 616:       sb	    t8, (v1)
                                                  617:       addiu   v1, 1
                                                  618:       
9D01010E  000695E2   BEQ V0, T7, 0x9D01011F       619:       beq	    v0, t7, 9f				//skok, toto byl posledni znak
9D010114      0C00   NOP                          620:       nop    
9D010116      6D20   ADDIU V0, V0, 1              621:       addiu   v0, 1
                                                  622:       nop
9D010118      CFF6   B 0x9D010107                 623:       b16	    6b
9D01011C      0C00   NOP                          624:       nop
                                                  625:       
                                                  626:   9:
9D01011E      8830   SB S0, 0(V1)                 627:       sb	    zero, (v1)
9D010120      45BF   JRC RA                       628:       jrc	    ra
                                                  629:       
                                                  630:   .end rTrim   
                                                  631:       
                                                  632:   //</editor-fold>
                                                  633:       
                                                  634:   //<editor-fold defaultstate="collapsed" desc="trim">
                                                  635:   .align 2     
                                                  636:   .global trim
                                                  637:   .ent trim
                                                  638:   trim:
                                                  639:   //a0=adresa input  string, zakoncene \0
                                                  640:   //a1=adresa output string, zakoncene \0 
                                                  641:   //meni v0, v1, t5-t9  
                                                  642:       
9D010124      4FB8   ADDIU SP, SP, -4             643:       _PUSH   ra
                                                  644:       
9D010128      0DA4   MOVE T5, A0                  645:       move    t5, a0
                                                  646:       
9D01012A  FFB94060   BGEZAL ZERO, 0x9D0100A1      647:       bal	    lTrim	    //meni v0, v1, t8, t9
9D010132      0C00   NOP                          648:       nop
                                                  649:       
9D010134      0C85   MOVE A0, A1                  650:       move    a0, a1
9D010136  FFCF4060   BGEZAL ZERO, 0x9D0100D9      651:       bal	    rTrim
9D01013E      0C00   NOP                          652:       nop
                                                  653:       
9D010140      0C8D   MOVE A0, T5                  654:       move    a0, t5	    //meni t6-t9, v0, v1
                                                  655:       
9D010142      4BE0   LW RA, 0(SP)                 656:       _POP    ra
9D010146      45BF   JRC RA                       657:       jrc	    ra
                                                  658:       
                                                  659:   .end trim
                                                  660:       
                                                  661:   //</editor-fold>
                                                  662:       
                                                  663:   //<editor-fold defaultstate="collapsed" desc="addSpace">
                                                  664:   .align 2    
                                                  665:   .global addSpace
                                                  666:   .ent addSpace
                                                  667:   addSpace:    
                                                  668:   //a0=string \0
                                                  669:   //a1=pozadovany pocet platnych znaku (nepocita \0)
                                                  670:       
                                                  671:       //prida mezery na konec, aby dosahl pozadovaneho poctu znaku (nepocita \0 na konci, pouze platne znaky)
                                                  672:       
9D010148  00203100   ADDIU T0, ZERO, 32           673:       li	    t0, _CHAR_SPACE
9D01014C      0D20   MOVE T1, ZERO                674:       move    t1, zero
                                                  675:       
                                                  676:   1:    
9D01014E      0940   LBU V0, 0(A0)                677:       lbu	    v0, (a0)
9D010150      8D07   BEQZ V0, 0x9D010161          678:       beqz    v0, 5f
9D010154      0C00   NOP                          679:       nop
                                                  680:       
9D010156      4D22   ADDIU T1, T1, 1              681:       addiu   t1, 1			//pocet ++
9D010158      6E40   ADDIU A0, A0, 1              682:       addiu   a0, 1
                                                  683:       nop
9D01015A      CFF9   B 0x9D01014F                 684:       b16	    1b
9D01015E      0C00   NOP                          685:       nop
                                                  686:       
                                                  687:       
                                                  688:   5:    
                                                  689:       //nasel konec \0
9D010160  00099525   BEQ A1, T1, 0x9D010177       690:       beq	    a1, t1, 9f			//skok, je pozadovany pocet
9D010166      0C00   NOP                          691:       nop
                                                  692:       
9D010168  00001904   SB T0, 0(A0)                 693:       sb	    t0, (a0)
9D01016C      4D22   ADDIU T1, T1, 1              694:       addiu   t1, 1
9D01016E      6E40   ADDIU A0, A0, 1              695:       addiu   a0, 1
                                                  696:       nop
9D010170      CFF7   B 0x9D010161                 697:       b16	    5b
9D010174      0C00   NOP                          698:       nop
                                                  699:       
                                                  700:   9:
9D010176      8840   SB S0, 0(A0)                 701:       sb	    zero, (a0)
9D010178      45BF   JRC RA                       702:       jrc	    ra
                                                  703:       
                                                  704:   .end addSpace  
                                                  705:       
                                                  706:   //</editor-fold>
                                                  707:       
                                                  708:   //<editor-fold defaultstate="collapsed" desc="formatLeft">
                                                  709:       
                                                  710:   .align 2
                                                  711:   .global formatLeft
                                                  712:   .ent formatLeft
                                                  713:   formatLeft:
                                                  714:   //a0=char* result
                                                  715:   //a1=int size   (musi byt mensi, nez velikost result, fce prida \0)
                                                  716:   //a2=char* text (zakonceno \0)
                                                  717:       
                                                  718:   //prida na konec mezery, aby v result byla celkova delka size (pocet platnych znaku, na konec jeste prida \0)    
                                                  719:   //vysledek ulozi do result    
                                                  720:   //je-li text delsi nez size, bude zkracen na size (oriznuty zprava)  
                                                  721:       
9D01017C  00014105   TLTI A1, 0x1                 722:       tlti    a1, 1		    //trap, pri a1<1
9D010180  00203060   ADDIU V1, ZERO, 32           723:       addiu   v1, zero, _CHAR_SPACE   //v1=SPACE
                                                  724:       
9D010184  C15000A4   ADDU T8, A0, A1              725:       addu    t8, a0, a1		    //t8=adresa v result, kam zapise \0 (result + size)
                                                  726:       
                                                  727:   1:    
9D010188  00129704   BEQ A0, T8, 0x9D0101B1       728:       beq	    a0, t8, 3f
9D01018E      0C00   NOP                          729:       nop
                                                  730:       
9D010190      0960   LBU V0, 0(A2)                731:       lbu	    v0, (a2)
9D010192      8D08   BEQZ V0, 0x9D0101A5          732:       beqz    v0, 2f
9D010196      0C00   NOP                          733:       nop
                                                  734:       
9D010198      8940   SB V0, 0(A0)                 735:       sb	    v0, (a0)
9D01019A      6E40   ADDIU A0, A0, 1              736:       addiu   a0, 1
9D01019C      6F60   ADDIU A2, A2, 1              737:       addiu   a2, 1
                                                  738:       nop
9D01019E      CFF4   B 0x9D010189                 739:       b16	    1b
9D0101A2      0C00   NOP                          740:       nop
                                                  741:       
                                                  742:   2:
9D0101A4      89C0   SB V1, 0(A0)                 743:       sb	    v1, (a0)
9D0101A6      6E40   ADDIU A0, A0, 1              744:       addiu   a0, 1
                                                  745:       
9D0101A8  FFFCB704   BNE A0, T8, 0x9D0101A5       746:       bne	    a0, t8, 2b	    //skok, result jeste nema pozadovanou velikost
9D0101AE      0C00   NOP                          747:       nop
                                                  748:       
                                                  749:       
                                                  750:       
                                                  751:   3:
                                                  752:       //a0=adresa za textem, kam vlozi \0
9D0101B0      8840   SB S0, 0(A0)                 753:       sb	    zero, (a0)
                                                  754:       
9D0101B2      45BF   JRC RA                       755:       jrc	    ra
                                                  756:       
                                                  757:   .end formatLeft 
                                                  758:       
                                                  759:   //</editor-fold>
                                                  760:      
                                                  761:   //<editor-fold defaultstate="collapsed" desc="formatRight">
                                                  762:       
                                                  763:   .align 2
                                                  764:   .global formatRight
                                                  765:   .ent formatRight
                                                  766:   formatRight:
                                                  767:   //a0=char* result
                                                  768:   //a1=int size   (musi byt mensi, nez velikost result, fce prida \0)
                                                  769:   //a2=char* text (zakonceno \0)
                                                  770:       
                                                  771:   //prida na zacatek mezery, aby v result byla celkova delka size (pocet platnych znaku, bez \0)
                                                  772:   //vysledek ulozi do result    
                                                  773:   //je-li text delsi nez size, bude zkracen na size (oriznuty zleva)    
                                                  774:       
9D0101B4  00014105   TLTI A1, 0x1                 775:       tlti    a1, 1		    //trap, pri a1<1
9D0101B8  00203060   ADDIU V1, ZERO, 32           776:       addiu   v1, zero, _CHAR_SPACE   //v1=SPACE
                                                  777:       
                                                  778:       //najdi konec textu
9D0101BC      0F26   MOVE T9, A2                  779:       move    t9, a2		    //adresa textu
                                                  780:       
                                                  781:       //najdi konec textu
                                                  782:   1:    
9D0101BE  00001719   LBU T8, 0(T9)                783:       lbu	    t8, (t9)
9D0101C2  00069418   BEQ T8, ZERO, 0x9D0101D3     784:       beqz    t8, 2f		    //skok, nasel konec textu
9D0101C8      0C00   NOP                          785:       nop
9D0101CA      4F22   ADDIU T9, T9, 1              786:       addiu   t9, 1		    //++
                                                  787:       nop
9D0101CC      CFF8   B 0x9D0101BF                 788:       b16	    1b
9D0101D0      0C00   NOP                          789:       nop
                                                  790:       
                                                  791:       
                                                  792:   2:
                                                  793:       //t9=adresa za poslednim platnym znakem v text (ukazuje na \0)
                                                  794:       
9D0101D2  C15000A4   ADDU T8, A0, A1              795:       addu    t8, a0, a1			//pozice za result, zde bude v result \0 (result + size)
9D0101D6  00001818   SB ZERO, 0(T8)               796:       sb	    zero, (t8)			//\0
                                                  797:       
                                                  798:   3:    
9D0101DA  000E94D9   BEQ T9, A2, 0x9D0101FB       799:       beq	    t9, a2, 4f			//skok, text je na prvnim znaku
                                                  800:       nop
                                                  801:       
9D0101E0  00159498   BEQ T8, A0, 0x9D01020F       802:       beq	    t8, a0, 9f			//skok, result je na prvnim znaku (text je delsi nez size)
9D0101E6      0C00   NOP                          803:       nop
                                                  804:       
9D0101E8      4F3E   ADDIU T9, T9, -1             805:       addiu   t9, -1
9D0101EA      4F1E   ADDIU T8, T8, -1             806:       addiu   t8, -1
                                                  807:       
9D0101EC  00001459   LBU V0, 0(T9)                808:       lbu	    v0, (t9)
9D0101F0  00001858   SB V0, 0(T8)                 809:       sb	    v0, (t8)
                                                  810:       nop
9D0101F4      CFF2   B 0x9D0101DB                 811:       b16	    3b
9D0101F8      0C00   NOP                          812:       nop
                                                  813:       
                                                  814:   4:
                                                  815:       //text vycerpal, bude doplnovat MEZERY
9D0101FA  00089498   BEQ T8, A0, 0x9D01020F       816:       beq	    t8, a0, 9f			//skok, result je na prvnim znaku
9D010200      0C00   NOP                          817:       nop
                                                  818:       
9D010202      4F1E   ADDIU T8, T8, -1             819:       addiu   t8, -1
9D010204  00001878   SB V1, 0(T8)                 820:       sb	    v1, (t8)
                                                  821:       nop
9D010208      CFF8   B 0x9D0101FB                 822:       b16	    4b
9D01020C      0C00   NOP                          823:       nop
                                                  824:       
                                                  825:   9:
                                                  826:       
9D01020E      45BF   JRC RA                       827:       jrc	    ra
                                                  828:       
                                                  829:   .end formatRight 
                                                  830:       
                                                  831:   //</editor-fold>
                                                  832:       
                                                  833:   
                                                  834:   //<editor-fold defaultstate="collapsed" desc="rndInt">
                                                  835:       
                                                  836:   .align 2
                                                  837:   .global rndInt
                                                  838:   .ent rndInt
                                                  839:   rndInt:
                                                  840:   //a0=int
                                                  841:   //a1=cipher zaokrouhli 1=desitky, 2=stovky, 3=tisice, ...
                                                  842:       //fce provede zaokrouhleni cisla 
                                                  843:       
9D010210  00053040   ADDIU V0, ZERO, 5            844:       addiu   v0, zero, 5
9D010214  000A3060   ADDIU V1, ZERO, 10           845:       addiu   v1, zero, 10
9D010218  000A3320   ADDIU T9, ZERO, 10           846:       addiu   t9, zero, 10
                                                  847:       addiu   t8, zero, 1
                                                  848:       
9D01021C  00054044   BGEZ A0, 0x9D01022B          849:       bgez    a0, 1f	    //skok, a0 je kladne
9D010224      0C00   NOP                          850:       nop
                                                  851:       
                                                  852:       //a0 je zaporne, prevod na kladne
                                                  853:       //addi    t8, zero, -1
                                                  854:       //mult    a0, t8
                                                  855:       //mflo    a0
9D010226  FFFB3040   ADDIU V0, ZERO, -5           856:       addiu   v0, zero, -5
                                                  857:       
                                                  858:       
                                                  859:   1:    
9D01022A      6EDE   ADDIU A1, A1, -1             860:       addiu   a1, -1
                                                  861:       
9D01022C      8E8B   BEQZ A1, 0x9D010245          862:       beqz    a1, 2f	    //skok, v0 a v1 je nastaveno na spravne hodnoty
9D010230      0C00   NOP                          863:       nop
                                                  864:       
9D010232  9B3C0323   MULTU V1, T9                 865:       multu   v1, t9	    //v1x10 (100,1000,...)
9D010236      4643   MFLO V1                      866:       mflo    v1
9D010238  8B3C0322   MULT V0, T9                  867:       mult    v0, t9	    //v0x10 (50,500,... / -50,-500,...)
9D01023C      4642   MFLO V0                      868:       mflo    v0
                                                  869:       nop
9D01023E      CFF5   B 0x9D01022B                 870:       b16	    1b
9D010242      0C00   NOP                          871:       nop
                                                  872:       
                                                  873:   2:    
                                                  874:       //v0=5,50,500,5000,... / -5,-50,-500,... 
                                                  875:       //v1=10,100,1000,10000,...
9D010244  21100044   ADD A0, A0, V0               876:       add     a0, v0	//i+v0
9D010248  703C0003   TEQ V1, ZERO                 877:       div	    a0, v1	// / v1
9D010262      4644   MFLO A0                      878:       mflo    a0
9D010264  9B3C0064   MULTU A0, V1                 879:       multu   a0, v1	// x v1
9D010268      4642   MFLO V0                      880:       mflo    v0		//return v0
                                                  881:       
                                                  882:       //+/- vysledek
                                                  883:       //mult    v0, t8
                                                  884:       //mflo    v0
                                                  885:       
9D01026A      45BF   JRC RA                       886:       jrc	    ra
                                                  887:       
                                                  888:   9:
                                                  889:       //chyba a1=0
9D01026C      0C44   MOVE V0, A0                  890:       move    v0, a0
9D01026E      45BF   JRC RA                       891:       jrc	    ra
                                                  892:       
                                                  893:   .end rndInt  
                                                  894:       
                                                  895:   //</editor-fold>
                                                  896:     
                                                  897:   //<editor-fold defaultstate="collapsed" desc="random">
                                                  898:       
                                                  899:   .align 2
                                                  900:   .global random
                                                  901:   .ent random
                                                  902:   random:
                                                  903:   //a0=rozsah  (0 ... rozsah)
                                                  904:   //fce vraci nahodne cislo - word 32-bit
                                                  905:       
9D010270  00FC0049   MFC0 V0, Count               906:       mfc0    v0, _CP0_COUNT
                                                  907:       
9D010274  11500322   ADDU V0, V0, T9              908:       addu    v0, t9
9D010278  11500302   ADDU V0, V0, T8              909:       addu    v0, t8
9D01027C      0544   ADDU V0, V0, A0              910:       addu    v0, a0
9D01027E      0554   ADDU V0, V0, A1              911:       addu    v0, a1
9D010280  11500242   ADDU V0, V0, S2              912:       addu    v0, s2
9D010284  11500262   ADDU V0, V0, S3              913:       addu    v0, s3    
9D010288  115003A2   ADDU V0, V0, SP              914:       addu    v0, sp
9D01028C  11500362   ADDU V0, V0, K1              915:       addu    v0, k1
                                                  916:       
                                                  917:       //nuluj b31, kladne cislo
9D010290  FFCC0040   INS V0, ZERO, 31, 1          918:       ins	    v0, zero, 31, 1
                                                  919:       nop
9D010294      CC03   B 0x9D01029D                 920:       b16	    2f
9D010298      0C00   NOP                          921:       nop
                                                  922:       
                                                  923:   1:
9D01029A      2523   SRL V0, V0, 1                924:       srl	    v0, 1
                                                  925:   2:    
9D01029C  C9D00082   SUBU T9, V0, A0              926:       subu    t9, v0, a0
9D0102A0  FFFB40D9   BGTZ T9, 0x9D01029B          927:       bgtz    t9, 1b
9D0102A6      0C00   NOP                          928:       nop
                                                  929:       
9D0102A8      45BF   JRC RA                       930:       jrc	    ra
                                                  931:       
                                                  932:   .end random  
                                                  933:       
                                                  934:   //</editor-fold>    
                                                  935:       
                                                  936:   //<editor-fold defaultstate="collapsed" desc="compareTimerMs">
                                                  937:       
                                                  938:   .align 2
                                                  939:   .global compareTimerMs
                                                  940:   .ent compareTimerMs    
                                                  941:   compareTimerMs:
                                                  942:   //a0=porovnavany cas (predpoklada se, ze je starsi, nez soucasny - timer_ms)
                                                  943:   //vraci kolik ms uplynulo od zadaneho casu    
                                                  944:   //meni t8,t9 (v0)    
                                                  945:       
                                                  946:       //je-li timer nastaven na 10ms, rozdil je po 10ms
                                                  947:       
9D0102AC  800041B9   LUI T9, 0x8000               948:       lw	    t9, (timer_ms)
9D0102B4  11D00099   SUBU V0, T9, A0              949:       subu    v0, t9, a0
                                                  950:        
9D0102B8  00034002   BLTZ V0, 0x9D0102C3          951:       bltz    v0, 1f
9D0102BE      0C00   NOP                          952:       nop
9D0102C0      45BF   JRC RA                       953:       jrc	    ra
                                                  954:       
                                                  955:   1:
                                                  956:       //doslo k preteceni timer_ms
9D0102C2  FFFF3300   ADDIU T8, ZERO, -1           957:       li	    t8, 0xFFFFFFFF
9D0102C6  11D00098   SUBU V0, T8, A0              958:       subu    v0, t8, a0 
9D0102CA  11500322   ADDU V0, V0, T9              959:       addu    v0, t9
9D0102CE      45BF   JRC RA                       960:       jrc	    ra
                                                  961:       
                                                  962:   .end compareTimerMs 
                                                  963:   
                                                  964:   .align 2
                                                  965:   .global pauseEvent
                                                  966:   .ent pauseEvent
                                                  967:   pauseEvent:
                                                  968:   //a0=pauza ms
                                                  969:       
                                                  970:   #ifdef SIMULATOR
                                                  971:       //simulator nemeri cas
9D0102D0      45BF   JRC RA                       972:       jrc	    ra
                                                  973:   #endif    
                                                  974:       
9D0102D2      0CDF   MOVE A2, RA                  975:       move    a2, ra		    //zaloha ra
9D0102D4      0C64   MOVE V1, A0                  976:       move    v1, a0		    //pocet ms cekani
9D0102D6  800041A4   LUI A0, 0x8000               977:       lw	    a0, timer_ms	    //pocatecni time_ms
                                                  978:       
                                                  979:   1:
                                                  980:       //test, zda je jiz Threading (muze volat doEvents)
9D0102DE  800041B9   LUI T9, 0x8000               981:       lbu	    t9, (SYSTEM_STATUS)	    //SYSTEM_STATUS.b0=Threading
9D0102E6  002C0339   EXT T9, T9, 0, 1             982:       ext	    t9, t9, 0, 1	    //ext b0
9D0102EA  00079419   BEQ T9, ZERO, 0x9D0102FD     983:       beqz    t9, 2f
9D0102F0      0C00   NOP                          984:       nop
                                                  985:       
                                                  986:       //doEvents
9D0102F2  FE134060   BGEZAL ZERO, 0x9D00FF1D      987:       bal	    doEvents		    //neuklada obsah t0-t9
9D0102FA      0C00   NOP                          988:       nop
                                                  989:       
                                                  990:   2:    
                                                  991:       //porovnava aktualni time_ms s time_ms v a0 (pocatecni cas)
9D0102FC  FFD64060   BGEZAL ZERO, 0x9D0102AD      992:       bal	    compareTimerMs	    //meni t9, t8, v0 vraci kolik uplynulo ms (po 10 ms)
9D010304      0C00   NOP                          993:       nop
                                                  994:       
9D010306      0535   SUBU V0, V0, V1              995:       subu    v0, v1
9D010308  FFE94002   BLTZ V0, 0x9D0102DF          996:       bltz    v0, 1b		    //skok, neuplynul cas
9D01030E      0C00   NOP                          997:       nop
                                                  998:       
9D010310      0FE6   MOVE RA, A2                  999:       move    ra, a2		    //obnov ra
9D010312      45BF   JRC RA                       1000:      jrc	    ra
                                                  1001:      
                                                  1002:  .end pauseEvent    
                                                  1003:      
                                                  1004:  //</editor-fold>
                                                  1005:     
                                                  1006:       
                                                  1007:  //<editor-fold defaultstate="collapsed" desc="macro _WRITE_CIPHER">
                                                  1008:      
                                                  1009:  .macro _WRITE_CIPHER num, cip, rad, result
                                                  1010:  //num = zapisovane cislo 0-9
                                                  1011:  //cip = pozadovany pocet cifer (min.)    
                                                  1012:  //rad = aktualni rad (10=mld, 2=desitky, 1=jednotky)    
                                                  1013:  //result = vysledne pole 
                                                  1014:  //meni t9    
                                                  1015:      
                                                  1016:      beqz    \num, 1002f
                                                  1017:      nop
                                                  1018:      
                                                  1019:      //num neni 0
                                                  1020:      addiu   \cip, zero, 10	//nastavi cip=10, tzn. ze od ted bude zapisovat kazde cislo, i 0
                                                  1021:      
                                                  1022:  1001:    
                                                  1023:      addiu   \num, 0x30		//mun - ascii
                                                  1024:      sb	    \num, (\result)
                                                  1025:      addiu   \result, 1		//result++
                                                  1026:      
                                                  1027:      nop
                                                  1028:      b16	    1003f
                                                  1029:      nop
                                                  1030:      
                                                  1031:  1002:
                                                  1032:      //num je nula
                                                  1033:      subu    t9, \rad, \cip
                                                  1034:      blez    t9, 1001b		//skok, tuto "0" bude zapisovat (rad <= cip)
                                                  1035:      nop
                                                  1036:      
                                                  1037:      //num je nula na zacatku, zatim nepronadi zapis
                                                  1038:      
                                                  1039:  1003:    
                                                  1040:      
                                                  1041:  .endm 
                                                  1042:      
                                                  1043:  //</editor-fold>
                                                  1044:      
                                                  1045:  //<editor-fold defaultstate="collapsed" desc="intToChar">
                                                  1046:      
                                                  1047:  .align 2
                                                  1048:  .global intToChar
                                                  1049:  .ent intToChar
                                                  1050:  intToChar:
                                                  1051:  //a0=int
                                                  1052:  //a1=char* result (min. char[12] -xxxxxxxxxx\0)
                                                  1053:  //a2=pocet cifer (min. pocet cifer, je-li cislo mensi, bude zleva doplneno 0) 1-10    
                                                  1054:  //meni t4-t9, a0-a2    
                                                  1055:      
9D010314  000A4044   BGEZ A0, 0x9D01032D          1056:      bgez    a0, uintToChar	    //skok, int je kladne
9D01031A      0C00   NOP                          1057:      nop
                                                  1058:      
                                                  1059:      //int je zaporne, zapise "-" a prevede na kladne
                                                  1060:      //result[.]="-"
9D01031C  002D3320   ADDIU T9, ZERO, 45           1061:      addiu   t9, zero, _CHAR_MINUS
9D010320  00001B25   SB T9, 0(A1)                 1062:      sb	    t9, (a1)
9D010324      6ED0   ADDIU A1, A1, 1              1063:      addiu   a1, 1		    //result++
                                                  1064:      
                                                  1065:      //int prevod na kladne cislo (NEG(int) + 1)
9D010326  22D00004   NOR A0, A0, ZERO             1066:      not	    a0
9D01032A      6E40   ADDIU A0, A0, 1              1067:      addiu   a0, 1
                                                  1068:      
                                                  1069:  .global uintToChar   
                                                  1070:  uintToChar:    
                                                  1071:      
9D01032C  000A3180   ADDIU T4, ZERO, 10           1072:      addiu   t4, zero, 10	    //rad, aktualni rad cisla (10=mld, 1=jednotky)
9D010330  3B9A41AD   LUI T5, 0x3B9A               1073:      li	    t5, 1000000000
9D010338  000A31E0   ADDIU T7, ZERO, 10           1074:      addiu   t7, zero, 10	    //konst    
                                                  1075:      
                                                  1076:      
                                                  1077:  1:
                                                  1078:      //int je kladne cislo
9D01033C  703C000D   TEQ T5, ZERO                 1079:      divu    t6, a0, t5
9D010346      464E   MFLO T6                      1080:      mflo    t6			    //t6=num
                                                  1081:      mfhi    a0			    //zbytek
                                                  1082:      
                                                  1083:      //num, cip, rad, result
9D010348  000C940E   BEQ T6, ZERO, 0x9D010365     1084:      _WRITE_CIPHER t6, a2, t4, a1    //meni t9
                                                  1085:      //result++, pokud provedl zapis
                                                  1086:      
9D010370      4D9E   ADDIU T4, T4, -1             1087:      addiu   t4, -1		    //rad--
9D010372  703C000F   TEQ T7, ZERO                 1088:      divu    t5, t7		    //c/10
9D01037C      464D   MFLO T5                      1089:      mflo    t5
                                                  1090:      
9D01037E      ED01   LI V0, 1                     1091:      li16    v0, 1
9D010380  FFDCB44D   BNE T5, V0, 0x9D01033D       1092:      bne	    t5, v0, 1b		    //skok, dalsi kolo
9D010386      0C00   NOP                          1093:      nop
                                                  1094:      
                                                  1095:      //konec a0=jednotky
9D010388  00303084   ADDIU A0, A0, 48             1096:      addiu   a0, 0x30		    //prevod na ascii znak
9D01038C      8A50   SB A0, 0(A1)                 1097:      sb	    a0, (a1)		    //result[]=jednotky
9D01038E      8851   SB S0, 1(A1)                 1098:      sb	    zero, 1(a1)		    //result[]=\0
                                                  1099:      
9D010390      45BF   JRC RA                       1100:      jrc	    ra
                                                  1101:      
                                                  1102:  .end intToChar
                                                  1103:      
                                                  1104:  //</editor-fold>
                                                  1105:      
                                                  1106:  //<editor-fold defaultstate="collapsed" desc="byteToChar">
                                                  1107:      
                                                  1108:  .align 2
                                                  1109:  .global byteToChar
                                                  1110:  .ent byteToChar
                                                  1111:  byteToChar:  
                                                  1112:  //a0=byte
                                                  1113:  //a1=char* result (min char[4], xxx\0  )
                                                  1114:  //a2=pocet cifer (min. pocet cifer, je-li cislo mensi, bude zleva doplneno 0) 1-3
                                                  1115:  //meni t4-t9, a0-a2
                                                  1116:      
                                                  1117:  //prevod byte bez znamenka
                                                  1118:      
9D010394  00033180   ADDIU T4, ZERO, 3            1119:      addiu   t4, zero, 3		    //rad, aktualni rad cisla (3=stovky, 1=jednotky)
9D010398  006431A0   ADDIU T5, ZERO, 100          1120:      li	    t5, 100		    //c
9D01039C  000A31E0   ADDIU T7, ZERO, 10           1121:      addiu   t7, zero, 10	    //konst  
                                                  1122:      
9D0103A0      2E4D   ANDI A0, A0, 0xFF            1123:      andi    a0, 0xFF		    //nuluje b8-b31
                                                  1124:      
                                                  1125:      
                                                  1126:  1:
                                                  1127:      //int je kladne cislo
9D0103A2  703C000D   TEQ T5, ZERO                 1128:      divu    t6, a0, t5
9D0103AC      464E   MFLO T6                      1129:      mflo    t6			    //t6=num
                                                  1130:      mfhi    a0			    //zbytek
                                                  1131:      
                                                  1132:      //num, cip, rad, result
9D0103AE  000C940E   BEQ T6, ZERO, 0x9D0103CB     1133:      _WRITE_CIPHER t6, a2, t4, a1    //meni t9
                                                  1134:      //result++, pokud provedl zapis
                                                  1135:      
9D0103D6      4D9E   ADDIU T4, T4, -1             1136:      addiu   t4, -1		    //rad--
9D0103D8  703C000F   TEQ T7, ZERO                 1137:      divu    t5, t7		    //c/10
9D0103E2      464D   MFLO T5                      1138:      mflo    t5
                                                  1139:      
9D0103E4      ED01   LI V0, 1                     1140:      li16    v0, 1
9D0103E6  FFDCB44D   BNE T5, V0, 0x9D0103A3       1141:      bne	    t5, v0, 1b		    //skok, dalsi kolo
9D0103EC      0C00   NOP                          1142:      nop
                                                  1143:      
                                                  1144:      //konec a0=jednotky
9D0103EE  00303084   ADDIU A0, A0, 48             1145:      addiu   a0, 0x30		    //prevod na ascii znak
9D0103F2      8A50   SB A0, 0(A1)                 1146:      sb	    a0, (a1)		    //result[]=jednotky
9D0103F4      8851   SB S0, 1(A1)                 1147:      sb	    zero, 1(a1)		    //result[]=\0
                                                  1148:      
9D0103F6      45BF   JRC RA                       1149:      jrc	    ra
                                                  1150:      
                                                  1151:  .end byteToChar
                                                  1152:      
                                                  1153:  //</editor-fold>
                                                  1154:      
                                                  1155:      
                                                  1156:      
                                                  1157:      
                                                  1158:      
                                                  1159:  //<editor-fold defaultstate="collapsed" desc="setPortDigOut">
                                                  1160:  .align 2    
                                                  1161:  .global setPortDigOut    
                                                  1162:  .ent setPortDigOut
                                                  1163:  setPortDigOut:    
                                                  1164:  //a0 base adresa portu, PORTA_BASE, PORTB_BASE, ...
                                                  1165:  //a1 pozadivane bity BIT0, BIT2 | BIT3, ...  
                                                  1166:      
                                                  1167:      //nastavuje pouze TRIS (in/out) a ANSEL (analog/digital)
                                                  1168:      
                                                  1169:      //napr.: setPortDigOut(POTRA_BASE, BIT1 | BIT4 | BIT8);
                                                  1170:      
                                                  1171:      //TRISbit=0
9D0103F8  001438A4   SH A1, 20(A0)                1172:      sh32    a1, (TRIS_OFFSET + CLR_OFFSET)(a0)
                                                  1173:      //ANSELbit=0 
9D0103FC  000438A4   SH A1, 4(A0)                 1174:      sh32    a1, (ANSEL_OFFSET + CLR_OFFSET)(a0)
                                                  1175:      
9D010400      45BF   JRC RA                       1176:      jrc	    ra
                                                  1177:      
                                                  1178:  .end setPortDigOut 
                                                  1179:  
                                                  1180:  //</editor-fold>
                                                  1181:      
                                                  1182:  //<editor-fold defaultstate="collapsed" desc="setPortDigIn">
                                                  1183:  .align 2    
                                                  1184:  .global setPortDigIn     
                                                  1185:  .ent setPortDigIn
                                                  1186:  setPortDigIn:    
                                                  1187:  //a0 base adresa portu, PORTA_BASE, PORTB_BASE, ...
                                                  1188:  //a1 pozadivane bity BIT0, BIT2 | BIT3, ...    
                                                  1189:      
                                                  1190:      //nastavuje pouze TRIS (in/out) a ANSEL (analog/digital)
                                                  1191:      
                                                  1192:      //napr.: setPortDigIn(POTRA_BASE, BIT1 | BIT4 | BIT8);
                                                  1193:      
                                                  1194:      //TRISbit=1
9D010404  001838A4   SH A1, 24(A0)                1195:      sh32    a1, (TRIS_OFFSET + SET_OFFSET)(a0)
                                                  1196:      //ANSELbit=0 
9D010408  000438A4   SH A1, 4(A0)                 1197:      sh32    a1, (ANSEL_OFFSET + CLR_OFFSET)(a0)
                                                  1198:      
9D01040C      45BF   JRC RA                       1199:      jrc	    ra
                                                  1200:      
                                                  1201:  .end setPortDigIn 
                                                  1202:      
                                                  1203:  //</editor-fold>
                                                  1204:      
                                                  1205:  //<editor-fold defaultstate="collapsed" desc="setPortAnalogIn">
                                                  1206:  .align 2    
                                                  1207:  .global setPortAnalogIn     
                                                  1208:  .ent setPortAnalogIn
                                                  1209:  setPortAnalogIn:    
                                                  1210:  //a0 base adresa portu, PORTA_BASE, PORTB_BASE, ...
                                                  1211:  //a1 pozadivane bity BIT0, BIT2 | BIT3, ...    
                                                  1212:      
                                                  1213:      //nastavuje pouze TRIS (in/out) a ANSEL (analog/digital)
                                                  1214:      
                                                  1215:      //napr.: setPortAnalogIn(POTRA_BASE, BIT1 | BIT4 | BIT8);
                                                  1216:      
                                                  1217:      //TRISbit=1
9D010410  001838A4   SH A1, 24(A0)                1218:      sh32    a1, (TRIS_OFFSET + SET_OFFSET)(a0)
                                                  1219:      //ANSELbit=1 
9D010414  000438A4   SH A1, 4(A0)                 1220:      sh32    a1, (ANSEL_OFFSET + CLR_OFFSET)(a0)
                                                  1221:      
9D010418      45BF   JRC RA                       1222:      jrc	    ra
                                                  1223:      
                                                  1224:  .end setPortAnalogIn 
                                                  1225:      
                                                  1226:  //</editor-fold>
                                                  1227:      
                                                  1228:  //<editor-fold defaultstate="collapsed" desc="setPortOpenDrain">
                                                  1229:  .align 2    
                                                  1230:  .global setPortOpenDrain     
                                                  1231:  .ent setPortOpenDrain
                                                  1232:  setPortOpenDrain:    
                                                  1233:  //a0 base adresa portu, PORTA_BASE, PORTB_BASE, ...
                                                  1234:  //a1 pozadivane bity BIT0, BIT2 | BIT3, ... 
                                                  1235:  //a2 1=nastav ODC, 0=nuluj ODC (vypnuto)    
                                                  1236:      
                                                  1237:      //nastavuje hodnotu ODCx 
                                                  1238:      
                                                  1239:      //napr.: setPortOpenDrain(POTRA_BASE, BIT1 | BIT4 | BIT8, 1);		//nastav OpenDrain B.1, B.4, B.8
                                                  1240:      
9D01041C      8F05   BEQZ A2, 0x9D010429          1241:      beqz    a2, 1f
9D010420      0C00   NOP                          1242:      nop
                                                  1243:      
                                                  1244:      //ODCx=1
9D010422  004838A4   SH A1, 72(A0)                1245:      sh32    a1, (ODC_OFFSET + SET_OFFSET)(a0)
9D010426      45BF   JRC RA                       1246:      jrc	    ra
                                                  1247:      
                                                  1248:  1:
                                                  1249:      //ODCx=0
9D010428  004438A4   SH A1, 68(A0)                1250:      sh32    a1, (ODC_OFFSET + CLR_OFFSET)(a0)
9D01042C      45BF   JRC RA                       1251:      jrc	    ra
                                                  1252:      
                                                  1253:  .end setPortOpenDrain
                                                  1254:      
                                                  1255:  //</editor-fold>
                                                  1256:    
                                                  1257:  //<editor-fold defaultstate="collapsed" desc="setPortPullUp">
                                                  1258:  .align 2    
                                                  1259:  .global setPortPullUp     
                                                  1260:  .ent setPortPullUp
                                                  1261:  setPortPullUp:    
                                                  1262:  //a0 base adresa portu, PORTA_BASE, PORTB_BASE, ...
                                                  1263:  //a1 pozadivane bity BIT0, BIT2 | BIT3, ... 
                                                  1264:  //a2 1=nastav PullUp, 0=nuluj PullUp (vypnuto)    
                                                  1265:      
                                                  1266:      //nastavuje hodnotu CNPUx 
                                                  1267:      
                                                  1268:      //napr.: setPortPullUp(POTRA_BASE, BIT1 | BIT4 | BIT8, 1);			//nastav PullUp B.1, B.4, B.8
                                                  1269:      
9D010430      8F05   BEQZ A2, 0x9D01043D          1270:      beqz    a2, 1f
9D010434      0C00   NOP                          1271:      nop
                                                  1272:      
                                                  1273:      //CNPUx=1
9D010436  005838A4   SH A1, 88(A0)                1274:      sh32    a1, (CNPU_OFFSET + SET_OFFSET)(a0)
9D01043A      45BF   JRC RA                       1275:      jrc	    ra
                                                  1276:      
                                                  1277:  1:
                                                  1278:      //CNPUx=0
9D01043C  005438A4   SH A1, 84(A0)                1279:      sh32    a1, (CNPU_OFFSET + CLR_OFFSET)(a0)
9D010440      45BF   JRC RA                       1280:      jrc	    ra
                                                  1281:      
                                                  1282:  .end setPortPullUp 
                                                  1283:      
                                                  1284:  //</editor-fold>
                                                  1285:   
                                                  1286:  //<editor-fold defaultstate="collapsed" desc="setPortPullDown">
                                                  1287:  .align 2    
                                                  1288:  .global setPortPullDown     
                                                  1289:  .ent setPortPullDown
                                                  1290:  setPortPullDown:    
                                                  1291:  //a0 base adresa portu, PORTA_BASE, PORTB_BASE, ...
                                                  1292:  //a1 pozadivane bity BIT0, BIT2 | BIT3, ... 
                                                  1293:  //a2 1=nastav PullDown, 0=nuluj PullDown (vypnuto)    
                                                  1294:      
                                                  1295:      //nastavuje hodnotu CNPDx 
                                                  1296:      
                                                  1297:      //napr.: setPortPullDown(POTRA_BASE, BIT1 | BIT4 | BIT8, 1);			//nastav PullDown B.1, B.4, B.8
                                                  1298:      
9D010444      8F05   BEQZ A2, 0x9D010451          1299:      beqz    a2, 1f
9D010448      0C00   NOP                          1300:      nop
                                                  1301:      
                                                  1302:      //CNPDx=1
9D01044A  006838A4   SH A1, 104(A0)               1303:      sh32    a1, (CNPD_OFFSET + SET_OFFSET)(a0)
9D01044E      45BF   JRC RA                       1304:      jrc	    ra
                                                  1305:      
                                                  1306:  1:
                                                  1307:      //CNPDx=0
9D010450  006438A4   SH A1, 100(A0)               1308:      sh32    a1, (CNPD_OFFSET + CLR_OFFSET)(a0)
9D010454      45BF   JRC RA                       1309:      jrc	    ra
                                                  1310:      
                                                  1311:  .end setPortPullDown
                                                  1312:      
                                                  1313:  //</editor-fold>
                                                  1314:      
                                                  1315:      
                                                  1316:  //<editor-fold defaultstate="collapsed" desc="defragTableW">
                                                  1317:      
                                                  1318:  .align 2
                                                  1319:  .global defragTableW
                                                  1320:  .ent defragTableW
                                                  1321:  defragTableW:
                                                  1322:  //a0=adresa tabulky
                                                  1323:  //a1=item size [bytes] (delitelne 4)
                                                  1324:  //a2=max. pocet polozek, item cnt
                                                  1325:  //meni t7-t9, v0, v1, a0-a2
                                                  1326:      
                                                  1327:      //tabulka musi obsahovat polozky word (velikost polozky min. 1 word, delitelna 4)
                                                  1328:      //posouva polozky v tabulce tak, aby mezi nimi nebyly neplatne polozky
                                                  1329:      //tzn. prvni nulova polozka je konec tabulky
                                                  1330:      //polozka musi zacinat word, ktery urcuje jeji platnost. Hodnota 0x0 = polozka je neplatna, hodnota != 0x0, polozka je platna
                                                  1331:      
                                                  1332:      
                                                  1333:      //a0=src
                                                  1334:      //t7=dest
9D010458      0DE4   MOVE T7, A0                  1335:      move    t7, a0
                                                  1336:      
                                                  1337:  1:
9D01045A  0000FF24   LW T9, 0(A0)                 1338:      lw	    t9, (a0)		    //load src data
9D01045E  00079419   BEQ T9, ZERO, 0x9D010471     1339:      beqz    t9, 3f		    //skok, src data=0
                                                  1340:      nop
                                                  1341:      
                                                  1342:      //src data neni 0
9D010464  000BB48F   BNE T7, A0, 0x9D01047F       1343:      bne	    t7, a0, 4f		    //skok src != dest, bude presun
9D01046A      0C00   NOP                          1344:      nop
                                                  1345:      
                                                  1346:      //src=dest, zadny presun
                                                  1347:  2:    
9D01046C  795000AF   ADDU T7, T7, A1              1348:      addu    t7, a1		    //dest++
                                                  1349:      
                                                  1350:  3:
9D010470      0658   ADDU A0, A0, A1              1351:      addu    a0, a1		    //src++
9D010472      6F6E   ADDIU A2, A2, -1             1352:      addiu   a2, -1		    //item cnt--
9D010474      AF72   BNEZ A2, 0x9D01045B          1353:      bne	    a2, zero, 1b	    //neni konec
9D010478      0C00   NOP                          1354:      nop
                                                  1355:      
                                                  1356:      //je konec, prosel vsechny polozky
9D01047A      45BF   JRC RA                       1357:      jrc	    ra
9D01047C      0C00   NOP                          1358:      nop
                                                  1359:      
                                                  1360:  4:
                                                  1361:      //presun dat ze src do dest
9D01047E      0C44   MOVE V0, A0                  1362:      move    v0, a0		    //src
9D010480      0C6F   MOVE V1, T7                  1363:      move    v1, t7		    //dest
9D010482      0F05   MOVE T8, A1                  1364:      move    t8, a1		    //size bytes
                                                  1365:      
                                                  1366:  5:    
9D010484  0000FF22   LW T9, 0(V0)                 1367:      lw	    t9, (v0)
9D010488  0000FB23   SW T9, 0(V1)                 1368:      sw	    t9, (v1)
9D01048C      6D22   ADDIU V0, V0, 4              1369:      addiu   v0, 4
9D01048E      6DB2   ADDIU V1, V1, 4              1370:      addiu   v1, 4
9D010490      4F18   ADDIU T8, T8, -4             1371:      addiu   t8, -4
9D010492  FFF7B418   BNE T8, ZERO, 0x9D010485     1372:      bnez    t8, 5b		    //skok, polozka pokracuje
9D010498      0C00   NOP                          1373:      nop
                                                  1374:      
                                                  1375:      //src[0]=0x0
9D01049A      E840   SW S0, 0(A0)                 1376:      sw	    zero, (a0)
                                                  1377:      nop
9D01049C      CFE7   B 0x9D01046D                 1378:      b16	    2b
9D0104A0      0C00   NOP                          1379:      nop
                                                  1380:      
                                                  1381:      
                                                  1382:  .end defragTableW    
                                                  1383:      
                                                  1384:  //</editor-fold>
                                                  1385:  
                                                  1386:  //<editor-fold defaultstate="collapsed" desc="defragTableB">
                                                  1387:      
                                                  1388:  .align 2
                                                  1389:  .global defragTableB
                                                  1390:  .ent defragTableB
                                                  1391:  defragTableB:
                                                  1392:  //a0=adresa tabulky
                                                  1393:  //a1=item size [bytes] (delitelne 1)
                                                  1394:  //a2=max. pocet polozek, item cnt
                                                  1395:  //meni t7-t9, v0, v1, a0-a2    
                                                  1396:      
                                                  1397:      //tabulka musi obsahovat polozky word (velikost polozky min. 1 word, delitelna 4)
                                                  1398:      //posouva polozky v tabulce tak, aby mezi nimi nebyly neplatne polozky
                                                  1399:      //tzn. prvni nulova polozka je konec tabulky
                                                  1400:      //polozka musi zacinat word, ktery urcuje jeji platnost. Hodnota 0x0 = polozka je neplatna, hodnota != 0x0, polozka je platna
                                                  1401:      
                                                  1402:      
                                                  1403:      //a0=src
                                                  1404:      //t7=dest
9D0104A4      0DE4   MOVE T7, A0                  1405:      move    t7, a0
                                                  1406:      
                                                  1407:  1:
9D0104A6  00001724   LBU T9, 0(A0)                1408:      lbu	    t9, (a0)		    //load src data
9D0104AA  00079419   BEQ T9, ZERO, 0x9D0104BD     1409:      beqz    t9, 3f		    //skok, src data=0
                                                  1410:      nop
                                                  1411:      
                                                  1412:      //src data neni 0
9D0104B0  000BB48F   BNE T7, A0, 0x9D0104CB       1413:      bne	    t7, a0, 4f		    //skok src != dest, bude presun
9D0104B6      0C00   NOP                          1414:      nop
                                                  1415:      
                                                  1416:      //src=dest, zadny presun
                                                  1417:  2:    
9D0104B8  795000AF   ADDU T7, T7, A1              1418:      addu    t7, a1		    //dest++
                                                  1419:      
                                                  1420:  3:
9D0104BC      0658   ADDU A0, A0, A1              1421:      addu    a0, a1		    //src++
9D0104BE      6F6E   ADDIU A2, A2, -1             1422:      addiu   a2, -1		    //item cnt--
9D0104C0      AF72   BNEZ A2, 0x9D0104A7          1423:      bne	    a2, zero, 1b	    //neni konec
9D0104C4      0C00   NOP                          1424:      nop
                                                  1425:      
                                                  1426:      //je konec, prosel vsechny polozky
9D0104C6      45BF   JRC RA                       1427:      jrc	    ra
9D0104C8      0C00   NOP                          1428:      nop
                                                  1429:      
                                                  1430:  4:
                                                  1431:      //presun dat ze src do dest
9D0104CA      0C44   MOVE V0, A0                  1432:      move    v0, a0		    //src
9D0104CC      0C6F   MOVE V1, T7                  1433:      move    v1, t7		    //dest
9D0104CE      0F05   MOVE T8, A1                  1434:      move    t8, a1		    //size bytes
                                                  1435:      
                                                  1436:  5:    
9D0104D0  00001722   LBU T9, 0(V0)                1437:      lbu	    t9, (v0)
9D0104D4  00001B23   SB T9, 0(V1)                 1438:      sb	    t9, (v1)
9D0104D8      6D20   ADDIU V0, V0, 1              1439:      addiu   v0, 1
9D0104DA      6DB0   ADDIU V1, V1, 1              1440:      addiu   v1, 1
9D0104DC      4F1E   ADDIU T8, T8, -1             1441:      addiu   t8, -1
9D0104DE  FFF7B418   BNE T8, ZERO, 0x9D0104D1     1442:      bnez    t8, 5b		    //skok, polozka pokracuje
9D0104E4      0C00   NOP                          1443:      nop
                                                  1444:      
                                                  1445:      //src[0]=0x0
9D0104E6      8840   SB S0, 0(A0)                 1446:      sb	    zero, (a0)
                                                  1447:      nop
9D0104E8      CFE7   B 0x9D0104B9                 1448:      b16	    2b
9D0104EC      0C00   NOP                          1449:      nop
                                                  1450:      
                                                  1451:      
                                                  1452:  .end defragTableB    
                                                  1453:      
                                                  1454:  //</editor-fold>    
                                                  1455:      
                                                  1456:  //<editor-fold defaultstate="collapsed" desc="cpyStr">
                                                  1457:  /*    
                                                  1458:  .align 2
                                                  1459:  .global cpyStr
                                                  1460:  .ent cpyStr
                                                  1461:  cpyStr:
                                                  1462:  //t0=src
                                                  1463:  //t1=dest
                                                  1464:  //t2=max size
                                                  1465:      
                                                  1466:  1:    
                                                  1467:      lbu	    t9, (t0)
                                                  1468:      sb	    t9, (t1)
                                                  1469:      beqz    t9, 2f		//skok, konec - nasel \0
                                                  1470:      nop
                                                  1471:      
                                                  1472:      addiu   t0, 1
                                                  1473:      addiu   t1, 1
                                                  1474:      addiu   t2, -1
                                                  1475:      bnez    t2, 1b
                                                  1476:      nop
                                                  1477:     
                                                  1478:  2:    
                                                  1479:      jrc	    ra
                                                  1480:      
                                                  1481:  .end cpyStr 
                                                  1482:  */ 
                                                  1483:  //</editor-fold>
                                                  1484:      
                                                  1485:  //<editor-fold defaultstate="collapsed" desc="memcpy32">
                                                  1486:  .align 2
                                                  1487:  .global memcpy32
                                                  1488:  .ent memcpy32
                                                  1489:  memcpy32:
                                                  1490:  //a0=src
                                                  1491:  //a1=dest
                                                  1492:  //a2=len
                                                  1493:      
                                                  1494:      //len musi byt delitelne 4
                                                  1495:      
9D0104F0      8F0C   BEQZ A2, 0x9D01050B          1496:      beqz    a2, 2f
9D0104F4      0C00   NOP                          1497:      nop
                                                  1498:      
                                                  1499:  1:    
9D0104F6  0000FF24   LW T9, 0(A0)                 1500:      lw	    t9, (a0)
9D0104FA  0000FB25   SW T9, 0(A1)                 1501:      sw	    t9, (a1)
9D0104FE      6E42   ADDIU A0, A0, 4              1502:      addiu   a0, 4
9D010500      6ED2   ADDIU A1, A1, 4              1503:      addiu   a1, 4
9D010502      4CD8   ADDIU A2, A2, -4             1504:      addiu   a2, -4
9D010504      AF78   BNEZ A2, 0x9D0104F7          1505:      bnez    a2, 1b
9D010508      0C00   NOP                          1506:      nop
                                                  1507:  2:    
9D01050A      45BF   JRC RA                       1508:      jrc	    ra
                                                  1509:      
                                                  1510:  .end memcpy32    
                                                  1511:      
                                                  1512:  //</editor-fold>
                                                  1513:  
                                                  1514:    
                                                  1515:      
                                                  1516:  //<editor-fold defaultstate="collapsed" desc="pwm_soft_timer">
                                                  1517:  #ifdef PWM_SOFT
                                                  1518:      
                                                  1519:  .align 2
                                                  1520:  .global pwm_soft_timer    
                                                  1521:  .ent pwm_soft_timer
                                                  1522:  pwm_soft_timer:
                                                  1523:  //je volano z timer1 interruptu, je-li definovano PWM_SOFT
                                                  1524:  //nastavuje vykon zmenou CCPxRB    
                                                  1525:  //pracuje podle dat v pwm_table
                                                  1526:  //byte[0]     timebase time step
                                                  1527:  //byte[1]     aktualni time value
                                                  1528:  //byte[2-3]   target value
                                                  1529:  //byte[4-7]   step 
                                                  1530:  //byte[8-11]  adresa fce pwm_soft_linear_down, pwm_soft_linear_up, ...
                                                  1531:  //byte[12-15] adresa CCPxRB registru - obsahuje value   
                                                  1532:  //byte[16-19] adresa pole dat pro jiny, nez linearni prubeh    
                                                  1533:      
                                                  1534:      la	    a0, pwm_table
                                                  1535:      move    t0, zero
                                                  1536:      addiu   t1, zero, CCP_PWM_COUNT		//pocet pwm (polozek v pwm_table)
                                                  1537:      
                                                  1538:  1://loop:    
                                                  1539:      lbu	    t7, 0(a0)				//load timebase (0=neplatna polozka)
                                                  1540:      beqz    t7, 4f				//skok, neplatna polozka
                                                  1541:      nop
                                                  1542:      
                                                  1543:      //tato polozka je platna
                                                  1544:      lbu	    t8, 1(a0)				//load time
                                                  1545:      addiu   t8, -1				//time --
                                                  1546:      bnez    t8, 2f//x0				//skok, jeste nenastal time
                                                  1547:      nop
                                                  1548:     
                                                  1549:      //time=0, provede dalsi krok pwm
                                                  1550:      sb	    t7, 1(a0)				//nastav novy time
                                                  1551:      lw	    t9, 8(a0)				//load fn
                                                  1552:      jr	    t9					//skok na fn linear_up, linear_down, ...
                                                  1553:  
                                                  1554:  2://x0:
                                                  1555:      //skok sem, pokud jeste nevyprsel time (t8=novy time)
                                                  1556:      sb	    t8, 1(a0)				//save time
                                                  1557:  3://x:
                                                  1558:      //skok sem, pokud pwm jeste nedosahl target
                                                  1559:      addiu   t0, 1
                                                  1560:      
                                                  1561:  4://next:    
                                                  1562:      //skok sem, pokud pwm jiz dosahl target
                                                  1563:      addiu   t1, -1				//max_items --
                                                  1564:      addiu   a0, CCP_PWM_TABLE_ISIZE		//item ++
                                                  1565:      bnez    t1, 1b //loop			//skok, na dalsi polozku
                                                  1566:      nop
                                                  1567:      
                                                  1568:      //byla posledni polozka
                                                  1569:      bnez    t0, 5f//noclr_fn
                                                  1570:      nop
                                                  1571:      
                                                  1572:      //zadny pwm neni aktivni, zrusi volani fce z timer1
                                                  1573:      sw	    zero, (pwm_soft_fn)
                                                  1574:      
                                                  1575:  5://noclr_fn:
                                                  1576:      jrc	    ra
                                                  1577:      nop
                                                  1578:      
                                                  1579:      //<editor-fold defaultstate="collapsed" desc="pwm_soft_linear_down">
                                                  1580:  .global pwm_soft_linear_down   
                                                  1581:  pwm_soft_linear_down:
                                                  1582:      //a0=adresa polozky v tabulce
                                                  1583:      lw	    t8, 12(a0)		    //adresa value registru
                                                  1584:      lw	    t9, (t8)		    //load obsah value reg
                                                  1585:      lw	    t6, 4(a0)		    //load step
                                                  1586:      subu    t9, t6		    //nova value
                                                  1587:      
                                                  1588:      lhu	    t6, 2(a0)		    //load target value
                                                  1589:      subu    t5, t9, t6
                                                  1590:      bgtz    t5, 6f//e2		    //skok, val jeste neni target
                                                  1591:      nop
                                                  1592:      
                                                  1593:      //target je jiz dosazena
                                                  1594:      sw	    t6, (t8)		    //save reg=target
                                                  1595:      sw	    zero, 0(a0)		    //timebase=0, zneplatni polozku
                                                  1596:      nop
                                                  1597:      b16	    4b//next
                                                  1598:      nop
                                                  1599:      
                                                  1600:  6://e2:    
                                                  1601:      //valu jeste neni target
                                                  1602:      sw	    t9, (t8)		    //save value do CCP reg
                                                  1603:      nop
                                                  1604:      b16	    3b//x
                                                  1605:      nop 
                                                  1606:      //</editor-fold>
                                                  1607:      
                                                  1608:      //<editor-fold defaultstate="collapsed" desc="pwm_soft_linear_up">
                                                  1609:  .global pwm_soft_linear_up    
                                                  1610:  pwm_soft_linear_up:    
                                                  1611:      //a0=adresa polozky v tabulce
                                                  1612:      lw	    t8, 12(a0)		    //adresa value registru
                                                  1613:      lw	    t9, (t8)		    //load obsah value reg
                                                  1614:      lw	    t6, 4(a0)		    //load step
                                                  1615:      addu    t9, t6		    //nova value
                                                  1616:      
                                                  1617:      lhu	    t6, 2(a0)		    //load target value
                                                  1618:      subu    t5, t6, t9
                                                  1619:      bgtz    t5, 7f//e1		    //skok, val jeste neni target
                                                  1620:      nop
                                                  1621:    
                                                  1622:      //target je jiz dosazena
                                                  1623:      sw	    t6, (t8)		    //save reg=target
                                                  1624:      sw	    zero, 0(a0)		    //timebase=0, zneplatni polozku
                                                  1625:      nop
                                                  1626:      b16	    4b//next
                                                  1627:      nop
                                                  1628:      
                                                  1629:  7://e1:    
                                                  1630:      //valu jeste neni target
                                                  1631:      sw	    t9, (t8)		    //save value do reg
                                                  1632:      nop
                                                  1633:      b16	    3b//x
                                                  1634:      nop
                                                  1635:      //</editor-fold>
                                                  1636:  
                                                  1637:      //<editor-fold defaultstate="collapsed" desc="pwm_soft_exp">
                                                  1638:  .global pwm_soft_exp
                                                  1639:  pwm_soft_exp:
                                                  1640:      //a0=adresa polozky v pwm_table
                                                  1641:      lw	    t8, 12(a0)		    //adresa value registru
                                                  1642:      lbu	    t9, 2(a0)		    //target index
                                                  1643:      lbu	    t7, 4(a0)		    //akt. index
                                                  1644:      lb	    t6, 5(a0)		    //step (byte se znamenkem)
                                                  1645:      
                                                  1646:      add	    t7, t6		    //index + step (+1,-1,0)
                                                  1647:      sb	    t7, 4(a0)		    //save novy index
                                                  1648:      
                                                  1649:      lw	    t6, 16(a0)		    //adresa tabulky dat 
                                                  1650:      sll	    t5, t7, 1		    //akt. index x 2 (16-bit data)
                                                  1651:      addu    t6, t5		    //base + offset	
                                                  1652:      lhu	    t5, (t6)		    //load value data
                                                  1653:      sw	    t5, (t8)		    //save value do CCP reg
                                                  1654:      
                                                  1655:      bne	    t7, t9, 3b		    //skok, jeste neni target  
                                                  1656:      nop
                                                  1657:      
                                                  1658:      //akt. index= target index
                                                  1659:      sw	    zero, (a0)		    //zneplatni polozku
                                                  1660:      nop
                                                  1661:      b16	    4b//next
                                                  1662:      nop    
                                                  1663:      //</editor-fold>
                                                  1664:    
                                                  1665:  .end pwm_soft_timer
                                                  1666:      
                                                  1667:  #endif    
                                                  1668:  //</editor-fold>
                                                  1669:      
                                                  1670:  
                                                  1671:  //<editor-fold defaultstate="collapsed" desc="iVector11 timer1_interrupt">
                                                  1672:  .align 2    
                                                  1673:  .global iVector_timer1   
                                                  1674:  .ent iVector_timer1
                                                  1675:  iVector_timer1:
                                                  1676:      
                                                  1677:      //#define INTERVAL	10		//10ms
                                                  1678:      
9D01050C  800041A2   LUI V0, 0x8000               1679:      lw	    v0, (timer_ms)	    
9D010514  000A3042   ADDIU V0, V0, 10             1680:      addiu   v0, TIMER1_INTERVAL		//timer_ms += TIMER1_INTERVAL (10ms)
9D010518  800041A1   LUI AT, 0x8000               1681:      sw	    v0, (timer_ms)
                                                  1682:      
                                                  1683:  #ifdef RTC
9D010520  800041A2   LUI V0, 0x8000               1684:      lw	    v0, (day_ms)
9D010528  000A3042   ADDIU V0, V0, 10             1685:      addiu   v0, TIMER1_INTERVAL
9D01052C  800041A1   LUI AT, 0x8000               1686:      sw	    v0, (day_ms)
                                                  1687:  #endif    
                                                  1688:     
                                                  1689:  //word addr, word ms, word ms value    
9D010534  800041A2   LUI V0, 0x8000               1690:      la	    v0, timer1_events
9D01053C  00103060   ADDIU V1, ZERO, 16           1691:      addiu   v1, zero, TIMER1_EVENT_CAPA
9D010540      EE01   LI A0, 1                     1692:      li16    a0, 1
9D010542      0D00   MOVE T0, ZERO                1693:      move    t0, zero			//priznak, zda byla vyrazena udalost
                                                  1694:      	
                                                  1695:  1:    
9D010544  0000FF22   LW T9, 0(V0)                 1696:      lw	    t9, (v0)			//adresa promene, kterou nastavi na 1, pokud nastala udalost
9D010548  001C9419   BEQ T9, ZERO, 0x9D010585     1697:      beqz    t9, 4f			//skok, neplatna polozka, konec dat
9D01054E      0C00   NOP                          1698:      nop
                                                  1699:     
                                                  1700:      //platna polozka
9D010550  0008FF02   LW T8, 8(V0)                 1701:      lw	    t8, 8(v0)			//load aktualni value (citac)
9D010554  FFF63318   ADDIU T8, T8, -10            1702:      addiu   t8, -TIMER1_INTERVAL	//citac --
                                                  1703:      sw	    t8, 8(v0)			//save citac
9D010558  000F40D8   BGTZ T8, 0x9D01057B          1704:      bgtz    t8, 3f			//skok, neni 0, zadna udalost
9D010560      0C00   NOP                          1705:      nop
                                                  1706:      
                                                  1707:      //nastala udalost
9D010562  00001899   SB A0, 0(T9)                 1708:      sb	    a0, (t9)			//nastav status byte registrovane udalosti
9D010566  0004FF02   LW T8, 4(V0)                 1709:      lw	    t8, 4(v0)			//load default value (pokud je 0, neni udalost repeat)
9D01056A  0004B418   BNE T8, ZERO, 0x9D010577     1710:      bnez    t8, 2f			//skok, je repeat
9D010570      0C00   NOP                          1711:      nop
                                                  1712:      
                                                  1713:      //t8=0, udalost neni repeat, zrusit 
9D010572      E820   SW S0, 0(V0)                 1714:      sw	    zero, (v0)
9D010574      4D02   ADDIU T0, T0, 1              1715:      addiu   t0, 1			//nastav priznak zruseni event
                                                  1716:  
                                                  1717:  2:
                                                  1718:      //je repeat, t8=default value (provede i kdyz neni repeat, nevadi to)
9D010576  0008FB02   SW T8, 8(V0)                 1719:      sw	    t8, 8(v0)
                                                  1720:      
                                                  1721:  3:
                                                  1722:      //next
9D01057A      6D26   ADDIU V0, V0, 12             1723:      addiu   v0, TIMER1_EVENT_ISIZE	//dalsi polozka
9D01057C      6DBE   ADDIU V1, V1, -1             1724:      addiu   v1, -1			//items--
9D01057E      ADE2   BNEZ V1, 0x9D010545          1725:      bnez    v1, 1b			//loop
9D010582      0C00   NOP                          1726:      nop
                                                  1727:      
                                                  1728:  4:    
9D010584  000B9409   BEQ T1, ZERO, 0x9D01059F     1729:      beqz    t1, 5f			//skok, nebyla zrusena zadna udalost
9D01058A      0C00   NOP                          1730:      nop
                                                  1731:      //byla zrusena udalost (nebyla repeat), defrag. tabulku
9D01058C  800041A4   LUI A0, 0x8000               1732:      la	    a0, timer1_events
9D010594  000C30A0   ADDIU A1, ZERO, 12           1733:      addiu   a1, zero, TIMER1_EVENT_ISIZE
9D010598  001030C0   ADDIU A2, ZERO, 16           1734:      addiu   a2, zero, TIMER1_EVENT_CAPA
                                                  1735:      //a0=adresa tabulky, a1=velikost polozky, a2=max. pocet polozek (kapacita)
                                                  1736:      //bal	    defragTableW
9D01059C      0C00   NOP                          1737:      nop
                                                  1738:  
                                                  1739:  5:    
                                                  1740:      
                                                  1741:  #ifdef PWM_SOFT
                                                  1742:   
                                                  1743:      //skok do fce pro soft rizeni pwm, pouze pokud je adresa fce nastavena
                                                  1744:      
                                                  1745:      lw	    t9, (pwm_soft_fn)
                                                  1746:      beqz    t9, 6f
                                                  1747:      nop
                                                  1748:      jalr    t9
                                                  1749:      nop
                                                  1750:  6:    
                                                  1751:      
                                                  1752:  #endif    
                                                  1753:      
                                                  1754:      
                                                  1755:      //konec, nuluj flag IFS0.4
                                                  1756:  #ifdef PIC32MZ    
                                                  1757:      li16    v0, 0x10
                                                  1758:      sw      v0, (IFS0CLR)
                                                  1759:  #endif    
                                                  1760:     
                                                  1761:  #ifdef PIC32MM0064   
                                                  1762:      li	    v0, (1 << 11)
                                                  1763:      sw      v0, (IFS0CLR)
                                                  1764:  #endif     
                                                  1765:      
                                                  1766:  #ifdef PIC32MM0256   
9D01059E  000241A2   LUI V0, 0x2                  1767:      li	    v0, (1 << 17)
9D0105A2  BF8141A1   LUI AT, 0xBF81               1768:      sw      v0, (IFS0CLR)
                                                  1769:  #endif     
                                                  1770:      
                                                  1771:      
9D0105AA  F37C0000   ERET                         1772:      eret
9D0105AE      0C00   NOP                          1773:      nop
                                                  1774:    
                                                  1775:  .end iVector_timer1
                                                  1776:    
                                                  1777:  //</editor-fold>        
                                                  1778:    
                                                  1779:  //<editor-fold defaultstate="collapsed" desc="iVector_rtc RTC alarm">
                                                  1780:  
                                                  1781:  .align 2    
                                                  1782:  .global iVector_rtc   
                                                  1783:  .ent iVector_rtc
                                                  1784:  iVector_rtc:
                                                  1785:      //allarm jednou za minutu pri sec=00
                                                  1786:      
                                                  1787:      //nastav day_ms, podle aktualniho casu
9D0105B0      4650   MFLO S0                      1788:      mflo    s0			//uchova Lo
9D0105B2      4611   MFHI S1                      1789:      mfhi    s1			//uchova Hi
                                                  1790:      
9D0105B4  0D0E4060   BGEZAL ZERO, 0x9D011FD5      1791:      bal	    rtc_setDayMs	//meni HiLo
9D0105BC      0C00   NOP                          1792:      nop
                                                  1793:      
9D0105BE  2D7C0011   MTHI S1                      1794:      mthi    s1			//obnov Hi
9D0105C2  3D7C0010   MTLO S0                      1795:      mtlo    s0			//obnov Lo
                                                  1796:      
                                                  1797:      
9D0105C6  800041A2   LUI V0, 0x8000               1798:      lw	    v0, (minute_event);
9D0105CE      8D06   BEQZ V0, 0x9D0105DD          1799:      beqz    v0, 1f		//skok, neni zadna fce minute_event
9D0105D2      0C00   NOP                          1800:      nop
                                                  1801:      
9D0105D4      45C2   JALR16 V0                    1802:      jalr    v0
9D0105DA      0C00   NOP                          1803:      nop
                                                  1804:      
                                                  1805:  1:
                                                  1806:      
                                                  1807:  #ifdef PIC32MM0064    
                                                  1808:      li	    v0, (1 << 14)	//nuluj flag
                                                  1809:      sw	    v0, (IFS0CLR)
                                                  1810:  #endif
                                                  1811:      
                                                  1812:  #ifdef PIC32MM0256    
9D0105DC      ED01   LI V0, 1                     1813:      li	    v0, (1 << 0)	//nuluj flag
9D0105DE  BF8141A1   LUI AT, 0xBF81               1814:      sw	    v0, (IFS1CLR)
                                                  1815:  #endif    
                                                  1816:      
                                                  1817:      
9D0105E6  F37C0000   ERET                         1818:      eret
9D0105EA      0C00   NOP                          1819:      nop
                                                  1820:      
                                                  1821:  .end iVector_rtc
                                                  1822:      
                                                  1823:  //</editor-fold>
                                                  1824:      
                                                  1825:  //<editor-fold defaultstate="collapsed" desc="iVector15 ADC">
                                                  1826:      
                                                  1827:  .align 2    
                                                  1828:  .global iVector_adc  
                                                  1829:  .ent iVector_adc
                                                  1830:  iVector_adc:
                                                  1831:  //AD converter provadi pravidelnou kalibraci, nastavenim AD1CON2.OFFCAL bitu
                                                  1832:  //vstup AD (SHA) se tim pripoji na Vss, prevedena hodnota by mela byt 0,
                                                  1833:  //ale vetsinou je o neco vetsi. Tato hodnota je calibData, o kterou bude
                                                  1834:  //zmenseny vysledek AD prevodu, az do dalsi kalibrace 
                                                  1835:  //proto muze byt vysledek AD prevodu i zaporny    
                                                  1836:      
                                                  1837:      #define ADC_BUFFES_SPACE	0x10		    //offset jednotlivych buffer registru
                                                  1838:      #define ADC_CALIB_COUNTER	0b11111111111	    //hodnota pro kalibraci, jsou-li stejne bity v adc_counter nulove
                                                  1839:  
                                                  1840:      /*
                                                  1841:      //test, zda bude kalibrace
                                                  1842:      lw	    v0, (adc_counter)
                                                  1843:      andi    v0, ADC_CALIB_COUNTER	    //nuluje horni bity
                                                  1844:      bnez    v0, 2f			    //skok, neni kalibrace
                                                  1845:      nop
                                                  1846:      
                                                  1847:  
                                                  1848:      
                                                  1849:      //test, zda je prvni, nebo druhy krok kalibrace (v prvnim nastavi OFFCAL, v druhem cte data)
                                                  1850:      lw	    v0, (AD1CON2)
                                                  1851:      ext	    v1, v0, 12, 1
                                                  1852:      bnez    v1, 1f			    //skok, OFFCAL je jiz nastaveno
                                                  1853:      nop
                                                  1854:      
                                                  1855:      //dalsi AD converze bude kalibrace
                                                  1856:      addiu   v0, zero, (1 << 12)
                                                  1857:      sw	    v0, (AD1CON2SET)		    //nastav OFFCAL AD1CON2.b12
                                                  1858:      nop
                                                  1859:      b16	    5f				    //eret
                                                  1860:      nop
                                                  1861:      
                                                  1862:  1:
                                                  1863:      //aktualni AD konverze byla kalibracni
                                                  1864:      
                                                  1865:      addiu   v0, zero, (1 << 12)
                                                  1866:      //sw	    v0, (AD1CON2CLR)		    //nuluj OFFCAL  AD1CON2.b12
                                                  1867:      
                                                  1868:      lw	    v1, (ADC1BUF0)		    //kalibracni data
                                                  1869:      sw	    v1, (calibData)		    //ulozit kalibracni data
                                                  1870:      
                                                  1871:      //adc_counter++
                                                  1872:      lw	    v0, (adc_counter)
                                                  1873:      addiu   v0, 1
                                                  1874:      //sw	    v0, (adc_counter)
                                                  1875:      
                                                  1876:      nop
                                                  1877:      b16	    5f				    //eret
                                                  1878:      nop    
                                                  1879:      
                                                  1880:      
                                                  1881:  
                                                  1882:      
                                                  1883:  2:
                                                  1884:      //adc_counter++, v0=adc_counter
                                                  1885:      addiu   v0, 1
                                                  1886:      sw	    v0, (adc_counter)
                                                  1887:      */
                                                  1888:      
9D0105EC  BF8041A2   LUI V0, 0xBF80               1889:      la	    v0, (ADC1BUF0)
9D0105F4  800041A3   LUI V1, 0x8000               1890:      la	    v1, (adc_values)
9D0105FC  800041B8   LUI T8, 0x8000               1891:      lw	    t8, (calibData)
                                                  1892:      
                                                  1893:  #ifdef AN0   
                                                  1894:      lw	    t9, (v0)
                                                  1895:      sw	    t9, (v1)
                                                  1896:      addiu   v0, ADC_BUFFES_SPACE
                                                  1897:  #endif    
                                                  1898:      
                                                  1899:  #ifdef AN1    
                                                  1900:      lw	    t9, (v0)
                                                  1901:      sw	    t9, (1*4)(v1)
                                                  1902:      addiu   v0, ADC_BUFFES_SPACE
                                                  1903:  #endif        
                                                  1904:      
                                                  1905:  #ifdef AN2    
                                                  1906:      lw	    t9, (v0)
                                                  1907:      sw	    t9, (2*4)(v1)
                                                  1908:      addiu   v0, ADC_BUFFES_SPACE
                                                  1909:  #endif      
                                                  1910:      
                                                  1911:  #ifdef AN3    
                                                  1912:      lw	    t9, (v0)
                                                  1913:      sw	    t9, (3*4)(v1)
                                                  1914:      addiu   v0, ADC_BUFFES_SPACE
                                                  1915:  #endif     
                                                  1916:      
                                                  1917:  #ifdef AN4    
9D010604  0000FF22   LW T9, 0(V0)                 1918:      lw	    t9, (v0)
9D010608  0010FB23   SW T9, 16(V1)                1919:      sw	    t9, (4*4)(v1)
9D01060C      6D28   ADDIU V0, V0, 16             1920:      addiu   v0, ADC_BUFFES_SPACE
                                                  1921:  #endif     
                                                  1922:      
                                                  1923:  #ifdef AN5    
9D01060E  0000FF22   LW T9, 0(V0)                 1924:      lw	    t9, (v0)
9D010612  0014FB23   SW T9, 20(V1)                1925:      sw	    t9, (5*4)(v1)
9D010616      6D28   ADDIU V0, V0, 16             1926:      addiu   v0, ADC_BUFFES_SPACE
                                                  1927:  #endif     
                                                  1928:      
                                                  1929:  #ifdef AN6    
9D010618  0000FF22   LW T9, 0(V0)                 1930:      lw	    t9, (v0)
9D01061C  0018FB23   SW T9, 24(V1)                1931:      sw	    t9, (6*4)(v1)
9D010620      6D28   ADDIU V0, V0, 16             1932:      addiu   v0, ADC_BUFFES_SPACE
                                                  1933:  #endif     
                                                  1934:      
                                                  1935:  #ifdef AN7    
9D010622  0000FF22   LW T9, 0(V0)                 1936:      lw	    t9, (v0)
9D010626  001CFB23   SW T9, 28(V1)                1937:      sw	    t9, (7*4)(v1)
9D01062A      6D28   ADDIU V0, V0, 16             1938:      addiu   v0, ADC_BUFFES_SPACE
                                                  1939:  #endif     
                                                  1940:      
                                                  1941:  #ifdef AN8    
                                                  1942:      lw	    t9, (v0)
                                                  1943:      sw	    t9, (8*4)(v1)
                                                  1944:      addiu   v0, ADC_BUFFES_SPACE
                                                  1945:  #endif     
                                                  1946:      
                                                  1947:  #ifdef AN9    
                                                  1948:      lw	    t9, (v0)
                                                  1949:      sw	    t9, (9*4)(v1)
                                                  1950:      addiu   v0, ADC_BUFFES_SPACE
                                                  1951:  #endif     
                                                  1952:      
                                                  1953:  #ifdef AN10    
                                                  1954:      lw	    t9, (v0)
                                                  1955:      sw	    t9, (10*4)(v1)
                                                  1956:      addiu   v0, ADC_BUFFES_SPACE
                                                  1957:  #endif     
                                                  1958:      
                                                  1959:  #ifdef AN11    
                                                  1960:      lw	    t9, (v0)
                                                  1961:      sw	    t9, (11*4)(v1)
                                                  1962:      addiu   v0, ADC_BUFFES_SPACE
                                                  1963:  #endif     
                                                  1964:      
                                                  1965:  #ifdef AN12    
                                                  1966:      lw	    t9, (v0)
                                                  1967:      sw	    t9, (12*4)(v1)
                                                  1968:      addiu   v0, ADC_BUFFES_SPACE
                                                  1969:  #endif     
                                                  1970:      
                                                  1971:  #ifdef AN13    
                                                  1972:      lw	    t9, (v0)
                                                  1973:      sw	    t9, (13*4)(v1)
                                                  1974:      addiu   v0, ADC_BUFFES_SPACE
                                                  1975:  #endif  
                                                  1976:      
                                                  1977:  #ifdef AN14    
                                                  1978:      lw	    t9, (v0)
                                                  1979:      sw	    t9, (14*4)(v1)
                                                  1980:      addiu   v0, ADC_BUFFES_SPACE
                                                  1981:  #endif      
                                                  1982:      
                                                  1983:  #ifdef AN15    
                                                  1984:      lw	    t9, (v0)
                                                  1985:      sw	    t9, (15*4)(v1)
                                                  1986:      addiu   v0, ADC_BUFFES_SPACE
                                                  1987:  #endif  
                                                  1988:      
                                                  1989:  #ifdef AN16    
                                                  1990:      lw	    t9, (v0)
                                                  1991:      sw	    t9, (16*4)(v1)
                                                  1992:      addiu   v0, ADC_BUFFES_SPACE
                                                  1993:  #endif      
                                                  1994:      
                                                  1995:  #ifdef AN17    
                                                  1996:      lw	    t9, (v0)
                                                  1997:      sw	    t9, (17*4)(v1)
                                                  1998:      addiu   v0, ADC_BUFFES_SPACE
                                                  1999:  #endif      
                                                  2000:      
                                                  2001:  #ifdef AN18    
                                                  2002:      lw	    t9, (v0)
                                                  2003:      sw	    t9, (18*4)(v1)
                                                  2004:      addiu   v0, ADC_BUFFES_SPACE
                                                  2005:  #endif      
                                                  2006:      
                                                  2007:  #ifdef AN19    
                                                  2008:      lw	    t9, (v0)
                                                  2009:      sw	    t9, (19*4)(v1)
                                                  2010:      addiu   v0, ADC_BUFFES_SPACE
                                                  2011:  #endif      
                                                  2012:      
                                                  2013:  #ifdef ANVDDCORE
                                                  2014:      lw	    t9, (v0)
                                                  2015:      sw	    t9, (27*4)(v1)
                                                  2016:      addiu   v0, ADC_BUFFES_SPACE
                                                  2017:  #endif 
                                                  2018:      
                                                  2019:  #ifdef ANVBG
9D01062C  0000FF22   LW T9, 0(V0)                 2020:      lw	    t9, (v0)
9D010630  0070FB23   SW T9, 112(V1)               2021:      sw	    t9, (28*4)(v1)
9D010634      6D28   ADDIU V0, V0, 16             2022:      addiu   v0, ADC_BUFFES_SPACE
                                                  2023:  #endif    
                                                  2024:   
                                                  2025:  #ifdef ANVSS
                                                  2026:      lw	    t9, (v0)
                                                  2027:      sw	    t9, (29*4)(v1)
                                                  2028:      addiu   v0, ADC_BUFFES_SPACE
                                                  2029:  #endif      
                                                  2030:      
                                                  2031:  #ifdef ANVDD
                                                  2032:      lw	    t9, (v0)
                                                  2033:      sw	    t9, (30*4)(v1)
                                                  2034:      addiu   v0, ADC_BUFFES_SPACE
                                                  2035:  #endif  
                                                  2036:      
                                                  2037:  5:    
                                                  2038:      
                                                  2039:  #ifdef PIC32MM0064    
                                                  2040:      li	    v0, (1 << 15)	//nuluj flag
                                                  2041:      sw	    v0, (IFS0CLR)
                                                  2042:  #endif
                                                  2043:    
                                                  2044:  #ifdef PIC32MM0256    
9D010636      ED02   LI V0, 2                     2045:      li	    v0, (1 << 1)	//nuluj flag
9D010638  BF8141A1   LUI AT, 0xBF81               2046:      sw	    v0, (IFS1CLR)
                                                  2047:  #endif    
                                                  2048:      
                                                  2049:      
9D010640  F37C0000   ERET                         2050:      eret
9D010644      0C00   NOP                          2051:      nop
                                                  2052:      
                                                  2053:  .end iVector_adc 
                                                  2054:      
                                                  2055:  //</editor-fold>
                                                  2056:    
                                                  2057:  //<editor-fold defaultstate="collapsed" desc="iVector0 CPU Timer">
                                                  2058:  .align 2    
                                                  2059:  .global iVector0
                                                  2060:  .ent iVector0
                                                  2061:  iVector0:
                                                  2062:      
                                                  2063:      //aktualni proces trva prilis dlouho, neprovedl doEvents
                                                  2064:      nop
9D010648      CC87   B 0x9D010759                 2065:      b	    general_exception
9D01064C      0C00   NOP                          2066:      nop
                                                  2067:      
                                                  2068:  .end iVector0  
                                                  2069:      
                                                  2070:  //</editor-fold>
                                                  2071:    
                                                  2072:      
                                                  2073:  //<editor-fold defaultstate="collapsed" desc="Interrupt MM">         
                                                  2074:     
                                                  2075:  //<editor-fold defaultstate="collapsed" desc="setSrsValue">         
                                                  2076:  .align 2    
                                                  2077:  .global setSrsValue    
                                                  2078:  .ent setSrsValue 
                                                  2079:  setSrsValue:
                                                  2080:      
                                                  2081:      //nastavi SP a GP pro SRS1, ktery pouziva interrupt
                                                  2082:  
                                                  2083:      //nastav previous SRS=1
9D010650      ED01   LI V0, 1                     2084:      li	    v0, 0x1   
9D010652  10FC006C   MFC0 V1, SRSCtl              2085:      mfc0    v1, _CP0_SRSCTL
9D010656  498C0062   INS V1, V0, 6, 4             2086:      ins	    v1, v0, 6, 4
9D01065A  12FC006C   MTC0 V1, SRSCtl              2087:      mtc0    v1, _CP0_SRSCTL
9D01065E  18000000   EHB                          2088:      ehb
                                                  2089:      
                                                  2090:      //zapis gp
                                                  2091:      //la	    v0, (gp_value)
9D010662      6920   LW V0, 0(V0)                 2092:      lw	    v0, (v0)			    //k0=gp_value
9D010664  F17C0382   WRPGPR GP, V0                2093:      wrpgpr  gp, v0
                                                  2094:      
                                                  2095:      //zapis sp
                                                  2096:      //la	    v0, (sp_srs1_top)
9D010668      6920   LW V0, 0(V0)                 2097:      lw	    v0, (v0)			    //k0=adresa stacku
9D01066A  F17C03A2   WRPGPR SP, V0                2098:      wrpgpr  sp, v0
                                                  2099:      
9D01066E      45BF   JRC RA                       2100:      jrc	    ra
                                                  2101:      
                                                  2102:  .end setSrsValue    
                                                  2103:  //</editor-fold>   
                                                  2104:      
                                                  2105:  //<editor-fold defaultstate="collapsed" desc="setSrsValue2">         
                                                  2106:      
                                                  2107:  .align 2    
                                                  2108:  .global setSrsValue2    
                                                  2109:  .ent setSrsValue2 
                                                  2110:  setSrsValue2:
                                                  2111:      
                                                  2112:      /*
                                                  2113:  #ifdef PIC32MM    
                                                  2114:      //nastavi SP a GP pro SRS1, ktery pouziva interrupt
                                                  2115:      //GP kopiruje ze SRS[0]
                                                  2116:  
                                                  2117:      //nastav previous SRS=1
                                                  2118:      li16    v0, 0x1   
                                                  2119:      mfc0    v1, _CP0_SRSCTL
                                                  2120:      ins	    v1, v0, 6, 4
                                                  2121:      mtc0    v1, _CP0_SRSCTL
                                                  2122:      ehb
                                                  2123:      
                                                  2124:      //zapis gp
                                                  2125:      wrpgpr  gp, gp
                                                  2126:      
                                                  2127:      //zapis sp (dolni cast stack_area je vyhrazena pro zasobnik SRS[1])
                                                  2128:      la	    v0, stack_area
                                                  2129:      li	    v1, SRS_STACK_SIZE
                                                  2130:      addu    v0, v1
                                                  2131:      wrpgpr  sp, v0
                                                  2132:      
                                                  2133:  #endif  
                                                  2134:      
                                                  2135:      */
                                                  2136:      
                                                  2137:      //nastavi SP (a GP) pro SRS[1-7], zasobniky jsou vyhrazeny na adrese stack_area,
                                                  2138:      //velikost kazdeho je definovana SRS_STACK_SIZE (smerem nahoru)
                                                  2139:      //nasleduji zasobniky pro jednotlive procesy 
                                                  2140:      //celkova velikost oblasti pro zasobniky je v STACK_SIZE
                                                  2141:      
                                                  2142:      //zjisti pocet SRS 
9D010670  10FC004C   MFC0 V0, SRSCtl              2143:      mfc0    v0, _CP0_SRSCTL
9D010674  1EAC0042   EXT V0, V0, 26, 4            2144:      ext	    v0, v0, 26, 4		//Number of Shadow Set (MM=1, MZ=7)
                                                  2145:      
9D010678      0C60   MOVE V1, ZERO                2146:      move    v1, zero			//SRS index
9D01067A  800041B8   LUI T8, 0x8000               2147:      la	    t8, stack_area
9D010682  020031E0   ADDIU T7, ZERO, 512          2148:      li	    t7, SRS_STACK_SIZE
                                                  2149:  
                                                  2150:  1:    
9D010686      6DB0   ADDIU V1, V1, 1              2151:      addiu   v1, 1			//SRS index++
                                                  2152:      
                                                  2153:      //nastav previous SRS=v1
9D010688  10FC032C   MFC0 T9, SRSCtl              2154:      mfc0    t9, _CP0_SRSCTL
9D01068C  498C0323   INS T9, V1, 6, 4             2155:      ins	    t9, v1, 6, 4
9D010690  12FC032C   MTC0 T9, SRSCtl              2156:      mtc0    t9, _CP0_SRSCTL
9D010694  18000000   EHB                          2157:      ehb
                                                  2158:      
                                                  2159:      //zapis gp
9D010698  F17C039C   WRPGPR GP, GP                2160:      wrpgpr  gp, gp
                                                  2161:      
                                                  2162:      //zapis sp (dolni cast stack_area je vyhrazena pro zasobnik SRS[1])
9D01069C  C15001F8   ADDU T8, T8, T7              2163:      addu    t8, t7			//horni hranice stacku
                                                  2164:      wrpgpr  sp, t8
                                                  2165:      
9D0106A0  FFF1B443   BNE V1, V0, 0x9D010687       2166:      bne	    v1, v0, 1b			//skok, existuje dalsi SRS
9D0106A8      0C00   NOP                          2167:      nop
                                                  2168:      
                                                  2169:      //konec
9D0106AA      45BF   JRC RA                       2170:      jrc	    ra
                                                  2171:      
                                                  2172:  .end setSrsValue2
                                                  2173:      
                                                  2174:  //</editor-fold>     
                                                  2175:      
                                                  2176:      
                                                  2177:  //<editor-fold defaultstate="collapsed" desc="setInterrupt, enableInterrupt">
                                                  2178:  .align 2    
                                                  2179:  .global setInterrupt
                                                  2180:  .ent setInterrupt
                                                  2181:  setInterrupt:
                                                  2182:    
                                                  2183:      //Vector spacing=8, MVEC=1, prox. timer disable
9D0106AC  000141A2   LUI V0, 0x1                  2184:      li	    v0, 0x00011000
9D0106B4  BF8141A1   LUI AT, 0xBF81               2185:      sw	    v0, (INTCON)
                                                  2186:      
                                                  2187:      //b4-b31
                                                  2188:      //level 1(CPU timer)SRS0
                                                  2189:      //level 2-7 SRS1
                                                  2190:      //b0-b3 use SRS
9D0106BC  111141A2   LUI V0, 0x1111               2191:      li	    v0, 0x11111110
9D0106C4  BF8141A1   LUI AT, 0xBF81               2192:      sw	    v0, (PRISS)
                                                  2193:      
9D0106CC  1AFC004C   MTC0 V0, SRSMap              2194:      mtc0    v0, _CP0_SRSMAP
9D0106D0  18000000   EHB                          2195:      ehb
                                                  2196:      
9D0106D4      45BF   JRC RA                       2197:      jrc	    ra
                                                  2198:      
                                                  2199:  .end setInterrupt
                                                  2200:      
                                                  2201:  .align 2    
                                                  2202:  .global enableInterrupt
                                                  2203:  .ent enableInterrupt
                                                  2204:  enableInterrupt:
                                                  2205:      
                                                  2206:      //enable interrupt
9D0106D8  577C0000   EI ZERO                      2207:      ei
9D0106DC      45BF   JRC RA                       2208:      jrc	    ra
                                                  2209:      
                                                  2210:  .end enableInterrupt    
                                                  2211:      
                                                  2212:      
                                                  2213:  //</editor-fold>
                                                  2214:     
                                                  2215:  //<editor-fold defaultstate="collapsed" desc="interrupt vectors">
                                                  2216:      
                                                  2217:  //tabulka vektoru je pevne na adrese 0x9D00 0200, nezavisle na EBASE (na rozdil od dokumenatce)    
                                                  2218:  //compilator vlozi skok na fci obsluhy takto: extern void __attribute__((vector(21))) asm_fn_name();
                                                  2219:  //asm_fn muze volat c_fn, ale zpracovani musi koncit ERET (tzn. mimo telo c_fn)
                                                  2220:  //v prubehu zpracovani interruptu je STATUS.EXL=1, dalsi interrupty cekaji na dokonceni predchoziho   
                                                  2221:  //vsechny IPL pouzivaji SRS[1], kde je nastaven SP a GP (vsechny obsluhy pouzivaji stack[512] vyhrazeny pouze pro interrupt)
                                                  2222:      
                                                  2223:  #ifdef PIC32MM    
                                                  2224:      
                                                  2225:  //<editor-fold defaultstate="collapsed" desc="SPI1Tx">
                                                  2226:  .align 2    
                                                  2227:  .global iVector_spi1Tx
                                                  2228:  .ent iVector_spi1Tx 
                                                  2229:  iVector_spi1Tx:   
                                                  2230:  
                                                  2231:      //SPI Tx
                                                  2232:  #ifdef SPI1_INIT    
                                                  2233:      bal	    spi1_TxInterrupt
                                                  2234:      nop
                                                  2235:  #endif
                                                  2236:      
9D0106E0  F37C0000   ERET                         2237:      eret
9D0106E4      0C00   NOP                          2238:      nop
                                                  2239:      
                                                  2240:  .end iVector_spi1Tx
                                                  2241:      
                                                  2242:  //</editor-fold>
                                                  2243:  
                                                  2244:  //<editor-fold defaultstate="collapsed" desc="SPI2Tx">
                                                  2245:  .align 2    
                                                  2246:  .global iVector_spi2Tx
                                                  2247:  .ent iVector_spi2Tx 
                                                  2248:  iVector_spi2Tx:   
                                                  2249:  
                                                  2250:      //SPI Tx
                                                  2251:  #ifdef SPI2_INIT      
9D0106E8  F0AC4060   BGEZAL ZERO, 0x9D00E845      2252:      bal	    spi2_TxInterrupt
9D0106F0      0C00   NOP                          2253:      nop
                                                  2254:  #endif    
                                                  2255:      
9D0106F2  F37C0000   ERET                         2256:      eret
9D0106F6      0C00   NOP                          2257:      nop
                                                  2258:      
                                                  2259:  .end iVector_spi2Tx   
                                                  2260:      
                                                  2261:  //</editor-fold>
                                                  2262:  
                                                  2263:  //<editor-fold defaultstate="collapsed" desc="SPI3Tx">
                                                  2264:  .align 2    
                                                  2265:  .global iVector_spi3Tx
                                                  2266:  .ent iVector_spi3Tx 
                                                  2267:  iVector_spi3Tx:   
                                                  2268:  
                                                  2269:      //SPI Tx
                                                  2270:  #ifdef SPI3_INIT      
                                                  2271:      bal	    spi3_TxInterrupt
                                                  2272:      nop
                                                  2273:  #endif    
                                                  2274:      
9D0106F8  F37C0000   ERET                         2275:      eret
9D0106FC      0C00   NOP                          2276:      nop
                                                  2277:      
                                                  2278:  .end iVector_spi3Tx   
                                                  2279:      
                                                  2280:  //</editor-fold>    
                                                  2281:      
                                                  2282:  #endif 
                                                  2283:      
                                                  2284:  #ifdef PIC32MM0256		    //I2C ma pouze PIC32MM0256
                                                  2285:      
                                                  2286:  //<editor-fold defaultstate="collapsed" desc="I2C1Slave">
                                                  2287:  .align 2
                                                  2288:  .global iVector_i2c1Slave    
                                                  2289:  .ent iVector_i2c1Slave
                                                  2290:  iVector_i2c1Slave:
                                                  2291:      
                                                  2292:      //I2C1 Slave
                                                  2293:  #ifdef I2C1_USE    
                                                  2294:      bal	    i2c1_SlaveInterrupt
                                                  2295:      nop
                                                  2296:  #endif    
                                                  2297:      
9D010700  F37C0000   ERET                         2298:      eret
9D010704      0C00   NOP                          2299:      nop
                                                  2300:      
                                                  2301:  .end iVector_i2c1Slave
                                                  2302:      
                                                  2303:  //</editor-fold>    
                                                  2304:  //<editor-fold defaultstate="collapsed" desc="I2C1Master">
                                                  2305:  .align 2
                                                  2306:  .global iVector_i2c1Master    
                                                  2307:  .ent iVector_i2c1Master
                                                  2308:  iVector_i2c1Master:
                                                  2309:      
                                                  2310:      //I2C1 Master
                                                  2311:  #ifdef I2C1_USE    
                                                  2312:      bal	    i2c1_MasterInterrupt
                                                  2313:      nop
                                                  2314:  #endif    
                                                  2315:      
9D010708  F37C0000   ERET                         2316:      eret
9D01070C      0C00   NOP                          2317:      nop
                                                  2318:      
                                                  2319:  .end iVector_i2c1Master  
                                                  2320:      
                                                  2321:  //</editor-fold>
                                                  2322:  //<editor-fold defaultstate="collapsed" desc="I2C1Bus">
                                                  2323:  .align 2
                                                  2324:  .global iVector_i2c1Bus    
                                                  2325:  .ent iVector_i2c1Bus
                                                  2326:  iVector_i2c1Bus:
                                                  2327:      
                                                  2328:      //I2C1 Bus
                                                  2329:  #ifdef I2C1_USE    
                                                  2330:      bal	    i2c1_BusInterrupt
                                                  2331:      nop
                                                  2332:  #endif    
                                                  2333:      
9D010710  F37C0000   ERET                         2334:      eret
9D010714      0C00   NOP                          2335:      nop
                                                  2336:      
                                                  2337:  .end iVector_i2c1Bus 
                                                  2338:      
                                                  2339:  //</editor-fold>    
                                                  2340:      
                                                  2341:  //<editor-fold defaultstate="collapsed" desc="I2C2Slave">
                                                  2342:  .align 2
                                                  2343:  .global iVector_i2c2Slave    
                                                  2344:  .ent iVector_i2c2Slave
                                                  2345:  iVector_i2c2Slave:
                                                  2346:      
                                                  2347:      //I2C2 Slave
                                                  2348:  #ifdef I2C2_USE    
                                                  2349:      bal	    i2c2_SlaveInterrupt
                                                  2350:      nop
                                                  2351:  #endif    
                                                  2352:      
9D010718  F37C0000   ERET                         2353:      eret
9D01071C      0C00   NOP                          2354:      nop
                                                  2355:      
                                                  2356:  .end iVector_i2c2Slave
                                                  2357:      
                                                  2358:  //</editor-fold>
                                                  2359:  //<editor-fold defaultstate="collapsed" desc="I2C2Master">
                                                  2360:  .align 2
                                                  2361:  .global iVector_i2c2Master    
                                                  2362:  .ent iVector_i2c2Master
                                                  2363:  iVector_i2c2Master:
                                                  2364:      
                                                  2365:      //I2C2 Master
                                                  2366:  #ifdef I2C2_USE    
                                                  2367:      bal	    i2c2_MasterInterrupt
                                                  2368:      nop
                                                  2369:  #endif    
                                                  2370:      
9D010720  F37C0000   ERET                         2371:      eret
9D010724      0C00   NOP                          2372:      nop
                                                  2373:      
                                                  2374:  .end iVector_i2c2Master  //</editor-fold>
                                                  2375:  //<editor-fold defaultstate="collapsed" desc="I2C2Bus">
                                                  2376:  .align 2
                                                  2377:  .global iVector_i2c2Bus    
                                                  2378:  .ent iVector_i2c2Bus
                                                  2379:  iVector_i2c2Bus:
                                                  2380:      
                                                  2381:      //I2C2 Bus
                                                  2382:  #ifdef I2C2_USE    
                                                  2383:      bal	    i2c2_BusInterrupt
                                                  2384:      nop
                                                  2385:  #endif    
                                                  2386:      
9D010728  F37C0000   ERET                         2387:      eret
9D01072C      0C00   NOP                          2388:      nop
                                                  2389:      
                                                  2390:  .end iVector_i2c2Bus 
                                                  2391:      
                                                  2392:  //</editor-fold>
                                                  2393:    
                                                  2394:  //<editor-fold defaultstate="collapsed" desc="I2C3Slave">
                                                  2395:  .align 2
                                                  2396:  .global iVector_i2c3Slave    
                                                  2397:  .ent iVector_i2c3Slave
                                                  2398:  iVector_i2c3Slave:
                                                  2399:      
                                                  2400:      //I2C3 Slave
                                                  2401:  #ifdef I2C3_USE    
                                                  2402:      bal	    i2c3_SlaveInterrupt
                                                  2403:      nop
                                                  2404:  #endif    
                                                  2405:      
9D010730  F37C0000   ERET                         2406:      eret
9D010734      0C00   NOP                          2407:      nop
                                                  2408:      
                                                  2409:  .end iVector_i2c3Slave
                                                  2410:      
                                                  2411:  //</editor-fold>
                                                  2412:  //<editor-fold defaultstate="collapsed" desc="I2C3Master">
                                                  2413:  .align 2
                                                  2414:  .global iVector_i2c3Master    
                                                  2415:  .ent iVector_i2c3Master
                                                  2416:  iVector_i2c3Master:
                                                  2417:      
                                                  2418:      //I2C3 Master
                                                  2419:  #ifdef I2C3_USE    
                                                  2420:      bal	    i2c3_MasterInterrupt
                                                  2421:      nop
                                                  2422:  #endif    
                                                  2423:      
9D010738  F37C0000   ERET                         2424:      eret
9D01073C      0C00   NOP                          2425:      nop
                                                  2426:      
                                                  2427:  .end iVector_i2c3Master  //</editor-fold>
                                                  2428:  //<editor-fold defaultstate="collapsed" desc="I2C3Bus">
                                                  2429:  .align 2
                                                  2430:  .global iVector_i2c3Bus    
                                                  2431:  .ent iVector_i2c3Bus
                                                  2432:  iVector_i2c3Bus:
                                                  2433:      
                                                  2434:      //I2C3 Bus
                                                  2435:  #ifdef I2C3_USE    
                                                  2436:      bal	    i2c3_BusInterrupt
                                                  2437:      nop
                                                  2438:  #endif    
                                                  2439:      
9D010740  F37C0000   ERET                         2440:      eret
9D010744      0C00   NOP                          2441:      nop
                                                  2442:      
                                                  2443:  .end iVector_i2c3Bus 
                                                  2444:      
                                                  2445:  //</editor-fold>  
                                                  2446:      
                                                  2447:      
                                                  2448:  //<editor-fold defaultstate="collapsed" desc="USB">
                                                  2449:  .align 2
                                                  2450:  .global iVector_usb    
                                                  2451:  .ent iVector_usb
                                                  2452:  iVector_usb:
                                                  2453:      
                                                  2454:  #ifdef USB_DEVICE_INIT    
9D010748  F8184060   BGEZAL ZERO, 0x9D00F77D      2455:      bal	    usbDevice_interrupt
9D010750      0C00   NOP                          2456:      nop
                                                  2457:  #endif    
                                                  2458:      
9D010752  F37C0000   ERET                         2459:      eret
9D010756      0C00   NOP                          2460:      nop
                                                  2461:      
                                                  2462:  .end iVector_usb  
                                                  2463:  //</editor-fold>
                                                  2464:    
                                                  2465:      
                                                  2466:  #endif     
                                                  2467:      
                                                  2468:  //</editor-fold>
                                                  2469:     
                                                  2470:      
                                                  2471:  //<editor-fold defaultstate="collapsed" desc="cpuTimer_init">
                                                  2472:  .align 2
                                                  2473:  .global cpuTimer_init
                                                  2474:  .ent cpuTimer_init
                                                  2475:  cpuTimer_init:
                                                  2476:      
                                                  2477:      //4/2/2018 zruseno, misto toho fce v main.c
                                                  2478:      
                                                  2479:      /*
                                                  2480:      //COUNT=0, COMPARE=0xFFFFFFFF
                                                  2481:      li	    v0, 0xFFFFFFFF
                                                  2482:      mtc0    v0, _CP0_COMPARE
                                                  2483:      ehb
                                                  2484:      mtc0    zero, _CP0_COUNT
                                                  2485:      ehb
                                                  2486:  
                                                  2487:      //Priority 1, Subpriority 0
                                                  2488:      lw	    v0, (IPC0)
                                                  2489:      ori	    v0, 0b00100			//IPC0.PRI=1, IPC0.SUB=0
                                                  2490:      sw	    v0, (IPC0)
                                                  2491:      
                                                  2492:      //Enable=1
                                                  2493:      li16    v0, 1
                                                  2494:      sw	    v0, (IEC0SET)		//IEC0.b0 = 1, enable
                                                  2495:      
                                                  2496:      //Flag=0
                                                  2497:      sw	    v0, (IFS0CLR)		//IFS0.b0 = 0, nuluj flag
                                                  2498:      
                                                  2499:      jrc	    ra
                                                  2500:      */
                                                  2501:     
                                                  2502:  .end cpuTimer_init
                                                  2503:      
                                                  2504:  //</editor-fold>
                                                  2505:      
                                                  2506:  //<editor-fold defaultstate="collapsed" desc="general_exception">
                                                  2507:  .align 2    
                                                  2508:  .global _general_exception_handler    
                                                  2509:  .ent _general_exception_handler    
                                                  2510:  _general_exception_handler:    
                                                  2511:      
                                                  2512:  .global general_exception
                                                  2513:  general_exception:
                                                  2514:   
                                                  2515:      
                                                  2516:  #ifdef ENABLE_APP_RESTART_ON_ERROR    
                                                  2517:      
                                                  2518:      //provede nove spusteni procesu (v dalsim loop)
9D010758  800041BB   LUI K1, 0x8000               2519:      la	    k1, proc_t_pos	    //zde je ulozena akt. pozice v proc_t
9D010760  0000FF5B   LW K0, 0(K1)                 2520:      lw	    k0, (k1)		    //process table
                                                  2521:      
9D010764  1004205A   LWP V0, 4(K0)                2522:      lwp	    v0, TH_T_START_ADDR*4(k0)
9D010768      0FE2   MOVE RA, V0                  2523:      move    ra, v0
9D01076A      0FA3   MOVE SP, V1                  2524:      move    sp, v1
                                                  2525:      
9D01076C  9D0141A2   LUI V0, 0x9D01               2526:      la	    v0, doEvents
9D010774  02FC004E   MTC0 V0, EPC                 2527:      mtc0    v0, _CP0_EPC
9D010778  18000000   EHB                          2528:      ehb
                                                  2529:      
9D01077C  F37C0000   ERET                         2530:      eret
9D010780      0C00   NOP                          2531:      nop
                                                  2532:      
                                                  2533:  #else
                                                  2534:  
                                                  2535:  1:
                                                  2536:      //stop
                                                  2537:      li	t9, 0x1
                                                  2538:      li	t8, 0x2
                                                  2539:      
                                                  2540:      nop
                                                  2541:      b16	    1b
                                                  2542:      nop
                                                  2543:      
                                                  2544:  #endif    
                                                  2545:     
                                                  2546:  .end _general_exception_handler  
                                                  2547:      
                                                  2548:  //</editor-fold>
                                                  2549:   
                                                  2550:     
---  D:/bos/bos/disp16_asm.S  ---------------------------------------------------------------------------
                                                  1:     #include "xc.h"
                                                  2:     #include "def.h"  
                                                  3:     #include "asm_macro.S"
                                                  4:        
                                                  5:     
                                                  6:     //.set mips32    
                                                  7:     #define MICROMIPS  
                                                  8:     .set micromips     
                                                  9:     .section .asm_fn, code    
                                                  10:    
                                                  11:    //pausa pri directWrite do SPI hw bufferu (zavisi na rychlosti CPU, zapis bytes musi byt pomalejsi, nez vysilani SPI)
                                                  12:    #define SPI_DIRECT_WAIT_STATE	2	    //plati pro PIC32MM, 24MHz, rychlejsi CPU by mely mit delsi pauzu
                                                  13:        
                                                  14:    //<editor-fold defaultstate="collapsed" desc="IMAGE_SRC definition">
                                                  15:        //datova struktura pro IMAGE a FONT
                                                  16:    #define	    _FILEID_OFF		    0
                                                  17:    #define	    _FORMAT_OFF		    1
                                                  18:    #define	    _BLOCKSIZE_OFF	    2
                                                  19:    #define	    _COMPRESSION_OFF	    3
                                                  20:    #define	    _WIDTH_OFF		    4
                                                  21:    #define	    _HEIGHT_OFF		    6
                                                  22:        
                                                  23:        //save s0-s3
                                                  24:    #define	    _RLECNT_OFF		    8
                                                  25:    #define	    _RLEDATA_OFF	    12
                                                  26:    #define	    _SRCPOSITION_OFF	    16    
                                                  27:    #define	    _SRCWORD_OFF	    20    
                                                  28:        //load s0-s7
                                                  29:    #define	    _GETNEXTDATA_OFF	    24
                                                  30:    #define	    _GETPOINT_OFF	    28
                                                  31:    #define	    _POINTTOBUFFER_OFF	    32
                                                  32:    #define	    _ONSCREEN_OFF	    36
                                                  33:        
                                                  34:    #define	    _SRCSTARTPOSITION_OFF   40    
                                                  35:        //load 2xWord (colorMap, nebo foreColor+bgColor)
                                                  36:    #define	    _SRCAFTER_OFF	    44     
                                                  37:    #define	    _FORECOLOR_OFF	    48
                                                  38:    #define	    _BGCOLOR_OFF	    50
                                                  39:    
                                                  40:    #define	    _X_OFF		    52
                                                  41:    #define	    _Y_OFF		    54
                                                  42:        //load 2xWord
                                                  43:       
                                                  44:    #define	    _STARTX_OFF		    56
                                                  45:    #define	    _STARTY_OFF		    58
                                                  46:    #define	    _ENDX_OFF		    60
                                                  47:    #define	    _ENDY_OFF		    62
                                                  48:        
                                                  49:        //load 2xWord
                                                  50:    #define	    _FONTDATAADDR_OFF	    64
                                                  51:    #define	    _FONTITEMSIZE_OFF	    68   
                                                  52:    #define	    _FIRSTASCII_OFF	    70
                                                  53:    #define	    _FIRSTVAR_OFF	    71  
                                                  54:        
                                                  55:    #define	    _BITCNT_OFF		    72   
                                                  56:    #define	    _EOF_OFF		    73
                                                  57:        
                                                  58:    //</editor-fold>
                                                  59:       
                                                  60:    //<editor-fold defaultstate="collapsed" desc="IMAGE_HEAD, FONT_HEAD definition">
                                                  61:    	//IMAGE_HEAD offset polozek (hlavicka souboru Image)
                                                  62:    #define	    _HEAD_COLORMAPOFFSET_OFF	8
                                                  63:    #define	    _HEAD_COLORMAPSIZE_OFF	10
                                                  64:    #define	    _HEAD_DATASIZE_OFF		16
                                                  65:        
                                                  66:    	//FONT_HEAD offset polozek (hlavicka souboru Font)
                                                  67:    #define	    _HEAD_FONTITEMSIZE_OFF	8  
                                                  68:    #define	    _HEAD_FIRSTASCII_OFF	10
                                                  69:    #define	    _HEAD_FIRSTVAR_OFF		11  
                                                  70:    	
                                                  71:    	//IMAGE_HEAD + FONT_HEAD offset
                                                  72:    #define	    _HEAD_DATAOFFSET_OFF	14
                                                  73:    
                                                  74:    //</editor-fold>
                                                  75:    	    
                                                  76:    tableOfgetNextData:
                                                  77:        .word   get_next_data_8
                                                  78:        .word   get_next_data_16
                                                  79:        .word   get_next_data_32
                                                  80:        .word   get_next_data_8rle
                                                  81:        .word   get_next_data_16rle
                                                  82:        .word   get_next_data_32rle  
                                                  83:        
                                                  84:    //<editor-fold defaultstate="collapsed" desc="setImageColorMap">
                                                  85:    .align 2
                                                  86:    .global setImageColorMap
                                                  87:    .ent setImageColorMap
                                                  88:    setImageColorMap:
                                                  89:    //a0=IMAGE_SRC
                                                  90:    //a1=colorMap
                                                  91:        
                                                  92:        //nastavuje jinou adresu colorMap (format 0x4)
                                                  93:        //colorMap=short[16] - 16x definice 16-bit barvy
                                                  94:        
9D00EAE0  0030F8A4   SW A1, 48(A0)                95:        sw32    a1, _FORECOLOR_OFF(a0)	//foreColor + bgColor tvori adresu colorMap
9D00EAE4      45BF   JRC RA                       96:        jrc	    ra
                                                  97:        
                                                  98:    .end setImageColorMap  
                                                  99:        
                                                  100:   //</editor-fold>
                                                  101:       
                                                  102:   //<editor-fold defaultstate="collapsed" desc="setImageSrc">
                                                  103:   .align 2
                                                  104:   .global setImageSrc    
                                                  105:   .ent setImageSrc
                                                  106:   setImageSrc:    
                                                  107:   //a0=adresa head
                                                  108:   //a1=adresa IMAGE_SRC   
                                                  109:       
                                                  110:       //nastavuje data z head: fileId, format, blockSize, compression, width, height
                                                  111:       //pokud je format=0x4, nastavi adresu colorMap, pokud existuje (offset i size > 0)
                                                  112:       //nastavuje adr. fci: getNextData, getPoint, pointToBuffer
                                                  113:       //nastavuje srcStartPosition, srcAfter, expSize, eof=1
                                                  114:    
                                                  115:       
9D00EAE8  10002304   LWP T8, 0(A0)                116:       lwp	    t8, (a0)		//id, format, blockSize, compression, width, height
9D00EAEC  90002305   SWP T8, 0(A1)                117:       swp	    t8, (a1)
                                                  118:       
                                                  119:       //srcStartPosition
9D00EAF0  000E3724   LHU T9, 14(A0)               120:       lhu	    t9, _HEAD_DATAOFFSET_OFF(a0)    //offset dat za head
9D00EAF4  C9500099   ADDU T9, T9, A0              121:       addu    t9, a0
9D00EAF8  0028FB25   SW T9, 40(A1)                122:       sw32    t9, _SRCSTARTPOSITION_OFF(a1)   //startPosition
                                                  123:       
                                                  124:       //srcAfter
9D00EAFC  0010FF04   LW T8, 16(A0)                125:       lw32    t8, _HEAD_DATASIZE_OFF(a0)	    //velikost dat
9D00EB00  C9500319   ADDU T9, T9, T8              126:       addu    t9, t8
9D00EB04  002CFB25   SW T9, 44(A1)                127:       sw32    t9, _SRCAFTER_OFF(a1)	    //dataAfter
                                                  128:       
                                                  129:       //<editor-fold defaultstate="collapsed" desc="format 0x1">
                                                  130:       //test format 0x1
9D00EB08  00011445   LBU V0, 1(A1)                131:       lbu32   v0, _FORMAT_OFF(a1)
9D00EB0C      ED81   LI V1, 1                     132:       li16    v1, 0x1
9D00EB0E  0011B462   BNE V0, V1, 0x9D00EB35       133:       bne	    v0, v1, 2f
9D00EB14      0C00   NOP                          134:       nop
                                                  135:       
                                                  136:       //format 0x1
9D00EB16  9D0141A3   LUI V1, 0x9D01               137:       la	    v1, point_to_buffer_01
9D00EB1E  0020F865   SW V1, 32(A1)                138:       sw32    v1, _POINTTOBUFFER_OFF(a1)		//pointToBuffer
9D00EB22  9D0141A3   LUI V1, 0x9D01               139:       la	    v1, get_next_point_01		    
9D00EB2A  001CF865   SW V1, 28(A1)                140:       sw32    v1, _GETPOINT_OFF(a1)		//getPoint
                                                  141:       
                                                  142:       //addiu   v1, zero, 16
                                                  143:       //sb	    v1, _EXPSIZE_OFF(a1)		//exp size
                                                  144:       
                                                  145:       nop
9D00EB2E      CC51   B 0x9D00EBD3                 146:       b16	    10f					//after_format
9D00EB32      0C00   NOP                          147:       nop
                                                  148:       
                                                  149:       //</editor-fold>
                                                  150:       
                                                  151:       //<editor-fold defaultstate="collapsed" desc="format 0x4">
                                                  152:   2:
                                                  153:       //test format 0x4, v0=format
9D00EB34      ED84   LI V1, 4                     154:       li16    v1, 0x4
9D00EB36  002AB462   BNE V0, V1, 0x9D00EB8F       155:       bne	    v0, v1, 7f
9D00EB3C      0C00   NOP                          156:       nop
                                                  157:       
                                                  158:       //format 0x4
9D00EB3E  9D0141A3   LUI V1, 0x9D01               159:       la	    v1, point_to_buffer_04
9D00EB46  0020F865   SW V1, 32(A1)                160:       sw32    v1, _POINTTOBUFFER_OFF(a1)		//pointToBuffer  
9D00EB4A  9D0141A3   LUI V1, 0x9D01               161:       la	    v1, get_next_point_04		    
9D00EB52  001CF865   SW V1, 28(A1)                162:       sw32    v1, _GETPOINT_OFF(a1)		//getPoint
                                                  163:       
                                                  164:       //addiu   v1, zero, 0x4
                                                  165:       //sb	    v1, _EXPSIZE_OFF(a1)		//exp size
                                                  166:       
                                                  167:       //nastav colorMap
9D00EB56  000A3724   LHU T9, 10(A0)               168:       lhu	    t9, _HEAD_COLORMAPSIZE_OFF(a0)
9D00EB5A  000F9419   BEQ T9, ZERO, 0x9D00EB7D     169:       beqz    t9, 5f				//skok, colorMap neexistuje (size=0)
9D00EB60      0C00   NOP                          170:       nop    
9D00EB62  00083724   LHU T9, 8(A0)                171:       lhu	    t9, _HEAD_COLORMAPOFFSET_OFF(a0)		//load offset
9D00EB66  00099419   BEQ T9, ZERO, 0x9D00EB7D     172:       beqz    t9, 5f				//skok, colorMap neexistuje (offset=0)
9D00EB6C      0C00   NOP                          173:       nop
                                                  174:       
                                                  175:       //colorMap existuje, t9=offset
9D00EB6E  C9500099   ADDU T9, T9, A0              176:       addu    t9, a0
9D00EB72  0030FB25   SW T9, 48(A1)                177:       sw32    t9, _FORECOLOR_OFF(a1)		//foreColor+bgColor tvori adresu colorMap
                                                  178:       
                                                  179:       nop
9D00EB76      CC2D   B 0x9D00EBD3                 180:       b16	    10f					//after_format
9D00EB7A      0C00   NOP                          181:       nop
                                                  182:       
                                                  183:   5: 
                                                  184:       //colorMap neexistuje, nastav std
9D00EB7C  9D0041B9   LUI T9, 0x9D00               185:       la	    t9, stdColorMap
9D00EB84  0030FB25   SW T9, 48(A1)                186:       sw32    t9, _FORECOLOR_OFF(a1)
                                                  187:       nop
9D00EB88      CC24   B 0x9D00EBD3                 188:       b16	    10f					//after_format
9D00EB8C      0C00   NOP                          189:       nop
                                                  190:       
                                                  191:       //</editor-fold>
                                                  192:       
                                                  193:       //<editor-fold defaultstate="collapsed" desc="format 0x55">
                                                  194:   7:  
                                                  195:      //test format 0x55, v0=format 
9D00EB8E  00553060   ADDIU V1, ZERO, 85           196:       addiu   v1, zero, 0x55
9D00EB92  0080B462   BNE V0, V1, 0x9D00EC97       197:       bne	    v0, v1, 99f				//skok, jiny format, chyba
9D00EB98      0C00   NOP                          198:       nop
                                                  199:      
                                                  200:       //format 0x55
9D00EB9A  9D0141A3   LUI V1, 0x9D01               201:       la	    v1, point_to_buffer_55
9D00EBA2  0020F865   SW V1, 32(A1)                202:       sw32    v1, _POINTTOBUFFER_OFF(a1)		//pointToBuffer  
                                                  203:       //addiu   v1, zero, 0x2
                                                  204:       //sb32    v1, _EXPSIZE_OFF(a1)		//exp size
                                                  205:       
                                                  206:       //getNexpPoint podle blockSize
9D00EBA6  00021445   LBU V0, 2(A1)                207:       lbu32   v0, _BLOCKSIZE_OFF(a1)
9D00EBAA      ED88   LI V1, 8                     208:       li16    v1, 0x8
9D00EBAC  000BB462   BNE V0, V1, 0x9D00EBC7       209:       bne	    v0, v1, 8f				//skok, blockSize=16/32
9D00EBB2      0C00   NOP                          210:       nop
                                                  211:       
                                                  212:       //blockSize 8
9D00EBB4  9D0141A3   LUI V1, 0x9D01               213:       la	    v1, get_next_point_55b		    
9D00EBBC  001CF865   SW V1, 28(A1)                214:       sw32    v1, _GETPOINT_OFF(a1)		//getPoint
                                                  215:       
                                                  216:       nop
9D00EBC0      CC08   B 0x9D00EBD3                 217:       b16	    10f					//after_format
9D00EBC4      0C00   NOP                          218:       nop
                                                  219:       
                                                  220:   8:
                                                  221:       //blockSize 16/32
9D00EBC6  9D0141A3   LUI V1, 0x9D01               222:       la	    v1, get_next_point_55a		    
9D00EBCE  001CF865   SW V1, 28(A1)                223:       sw32    v1, _GETPOINT_OFF(a1)		//getPoint
                                                  224:       
                                                  225:       //</editor-fold>
                                                  226:       
                                                  227:       //<editor-fold defaultstate="collapsed" desc="getNextData">
                                                  228:      
                                                  229:   10: //after_format: 
                                                  230:       
                                                  231:       //nastav getNextPoint, podle blockSize a RLE
9D00EBD2  00021465   LBU V1, 2(A1)                232:       lbu32   v1, _BLOCKSIZE_OFF(a1)			    //8/16/32
9D00EBD6  00031725   LBU T9, 3(A1)                233:       lbu32   t9, _COMPRESSION_OFF(a1)			    //0/1
9D00EBDA  0029B419   BNE T9, ZERO, 0x9D00EC31     234:       bnez    t9, 11f
9D00EBE0      0C00   NOP                          235:       nop
                                                  236:       
                                                  237:       //nema kopresi, v1=blockSize
                                                  238:       //reg, val, set_reg, set_result, branch (set and branch if equal - reg=val)
9D00EBE2  00083320   ADDIU T9, ZERO, 8            239:       _SET_B_IF_EQUI v1, 8, v0, 0, 12f			    //meni t9
9D00EBFA  00103320   ADDIU T9, ZERO, 16           240:       _SET_B_IF_EQUI v1, 16, v0, 1, 12f			    //meni t9
9D00EC12  00203320   ADDIU T9, ZERO, 32           241:       _SET_B_IF_EQUI v1, 32, v0, 2, 12f			    //meni t9		
                                                  242:       
                                                  243:       nop
9D00EC2A      CC35   B 0x9D00EC97                 244:       b16	    99f						    //jiny format
9D00EC2E      0C00   NOP                          245:       nop
                                                  246:       
                                                  247:   11:
                                                  248:       //ma kopresi, v1=blockSize  
                                                  249:       //reg, val, set_reg, set_result, branch (set and branch if equal - reg=val)
9D00EC30  00083320   ADDIU T9, ZERO, 8            250:       _SET_B_IF_EQUI v1, 8, v0, 3, 12f			    //meni t9
9D00EC48  00103320   ADDIU T9, ZERO, 16           251:       _SET_B_IF_EQUI v1, 16, v0, 4, 12f			    //meni t9
9D00EC60  00203320   ADDIU T9, ZERO, 32           252:       _SET_B_IF_EQUI v1, 32, v0, 5, 12f			    //meni t9
                                                  253:       
                                                  254:       nop
9D00EC78      CC0E   B 0x9D00EC97                 255:       b16	    99f						    //jiny format
9D00EC7C      0C00   NOP                          256:       nop
                                                  257:       
                                                  258:   12:    
                                                  259:       //v0=index fce 0-5
9D00EC7E  9D0141B9   LUI T9, 0x9D01               260:       la	    t9, tableOfgetNextData			    //tabulka fci
9D00EC86  C1180059   LWXS T8, V0(T9)              261:       lwxs    t8, v0(t9)					    //load adresu fce
9D00EC8A  0018FB05   SW T8, 24(A1)                262:       sw32    t8, _GETNEXTDATA_OFF(a1)			    //save adresu fce
                                                  263:       
                                                  264:       //</editor-fold>
                                                  265:   
                                                  266:       //eof=1
9D00EC8E      ED81   LI V1, 1                     267:       li16    v1, 1
9D00EC90  00491865   SB V1, 73(A1)                268:       sb32    v1, _EOF_OFF(a1)
                                                  269:       
9D00EC94      45BF   JRC RA                       270:       jrc	    ra
                                                  271:       
                                                  272:   99:
                                                  273:       //jiny format, nastavi adresu fce GETPOINT na eof, tzn. ze imageToBuffer nic neprovede
9D00EC96  9D0141A3   LUI V1, 0x9D01               274:       la	    v1, imageToBuffer_eof		    
9D00EC9E  001CF865   SW V1, 28(A1)                275:       sw32    v1, _GETPOINT_OFF(a1)		//getPoint = eof   
9D00ECA2      45BF   JRC RA                       276:       jrc	    ra
                                                  277:       
                                                  278:   .end setImageSrc    
                                                  279:       
                                                  280:   //</editor-fold>
                                                  281:     
                                                  282:   //<editor-fold defaultstate="collapsed" desc="fillRectDirect">
                                                  283:   .align 2
                                                  284:   .global fillRectDirect
                                                  285:   .ent fillRectDirect
                                                  286:   fillRectDirect:
                                                  287:   //a0=color
                                                  288:   //a1=pocet pixelu
                                                  289:   //a2=adresa hwBufferu (SPIxBUF)    
                                                  290:   
                                                  291:       
                                                  292:       //zapisuje barvu a0 na display, zadany pocet pixelu, zapisem primo do SPIBUF
                                                  293:       //do kazdeho bodu zapise a0, direct write data >> SPIBUF
                                                  294:   
9D00ECA4      ED02   LI V0, 2                     295:       li	    v0, SPI_DIRECT_WAIT_STATE
9D00ECA6      6DA0   ADDIU V1, V0, 1              296:       addiu   v1, v0, 1			//wait state +1
                                                  297:   1:    
                                                  298:       //li16    v1, 4
                                                  299:       //lw	    t9, (SPI2STAT)
                                                  300:       //ext	    t9, t9, 16, 5
                                                  301:       //subu    t9, v1
                                                  302:       //bgtz    t9, 1b
                                                  303:       //nop
                                                  304:       
                                                  305:       //wait state
                                                  306:   2:
9D00ECA8      6DBE   ADDIU V1, V1, -1             307:       addiu   v1, -1
9D00ECAA      ADFE   BNEZ V1, 0x9D00ECA9          308:       bnez    v1, 2b
9D00ECAE      0C00   NOP                          309:       nop
                                                  310:       
                                                  311:       
9D00ECB0      AA60   SH A0, 0(A2)                 312:       sh	    a0, (a2) //(SPI2BUF)	//zapis do hw bufferu
9D00ECB2      6EDE   ADDIU A1, A1, -1             313:       addiu   a1, -1			//count--
                                                  314:       addiu   v1, v0, 1			//wait state +1
9D00ECB4      AEF9   BNEZ A1, 0x9D00ECA9          315:       bnez    a1, 1b
9D00ECB8      0C00   NOP                          316:       nop
                                                  317:       
9D00ECBA      45BF   JRC RA                       318:       jrc	    ra
                                                  319:       
                                                  320:   .end fillRectDirect 
                                                  321:       
                                                  322:   //</editor-fold>
                                                  323:       
                                                  324:   //<editor-fold defaultstate="collapsed" desc="imageToBuffer">    
                                                  325:   .align 2
                                                  326:   .global	imageToBuffer
                                                  327:   .ent imageToBuffer
                                                  328:   imageToBuffer:
                                                  329:   //a0=IMAGE_SRC struct
                                                  330:   //a1=buffer
                                                  331:   //a2=buffer len
                                                  332:   //a3 0=prohozeni H a L bajtu barvy, pri 8-bit komunikaci, 1=neprovadi prohozeni barvy, 2=directWrite >> a1 (adresa SPIxBUF)
                                                  333:       
                                                  334:       //fce provadi presun dat definovanych IMAGE_SRC do bufferu
                                                  335:       //pokud dosahne konce dat, nastavi eof=1 (dalsi volani provede znovu inicializaci)
                                                  336:       //pokud zaplni buffer, ulozi aktualni pozici a v pristim volani pokracuje (eof=0)
                                                  337:       //vysledny pixel je 16-bit barva.
                                                  338:       //Pokud je v display.h definovano DISPLAY_BUS_8 prohodi H a L byte barvy (wsbh)
                                                  339:       //Pri 16-bit komunikaci (SPI, PMP) je barva ok.
                                                  340:       //format barvy b15-b0 RRRRRGGG-GGGBBBBB
                                                  341:       
9D00ECBC      4FEF   ADDIU SP, SP, -36            342:       _PUSH_S07RA
                                                  343:       
9D00ECC2  00491444   LBU V0, 73(A0)               344:       lbu32   v0, _EOF_OFF(a0)
9D00ECC6      8D20   BEQZ V0, 0x9D00ED09          345:       beqz    v0, 2f  //start			//skok, pokracovani
9D00ECCA      0C00   NOP                          346:       nop
                                                  347:       
                                                  348:       //<editor-fold defaultstate="collapsed" desc="init values">
                                                  349:       //eof=1, provede init values
                                                  350:       
9D00ECCC  0028FC44   LW V0, 40(A0)                351:       lw32    v0, _SRCSTARTPOSITION_OFF(a0)	//srcPosition=startPosition
9D00ECD0  0010F844   SW V0, 16(A0)                352:       sw32    v0, _SRCPOSITION_OFF(a0)
                                                  353:       
9D00ECD4  0008F804   SW ZERO, 8(A0)               354:       sw32    zero, _RLECNT_OFF(a0)		//nuluj rleCnt
9D00ECD8  00481804   SB ZERO, 72(A0)              355:       sb32    zero, _BITCNT_OFF(a0)		//nuluj bitCnt
9D00ECDC  0034F804   SW ZERO, 52(A0)              356:       sw32    zero, _X_OFF(a0)			//nuluj x+y
                                                  357:       
9D00ECE0  00383C44   LH V0, 56(A0)                358:       lh32    v0, _STARTX_OFF(a0)			//load signed hword
9D00ECE4      EDFF   LI V1, -1                    359:       li16    v1, -1
9D00ECE6  000B9462   BEQ V0, V1, 0x9D00ED01       360:       beq     v0, v1, 1f				//skok, zadne pixely mimo obraz
9D00ECEC      0C00   NOP                          361:       nop
                                                  362:       
                                                  363:       //nastav fci onScreen na test (cast pixelu mimo obraz)
9D00ECEE  9D0141A2   LUI V0, 0x9D01               364:       la	    v0, test_on_screen
9D00ECF6  0024F844   SW V0, 36(A0)                365:       sw32    v0, _ONSCREEN_OFF(a0)
                                                  366:       nop
9D00ECFA      CC06   B 0x9D00ED09                 367:       b16	    2f					//start
9D00ECFE      0C00   NOP                          368:       nop
                                                  369:       
                                                  370:   1:
                                                  371:       //nastav fci onScreen na pointToBuffer (zadne pixely mimo obraz), neprovadi test
9D00ED00  0020FC44   LW V0, 32(A0)                372:       lw32    v0, _POINTTOBUFFER_OFF(a0)
9D00ED04  0024F844   SW V0, 36(A0)                373:       sw32    v0, _ONSCREEN_OFF(a0)
                                                  374:       
                                                  375:       //</editor-fold>
                                                  376:   
                                                  377:       
                                                  378:   2:  //start   
                                                  379:       //vyber vystupni fci (s wsbh, bez swbh, directWrite)
9D00ED08  00034167   TGEIU A3, 0x3                380:       tgeiu   a3, 0x3			    //trap, pokud a3>=3 (mozne volby 0,1,2)
9D00ED0C  9D0141B9   LUI T9, 0x9D01               381:       la	    t9, 4f
9D00ED14  391800F9   LWXS A3, A3(T9)              382:       lwxs    a3, a3(t9)			    //a3=adresa vystupni fce
                                                  383:       
                                                  384:   3:    
                                                  385:       //load 8xWord
9D00ED18  50082104   LWM S0-S7, 8(A0)             386:       lwm32   s0-s7, _RLECNT_OFF(a0)
                                                  387:       //load data
9D00ED1C  102C2104   LWP T0, 44(A0)               388:       lwp32   t0, _SRCAFTER_OFF(a0)	    //srcAfter+color fore=b0-15, bg=b16-31
9D00ED20  10382184   LWP T4, 56(A0)               389:       lwp32   t4, _STARTX_OFF(a0)		    //startX t4 L, startY t4 H, endX t5 L, endY t5, H
9D00ED24  00343544   LHU T2, 52(A0)               390:       lhu32   t2, _X_OFF(a0)		    //x
9D00ED28  00363564   LHU T3, 54(A0)               391:       lhu32   t3, _Y_OFF(a0)		    //y
9D00ED2C  004815C4   LBU T6, 72(A0)               392:       lbu32   t6, _BITCNT_OFF(a0)
9D00ED30  00043464   LHU V1, 4(A0)                393:       lhu32   v1, _WIDTH_OFF(a0)
9D00ED34      ED00   LI V0, 0                     394:       li16    v0, 0			    //return size v bufferu
                                                  395:       
                                                  396:       //call getPoint
9D00ED36      45B5   JRC S5                       397:       jrc	    s5
                                                  398:       
                                                  399:   4:  //vystupni fce
                                                  400:       .word   11f //x_cont_wsbh
                                                  401:       .word   12f //x_cont
                                                  402:       .word   5f //direct
                                                  403:       
                                                  404:   5: //direct:  
                                                  405:       //directWrite (a1 obsahuje adresu SPIxBUF, kam zapisuje data)
9D00ED44  00003B05   SH T8, 0(A1)                 406:       sh	    t8, (a1)
                                                  407:       //pokracuje next_loop_move_point
                                                  408:       
                                                  409:   6://next_loop_move_point:
9D00ED48  000F96F6   BEQ S6, S7, 0x9D00ED6B       410:       beq	    s6, s7, 10f			    //skok, neprovadi move_point
9D00ED4E      0C00   NOP                          411:       nop
                                                  412:       
                                                  413:       //move point (x++, y++)
                                                  414:   7://move_point:
9D00ED50      4D42   ADDIU T2, T2, 1              415:       addiu   t2, 1			//x++
9D00ED52  000AB46A   BNE T2, V1, 0x9D00ED6B       416:       bne	    t2, v1, 10f			//skok, neni za x
9D00ED58      0C00   NOP                          417:       nop
                                                  418:       
                                                  419:       //konec radku, x=0, zvysit y
9D00ED5A      0D40   MOVE T2, ZERO                420:       move    t2, zero			//x=0
9D00ED5C  7C2C032D   EXT T9, T5, 16, 16           421:       ext	    t9, t5, 16, 16		//endY je v t5 H
9D00ED60  002D9579   BEQ T9, T3, 0x9D00EDBF       422:       beq	    t9, t3, imageToBuffer_eof   //skok, je na poslednim radku
9D00ED66      0C00   NOP                          423:       nop
                                                  424:       
                                                  425:       //neni na poslednim, posun Y
9D00ED68      4D62   ADDIU T3, T3, 1              426:       addiu   t3, 1			//y++
                                                  427:   
                                                  428:   10:
                                                  429:       //start dalsi pixel, call getPoint
9D00ED6A      45B5   JRC S5                       430:       jrc	    s5				    //getPoint
9D00ED6C      0C00   NOP                          431:       nop
                                                  432:       
                                                  433:       
                                                  434:       //<editor-fold defaultstate="collapsed" desc="pointToBuffer">
                                                  435:       
                                                  436:   point_to_buffer_55:
                                                  437:       //t7 obsahuje primo barvu pixelu
9D00ED6E      0F0F   MOVE T8, T7                  438:       move    t8, t7
                                                  439:       
9D00ED70      45A7   JRC A3                       440:       jrc	    a3				//skok na vystupni fci
                                                  441:   
                                                  442:   point_to_buffer_04:
                                                  443:       //t7.b0-3=pixdata
9D00ED72  080001EF   SLL T7, T7, 1                444:       sll	    t7, 1			    //x 2
9D00ED76  7950012F   ADDU T7, T7, T1              445:       addu    t7, t1			    //t1=colorMap (+ color)
9D00ED7A  0000370F   LHU T8, 0(T7)                446:       lhu	    t8, (t7)
                                                  447:       
9D00ED7E      45A7   JRC A3                       448:       jrc	    a3				    //skok na vystupni fci
                                                  449:       
                                                  450:   point_to_buffer_01:
                                                  451:       //t7.b0=pixdata
9D00ED80  782C0309   EXT T8, T1, 0, 16            452:       ext	    t8, t1, 0, 16		    //foreColor
9D00ED84  7C2C0329   EXT T9, T1, 16, 16           453:       ext	    t9, t1, 16, 16		    //bgColor
9D00ED88  C05801F9   MOVZ T8, T9, T7              454:       movz    t8, t9, t7			    //do t8 bgColor, pokud t7=0        
                                                  455:       
9D00ED8C      45A7   JRC A3                       456:       jrc	    a3				    //skok na vystupni fci
                                                  457:       
                                                  458:   11: //x_cont_wsbh:  
                                                  459:       //t8=vysledna barva, ale bude upravena na 8-bit tx
9D00ED8E  7B3C0318   WSBH T8, T8                  460:       wsbh    t8
                                                  461:       
                                                  462:   12: //x_cont:
                                                  463:       //t8=vysledna barva, write to buffer
9D00ED92  00003B05   SH T8, 0(A1)                 464:       sh	    t8, (a1)			    //color > buffer
                                                  465:     
9D00ED96      4CA4   ADDIU A1, A1, 2              466:       addiu   a1, 2			    //buffer++
9D00ED98      4C44   ADDIU V0, V0, 2              467:       addiu   v0, 2			    //return len ++
9D00ED9A  FFD5B4C2   BNE V0, A2, 0x9D00ED49       468:       bne	    v0, a2, 6b //next_loop_move_point    //skok, buffer neni plny
9D00EDA0      0C00   NOP                          469:       nop
                                                  470:      
                                                  471:       //buffer je plny
                                                  472:     
                                                  473:       
                                                  474:       //</editor-fold>    
                                                  475:       
                                                  476:       //<editor-fold defaultstate="collapsed" desc="buffer full, EOF">
                                                  477:   13: //buffer_full:
                                                  478:       //buffer je plny, ale neni konec dat, save data, (eof=0), v0=pocet bytes v bufferu
                                                  479:       
                                                  480:       //save
9D00EDA2  D0082084   SWM S0-S3, 8(A0)             481:       swm32   s0-s3, _RLECNT_OFF(a0)
9D00EDA6  00343944   SH T2, 52(A0)                482:       sh32    t2, _X_OFF(a0)
9D00EDAA  00363964   SH T3, 54(A0)                483:       sh32    t3, _Y_OFF(a0)
9D00EDAE  004819C4   SB T6, 72(A0)                484:       sb32    t6, _BITCNT_OFF(a0)
                                                  485:       
9D00EDB2  00491804   SB ZERO, 73(A0)              486:       sb32    zero, _EOF_OFF(a0)			//eof=0
                                                  487:       
9D00EDB6  5000231D   LWM S0-S7, RA, 0(SP)         488:       _POP_S07RA
9D00EDBC      45BF   JRC RA                       489:       jrc	    ra
                                                  490:       
                                                  491:   imageToBuffer_eof: //is_eof:   
                                                  492:       //je konec dat, nastav eof=1, v0=pocet bytes v bufferu
9D00EDBE      ED81   LI V1, 1                     493:       li16    v1, 1
9D00EDC0  00491864   SB V1, 73(A0)                494:       sb32    v1, _EOF_OFF(a0)
                                                  495:       
9D00EDC4  5000231D   LWM S0-S7, RA, 0(SP)         496:       _POP_S07RA
9D00EDCA      45BF   JRC RA                       497:       jrc	    ra 
                                                  498:       
                                                  499:       //</editor-fold>    
                                                  500:       
                                                  501:       //<editor-fold defaultstate="collapsed" desc="test on screen">
                                                  502:   test_on_screen:
                                                  503:       //startX
9D00EDCC  782C032C   EXT T9, T4, 0, 16            504:       ext	    t9, t4, 0, 16		    //startX do t9
9D00EDD0  C9D0032A   SUBU T9, T2, T9              505:       subu    t9, t2, t9
9D00EDD4  FFBC4019   BLTZ T9, 0x9D00ED51          506:       bltz    t9, 7b //move_point		    //skok, bod je mimo obraz
9D00EDDA      0C00   NOP                          507:       nop
                                                  508:       
                                                  509:       //startY
9D00EDDC  7C2C032C   EXT T9, T4, 16, 16           510:       ext	    t9, t4, 16, 16
9D00EDE0  C9D0032B   SUBU T9, T3, T9              511:       subu    t9, t3, t9
9D00EDE4  FFB44019   BLTZ T9, 0x9D00ED51          512:       bltz    t9, 7b //move_point		    //skok, bod je mimo obraz
9D00EDEA      0C00   NOP                          513:       nop
                                                  514:       
                                                  515:       //exdX
9D00EDEC  782C032D   EXT T9, T5, 0, 16            516:       ext	    t9, t5, 0, 16
9D00EDF0  C9D0032A   SUBU T9, T2, T9              517:       subu    t9, t2, t9
9D00EDF4  FFAC40D9   BGTZ T9, 0x9D00ED51          518:       bgtz    t9, 7b //move_point		    //skok, bod je mimo obraz
9D00EDFA      0C00   NOP                          519:       nop
                                                  520:       
                                                  521:       //endY
9D00EDFC  7C2C032D   EXT T9, T5, 16, 16           522:       ext	    t9, t5, 16, 16
9D00EE00  C9D0032B   SUBU T9, T3, T9              523:       subu    t9, t3, t9
9D00EE04  FFA440D9   BGTZ T9, 0x9D00ED51          524:       bgtz    t9, 7b //move_point		    //skok, bod je mimo obraz
9D00EE0A      0C00   NOP                          525:       nop
                                                  526:       
                                                  527:       //neni mimo obrazovku
9D00EE0C      45B6   JRC S6                       528:       jrc	    s6				    //pointToBuffer01/04/55
                                                  529:       
                                                  530:       //</editor-fold>
                                                  531:    
                                                  532:       //<editor-fold defaultstate="collapsed" desc="getNextPoint">
                                                  533:   get_next_point_01:
                                                  534:       //t6=bitCnt, s3=srcWord
9D00EE0E  0008B40E   BNE T6, ZERO, 0x9D00EE23     535:       bnez    t6, 1f			    //skok, srcWord obsahuje data
9D00EE14      0C00   NOP                          536:       nop
                                                  537:     
                                                  538:       //load data
9D00EE16      45D4   JALR16 S4                    539:       jalr    s4				    //load pixdata (srcWord s3)
9D00EE1C      0C00   NOP                          540:       nop
9D00EE1E  000215C4   LBU T6, 2(A0)                541:       lbu32    t6, _BLOCKSIZE_OFF(a0)	    //bitCnt = blockSize
                                                  542:       
                                                  543:   1:    
9D00EE22      4DDE   ADDIU T6, T6, -1             544:       addiu   t6, -1			    //bitCnt--
9D00EE24  07EC01F3   EXT T7, S3, 31, 1            545:       ext	    t7, s3, 31, 1		    //t7(pixdata)=srcWord.b31
9D00EE28  08000273   SLL S3, S3, 1                546:       sll	    s3, 1			    //srcWord<<1
                                                  547:       
9D00EE2C      45B7   JRC S7                       548:       jrc	    s7				    //testOnScreen, nebo pointToBuffer01
9D00EE2E      0C00   NOP                          549:       nop
                                                  550:       
                                                  551:   get_next_point_04:
                                                  552:       //t6=bitCnt, s3=srcWord
9D00EE30  000AB40E   BNE T6, ZERO, 0x9D00EE49     553:       bnez    t6, 1f			    //skok, srcWord obsahuje data
9D00EE36      0C00   NOP                          554:       nop    
                                                  555:       
                                                  556:       //load data
9D00EE38      45D4   JALR16 S4                    557:       jalr    s4
9D00EE3E      0C00   NOP                          558:       nop
9D00EE40  000215C4   LBU T6, 2(A0)                559:       lbu32   t6, _BLOCKSIZE_OFF(a0)	    //bitCnt = blockSize
9D00EE44  104001CE   SRL T6, T6, 2                560:       srl	    t6, 2			    // /4
                                                  561:       
                                                  562:   1:
9D00EE48      4DDE   ADDIU T6, T6, -1             563:       addiu   t6, -1
9D00EE4A  1F2C01F3   EXT T7, S3, 28, 4            564:       ext	    t7, s3, 28, 4		    //t7(pixdata)=srcWord.b28-31
9D00EE4E  20000273   SLL S3, S3, 4                565:       sll	    s3, 4			    //srcWord<<4    
                                                  566:       
9D00EE52      45B7   JRC S7                       567:       jrc	    s7				    //testOnScreen, nebo pointToBuffer04
9D00EE54      0C00   NOP                          568:       nop
                                                  569:       
                                                  570:   get_next_point_55a: //format 0x55, blockSize 16/32
                                                  571:       //t6=bitCnt, s3=srcWord
9D00EE56  000AB40E   BNE T6, ZERO, 0x9D00EE6F     572:       bnez    t6, 1f			    //skok, srcWord obsahuje data
9D00EE5C      0C00   NOP                          573:       nop   
                                                  574:       
                                                  575:       //load data
9D00EE5E      45D4   JALR16 S4                    576:       jalr    s4
9D00EE64      0C00   NOP                          577:       nop
                                                  578:       //wsbh    s3, s3			    //prohodit B0 s B1, a B3 s B2
9D00EE66  000215C4   LBU T6, 2(A0)                579:       lbu32   t6, _BLOCKSIZE_OFF(a0)	    //bitCnt = blockSize
9D00EE6A  204001CE   SRL T6, T6, 4                580:       srl	    t6, 4			    // /16    
                                                  581:       
                                                  582:   1:
9D00EE6E      4DDE   ADDIU T6, T6, -1             583:       addiu   t6, -1
9D00EE70  7C2C01F3   EXT T7, S3, 16, 16           584:       ext	    t7, s3, 16, 16		    //t7(pixdata)=srcWord.b16-31
9D00EE74  80000273   SLL S3, S3, 16               585:       sll	    s3, 16			    //srcWord<<16    
                                                  586:       
9D00EE78      45B7   JRC S7                       587:       jrc	    s7				    //testOnScreen, nebo pointToBuffer55
9D00EE7A      0C00   NOP                          588:       nop    
                                                  589:       
                                                  590:   get_next_point_55b: //format 0x55, blockSize 8
                                                  591:       
                                                  592:       //load data 8-bit
9D00EE7C      45D4   JALR16 S4                    593:       jalr    s4
9D00EE82      0C00   NOP                          594:       nop
                                                  595:       srl	    t7, s3, 16			    //s3(b24-31) > t7(8-15) 
                                                  596:       //ext	    t7, s3, 24, 8		    //t7(pixdata) b0-b7
                                                  597:       
9D00EE84      45D4   JALR16 S4                    598:       jalr    s4
9D00EE8A      0C00   NOP                          599:       nop
9D00EE8C  C0400273   SRL S3, S3, 24               600:       srl	    s3, 24			    //s3(24-31) > s3(0-7)
9D00EE90  7A90026F   OR T7, T7, S3                601:       or	    t7, s3
                                                  602:       //ext	    t9, s3, 24, 8		    //vyjmout b24-31
                                                  603:       //ins	    t7, t9, 8, 8		    //vlozit do pixdata.b8-15
                                                  604:       
9D00EE94      45B7   JRC S7                       605:       jrc	    s7
9D00EE96      0C00   NOP                          606:       nop
                                                  607:       
                                                  608:       //</editor-fold>
                                                  609:   
                                                  610:       //<editor-fold defaultstate="collapsed" desc="get_next_data_8, RLE">
                                                  611:       
                                                  612:   get_next_data_8:
                                                  613:       //s2=position, t0=after
9D00EE98  FF919512   BEQ S2, T0, 0x9D00EDBF       614:       beq	    s2, t0, imageToBuffer_eof	    //skok, je za daty
9D00EE9E      0C00   NOP                          615:       nop
                                                  616:       
9D00EEA0  00001672   LBU S3, 0(S2)                617:       lbu	    s3, (s2)			    //srcWord=data
9D00EEA4      4E42   ADDIU S2, S2, 1              618:       addiu   s2, 1			    //position++    
9D00EEA6  C0000273   SLL S3, S3, 24               619:       sll	    s3, 24			    //posun do b24-31
                                                  620:       
9D00EEAA      45BF   JRC RA                       621:       jrc	    ra
                                                  622:       
                                                  623:   get_next_data_8rle:
                                                  624:       //rleCnt=s0, rleData=s1
9D00EEAC  001A40D0   BGTZ S0, 0x9D00EEE5          625:       bgtz    s0, 3f			    //skok, rleCnt>0
                                                  626:       nop
                                                  627:       
9D00EEB2  000B4010   BLTZ S0, 0x9D00EECD          628:       bltz    s0, 1f			    //skok, rleCnt<0
                                                  629:       nop
                                                  630:       
                                                  631:       //rleCnt=0, load dalsi
                                                  632:       //s2=position, t0=after    
9D00EEB8  FF819512   BEQ S2, T0, 0x9D00EDBF       633:       beq	    s2, t0, imageToBuffer_eof	    //skok, je za daty
9D00EEBE      0C00   NOP                          634:       nop
                                                  635:       
                                                  636:       //dalsi rleCnt
9D00EEC0  00001E12   LB S0, 0(S2)                 637:       lb	    s0, (s2)			    //load rleCnt
                                                  638:       addiu   s2, 1			    //position++
9D00EEC4  000940D0   BGTZ S0, 0x9D00EEDB          639:       bgtz    s0, 2f			    //skok, rleCnt > 0
9D00EECA      0C00   NOP                          640:       nop
                                                  641:       
                                                  642:   1:    
9D00EECC  00001672   LBU S3, 0(S2)                643:       lbu	    s3, (s2)			    //load data
9D00EED0      4E42   ADDIU S2, S2, 1              644:       addiu   s2, 1			    //position ++
9D00EED2  C0000273   SLL S3, S3, 24               645:       sll	    s3, 24			    //posun do b24-31
9D00EED6      6C00   ADDIU S0, S0, 1              646:       addiu   s0, 1			    //rleCnt++
9D00EED8      45BF   JRC RA                       647:       jrc	    ra
                                                  648:       
                                                  649:   2:
                                                  650:       //load nove rleData
9D00EEDA  00001632   LBU S1, 0(S2)                651:       lbu	    s1, (s2)			    //load rleCnt
9D00EEDE      4E42   ADDIU S2, S2, 1              652:       addiu   s2, 1			    //position ++
9D00EEE0  C0000231   SLL S1, S1, 24               653:       sll	    s1, 24			    //posun do b24-31
                                                  654:       
                                                  655:   3:
                                                  656:       //rleCnt>0, dalsi rleData
9D00EEE4      0E71   MOVE S3, S1                  657:       move    s3, s1			    //srcWord < rleData
9D00EEE6      6C0E   ADDIU S0, S0, -1             658:       addiu   s0, -1			    //rleCnt--
9D00EEE8      45BF   JRC RA                       659:       jrc	    ra
                                                  660:       
                                                  661:       //</editor-fold>
                                                  662:       
                                                  663:       //<editor-fold defaultstate="collapsed" desc="get_next_data_16, RLE">
                                                  664:       
                                                  665:   get_next_data_16:
                                                  666:       //s2=position, t0=after
9D00EEEA  FF689512   BEQ S2, T0, 0x9D00EDBF       667:       beq	    s2, t0, imageToBuffer_eof	    //skok, je za daty
9D00EEF0      0C00   NOP                          668:       nop
                                                  669:       
9D00EEF2  00003672   LHU S3, 0(S2)                670:       lhu	    s3, (s2)			    //srcWord=data
9D00EEF6      4E44   ADDIU S2, S2, 2              671:       addiu   s2, 2			    //position++
9D00EEF8  80000273   SLL S3, S3, 16               672:       sll	    s3, 16			    //posun do b16-31
                                                  673:   
9D00EEFC      45BF   JRC RA                       674:       jrc	    ra   
                                                  675:       
                                                  676:   get_next_data_16rle:
                                                  677:       //rleCnt=s0, rleData=s1
9D00EEFE  001A40D0   BGTZ S0, 0x9D00EF37          678:       bgtz    s0, 3f			    //skok, rleCnt>0
                                                  679:       nop
                                                  680:       
9D00EF04  000B4010   BLTZ S0, 0x9D00EF1F          681:       bltz    s0, 1f			    //skok, rleCnt<0
                                                  682:       nop
                                                  683:       
                                                  684:       //rleCnt=0, load dalsi
                                                  685:       //s2=position, t0=after    
9D00EF0A  FF589512   BEQ S2, T0, 0x9D00EDBF       686:       beq	    s2, t0, imageToBuffer_eof	    //skok, je za daty
9D00EF10      0C00   NOP                          687:       nop
                                                  688:       
                                                  689:       //dalsi rleCnt
9D00EF12  00003E12   LH S0, 0(S2)                 690:       lh	    s0, (s2)			    //load rleCnt
                                                  691:       addiu   s2, 2			    //position++
9D00EF16  000940D0   BGTZ S0, 0x9D00EF2D          692:       bgtz    s0, 2f			    //skok, rleCnt > 0
9D00EF1C      0C00   NOP                          693:       nop
                                                  694:       
                                                  695:   1:    
9D00EF1E  00003672   LHU S3, 0(S2)                696:       lhu	    s3, (s2)			    //load data
9D00EF22      4E44   ADDIU S2, S2, 2              697:       addiu   s2, 2			    //position ++
9D00EF24  80000273   SLL S3, S3, 16               698:       sll	    s3, 16			    //posun do b16-31
9D00EF28      6C00   ADDIU S0, S0, 1              699:       addiu   s0, 1			    //rleCnt++
9D00EF2A      45BF   JRC RA                       700:       jrc	    ra
                                                  701:       
                                                  702:   2:
                                                  703:       //load nove rleData
9D00EF2C  00003632   LHU S1, 0(S2)                704:       lhu	    s1, (s2)			    //load rleCnt
9D00EF30      4E44   ADDIU S2, S2, 2              705:       addiu   s2, 2			    //position ++
9D00EF32  80000231   SLL S1, S1, 16               706:       sll	    s1, 16			    //posun do b16-31
                                                  707:       
                                                  708:   3:
                                                  709:       //rleCnt>0, dalsi rleData
9D00EF36      0E71   MOVE S3, S1                  710:       move    s3, s1			    //srcWord < rleData
9D00EF38      6C0E   ADDIU S0, S0, -1             711:       addiu   s0, -1			    //rleCnt--
9D00EF3A      45BF   JRC RA                       712:       jrc	    ra
                                                  713:       
                                                  714:       //</editor-fold>
                                                  715:       
                                                  716:       //<editor-fold defaultstate="collapsed" desc="get_next_data_32, RLE">
                                                  717:       
                                                  718:   get_next_data_32:
                                                  719:       //s2=position, t0=after
9D00EF3C  FF3F9512   BEQ S2, T0, 0x9D00EDBF       720:       beq	    s2, t0, imageToBuffer_eof	    //skok, je za daty
9D00EF42      0C00   NOP                          721:       nop
                                                  722:       
9D00EF44  0000FE72   LW S3, 0(S2)                 723:       lw32    s3, (s2)			    //srcWord=data
9D00EF48      4E48   ADDIU S2, S2, 4              724:       addiu   s2, 4			    //position++
                                                  725:   
9D00EF4A      45BF   JRC RA                       726:       jrc	    ra       
                                                  727:       
                                                  728:   get_next_data_32rle:    
                                                  729:       //rleCnt=s0, rleData=s1
9D00EF4C  001640D0   BGTZ S0, 0x9D00EF7D          730:       bgtz    s0, 3f			    //skok, rleCnt>0
                                                  731:       nop
                                                  732:       
9D00EF52  000B4010   BLTZ S0, 0x9D00EF6D          733:       bltz    s0, 1f			    //skok, rleCnt<0
                                                  734:       nop
                                                  735:       
                                                  736:       //rleCnt=0, load dalsi
                                                  737:       //s2=position, t0=after    
9D00EF58  FF319512   BEQ S2, T0, 0x9D00EDBF       738:       beq	    s2, t0, imageToBuffer_eof	    //skok, je za daty
9D00EF5E      0C00   NOP                          739:       nop
                                                  740:       
                                                  741:       //dalsi rleCnt
9D00EF60  0000FE12   LW S0, 0(S2)                 742:       lw	    s0, (s2)			    //load rleCnt
                                                  743:       addiu   s2, 4
9D00EF64  000740D0   BGTZ S0, 0x9D00EF77          744:       bgtz    s0, 2f			    //skok, rleCnt > 0
9D00EF6A      0C00   NOP                          745:       nop
                                                  746:       
                                                  747:   1:    
9D00EF6C  0000FE72   LW S3, 0(S2)                 748:       lw	    s3, (s2)			    //load data
9D00EF70      4E48   ADDIU S2, S2, 4              749:       addiu   s2, 4			    //position ++
9D00EF72      6C00   ADDIU S0, S0, 1              750:       addiu   s0, 1			    //rleCnt++
9D00EF74      45BF   JRC RA                       751:       jrc	    ra
                                                  752:       
                                                  753:   2:
                                                  754:       //load nove rleData
9D00EF76  0000FE32   LW S1, 0(S2)                 755:       lw	    s1, (s2)			    //load rleCnt
9D00EF7A      4E48   ADDIU S2, S2, 4              756:       addiu   s2, 4			    //position ++
                                                  757:       
                                                  758:   3:
                                                  759:       //rleCnt>0, dalsi rleData
9D00EF7C      0E71   MOVE S3, S1                  760:       move    s3, s1			    //srcWord < rleData
9D00EF7E      6C0E   ADDIU S0, S0, -1             761:       addiu   s0, -1			    //rleCnt--
9D00EF80      45BF   JRC RA                       762:       jrc	    ra
                                                  763:       
                                                  764:       //</editor-fold>
                                                  765:       
                                                  766:   .end imageToBuffer    
                                                  767:       
                                                  768:   //</editor-fold>    
                                                  769:       
                                                  770:   //<editor-fold defaultstate="collapsed" desc="setFontSrc">
                                                  771:   .align 2
                                                  772:   .global setFontSrc
                                                  773:   .ent setFontSrc
                                                  774:   setFontSrc:
                                                  775:   //a0=src data (adresa fontu)    
                                                  776:   //a1=IMAGE_SRC2 struct  
                                                  777:      
                                                  778:      //nastavuje data z head: fileId, format, blockSize, compression, width, height
                                                  779:       //pokud je format=0x4, nastavi adresu colorMap, pokud existuje (offset i size > 0)
                                                  780:       //nastavuje adr. fci: getNextData, getPoint, pointToBuffer
                                                  781:       //nastavuje srcStartPosition, srcAfter, expSize, eof=1
                                                  782:    
                                                  783:       
9D00EF84  10002304   LWP T8, 0(A0)                784:       lwp32    t8, (a0)				//id, format, blockSize, compression, width, height
9D00EF88  90002305   SWP T8, 0(A1)                785:       swp32    t8, (a1)				//save
                                                  786:       
9D00EF8C  000E3704   LHU T8, 14(A0)               787:       lhu32   t8, _HEAD_DATAOFFSET_OFF(a0)	//dataOffset
9D00EF90  C1500098   ADDU T8, T8, A0              788:       addu    t8, a0				//base+offset = zacatek dat fontu
                                                  789:       
9D00EF94  0008FF24   LW T9, 8(A0)                 790:       lw32    t9, _HEAD_FONTITEMSIZE_OFF(a0)	//load itemSize, firstAscii, firstVar
                                                  791:       	    
                                                  792:       //save t8+t9
9D00EF98  90402305   SWP T8, 64(A1)               793:       swp32   t8, _FONTDATAADDR_OFF(a1)		//save dataOffset, itemSize, firstAscii, firstVar
                                                  794:   
                                                  795:       
                                                  796:       //<editor-fold defaultstate="collapsed" desc="format 0x1">
                                                  797:       //test format 0x1
9D00EF9C  00011445   LBU V0, 1(A1)                798:       lbu32   v0, _FORMAT_OFF(a1)
9D00EFA0      ED81   LI V1, 1                     799:       li16    v1, 0x1
9D00EFA2  0011B462   BNE V0, V1, 0x9D00EFC9       800:       bne	    v0, v1, 2f
9D00EFA8      0C00   NOP                          801:       nop
                                                  802:       
                                                  803:       //format 0x1
9D00EFAA  9D0141A3   LUI V1, 0x9D01               804:       la	    v1, point_to_buffer_01
9D00EFB2  0020F865   SW V1, 32(A1)                805:       sw32    v1, _POINTTOBUFFER_OFF(a1)		//pointToBuffer
9D00EFB6  9D0141A3   LUI V1, 0x9D01               806:       la	    v1, get_next_point_01		    
9D00EFBE  001CF865   SW V1, 28(A1)                807:       sw32    v1, _GETPOINT_OFF(a1)		//getPoint
                                                  808:       
                                                  809:       nop
9D00EFC2      CC3E   B 0x9D00F041                 810:       b16	    10f					//after_format
9D00EFC6      0C00   NOP                          811:       nop
                                                  812:       
                                                  813:       //</editor-fold>
                                                  814:       
                                                  815:       //<editor-fold defaultstate="collapsed" desc="format 0x4">
                                                  816:   2:
                                                  817:       //test format 0x4, v0=format
9D00EFC8      ED84   LI V1, 4                     818:       li16    v1, 0x4
9D00EFCA  0017B462   BNE V0, V1, 0x9D00EFFD       819:       bne	    v0, v1, 7f
9D00EFD0      0C00   NOP                          820:       nop
                                                  821:       
                                                  822:       //format 0x4
9D00EFD2  9D0141A3   LUI V1, 0x9D01               823:       la	    v1, point_to_buffer_04
9D00EFDA  0020F865   SW V1, 32(A1)                824:       sw32    v1, _POINTTOBUFFER_OFF(a1)		//pointToBuffer  
9D00EFDE  9D0141A3   LUI V1, 0x9D01               825:       la	    v1, get_next_point_04		    
9D00EFE6  001CF865   SW V1, 28(A1)                826:       sw32    v1, _GETPOINT_OFF(a1)		//getPoint
                                                  827:       
                                                  828:       
                                                  829:       
                                                  830:       //colorMap u fontu neexistuje, nastav std
9D00EFEA  9D0041B9   LUI T9, 0x9D00               831:       la	    t9, stdColorMap
9D00EFF2  0030FB25   SW T9, 48(A1)                832:       sw32    t9, _FORECOLOR_OFF(a1)
                                                  833:       nop
9D00EFF6      CC24   B 0x9D00F041                 834:       b16	    10f					//after_format
9D00EFFA      0C00   NOP                          835:       nop
                                                  836:       
                                                  837:       //</editor-fold>
                                                  838:       
                                                  839:       //<editor-fold defaultstate="collapsed" desc="format 0x55">
                                                  840:   7:  
                                                  841:      //test format 0x55, v0=format 
9D00EFFC  00553060   ADDIU V1, ZERO, 85           842:       addiu   v1, zero, 0x55
9D00F000  0080B462   BNE V0, V1, 0x9D00F105       843:       bne	    v0, v1, 99f				//skok, jiny format, chyba
9D00F006      0C00   NOP                          844:       nop
                                                  845:      
                                                  846:       //format 0x55
9D00F008  9D0141A3   LUI V1, 0x9D01               847:       la	    v1, point_to_buffer_55
9D00F010  0020F865   SW V1, 32(A1)                848:       sw32    v1, _POINTTOBUFFER_OFF(a1)		//pointToBuffer  
                                                  849:       
                                                  850:       //getNexpPoint podle blockSize
9D00F014  00021445   LBU V0, 2(A1)                851:       lbu32   v0, _BLOCKSIZE_OFF(a1)
9D00F018      ED88   LI V1, 8                     852:       li16    v1, 0x8
9D00F01A  000BB462   BNE V0, V1, 0x9D00F035       853:       bne	    v0, v1, 8f				//skok, blockSize=16/32
9D00F020      0C00   NOP                          854:       nop
                                                  855:       
                                                  856:       //blockSize 8
9D00F022  9D0141A3   LUI V1, 0x9D01               857:       la	    v1, get_next_point_55b		    
9D00F02A  001CF865   SW V1, 28(A1)                858:       sw32    v1, _GETPOINT_OFF(a1)		//getPoint
                                                  859:       
                                                  860:       nop
9D00F02E      CC08   B 0x9D00F041                 861:       b16	    10f					//after_format
9D00F032      0C00   NOP                          862:       nop
                                                  863:       
                                                  864:   8:
                                                  865:       //blockSize 16/32
9D00F034  9D0141A3   LUI V1, 0x9D01               866:       la	    v1, get_next_point_55a		    
9D00F03C  001CF865   SW V1, 28(A1)                867:       sw32    v1, _GETPOINT_OFF(a1)		//getPoint
                                                  868:       
                                                  869:       //</editor-fold>
                                                  870:       
                                                  871:       //<editor-fold defaultstate="collapsed" desc="getNextData">
                                                  872:      
                                                  873:   10: //after_format: 
                                                  874:       
                                                  875:       //nastav getNextPoint, podle blockSize a RLE
9D00F040  00021465   LBU V1, 2(A1)                876:       lbu32   v1, _BLOCKSIZE_OFF(a1)			    //8/16/32
9D00F044  00031725   LBU T9, 3(A1)                877:       lbu32   t9, _COMPRESSION_OFF(a1)			    //0/1
9D00F048  0029B419   BNE T9, ZERO, 0x9D00F09F     878:       bnez    t9, 11f
9D00F04E      0C00   NOP                          879:       nop
                                                  880:       
                                                  881:       //nema kopresi, v1=blockSize
                                                  882:       //reg, val, set_reg, set_result, branch (set and branch if equal - reg=val)
9D00F050  00083320   ADDIU T9, ZERO, 8            883:       _SET_B_IF_EQUI v1, 8, v0, 0, 12f			    //meni t9
9D00F068  00103320   ADDIU T9, ZERO, 16           884:       _SET_B_IF_EQUI v1, 16, v0, 1, 12f			    //meni t9
9D00F080  00203320   ADDIU T9, ZERO, 32           885:       _SET_B_IF_EQUI v1, 32, v0, 2, 12f			    //meni t9		
                                                  886:       
                                                  887:       nop
9D00F098      CC35   B 0x9D00F105                 888:       b16	    99f						    //jiny format
9D00F09C      0C00   NOP                          889:       nop
                                                  890:       
                                                  891:   11:
                                                  892:       //ma kopresi, v1=blockSize  
                                                  893:       //reg, val, set_reg, set_result, branch (set and branch if equal - reg=val)
9D00F09E  00083320   ADDIU T9, ZERO, 8            894:       _SET_B_IF_EQUI v1, 8, v0, 3, 12f			    //meni t9
9D00F0B6  00103320   ADDIU T9, ZERO, 16           895:       _SET_B_IF_EQUI v1, 16, v0, 4, 12f			    //meni t9
9D00F0CE  00203320   ADDIU T9, ZERO, 32           896:       _SET_B_IF_EQUI v1, 32, v0, 5, 12f			    //meni t9
                                                  897:       
                                                  898:       nop
9D00F0E6      CC0E   B 0x9D00F105                 899:       b16	    99f						    //jiny format
9D00F0EA      0C00   NOP                          900:       nop
                                                  901:       
                                                  902:   12:    
                                                  903:       //v0=index fce 0-5
9D00F0EC  9D0141B9   LUI T9, 0x9D01               904:       la	    t9, tableOfgetNextData			    //tabulka fci
9D00F0F4  C1180059   LWXS T8, V0(T9)              905:       lwxs    t8, v0(t9)					    //load adresu fce
9D00F0F8  0018FB05   SW T8, 24(A1)                906:       sw32    t8, _GETNEXTDATA_OFF(a1)			    //save adresu fce
                                                  907:       
                                                  908:       //</editor-fold>
                                                  909:   
                                                  910:       //eof=1
9D00F0FC      ED81   LI V1, 1                     911:       li16    v1, 1
9D00F0FE  00491865   SB V1, 73(A1)                912:       sb32    v1, _EOF_OFF(a1)
                                                  913:       
9D00F102      45BF   JRC RA                       914:       jrc	    ra
                                                  915:       
                                                  916:   99:
                                                  917:       //jiny format, nastavi adresu fce GETPOINT na eof, tzn. ze imageToBuffer nic neprovede
9D00F104  9D0141A3   LUI V1, 0x9D01               918:       la	    v1, imageToBuffer_eof		    
9D00F10C  001CF865   SW V1, 28(A1)                919:       sw32    v1, _GETPOINT_OFF(a1)		//getPoint = eof   
9D00F110      45BF   JRC RA                       920:       jrc	    ra
                                                  921:      
                                                  922:   .end setFontSrc    
                                                  923:      
                                                  924:   //</editor-fold>     
                                                  925:   
                                                  926:   //<editor-fold defaultstate="collapsed" desc="fontCharParam">
                                                  927:   .align 2    
                                                  928:   .global fontCharParam    
                                                  929:   .ent fontCharParam    
                                                  930:   fontCharParam:    
                                                  931:   //a0=IMAGE_SRC struct
                                                  932:   //a1=ascii code  
                                                  933:       
                                                  934:       //fce nastavi adresu dat znaku (a1) v FONT_SRC dataPosition, dataAfter
                                                  935:       //1. u fixed size fontu, je-li v povinne oblasti, vypocita adresu
                                                  936:       //2. u var size fontu, nebo je-li za povinnou oblasti, prochazi tabulku a hleda znak
                                                  937:       //nastavi FONT_SRC->width
                                                  938:       //volani fontToBuffer pouzije tuto pozici
                                                  939:   
                                                  940:       //test, zda je nastaven font - IMAGE_SRC v a0
9D00F114  00001444   LBU V0, 0(A0)                941:       lbu32   v0, _FILEID_OFF(a0)
9D00F118  004A9402   BEQ V0, ZERO, 0x9D00F1B1     942:       beqz    v0, 12f
9D00F11E      0C00   NOP                          943:       nop
                                                  944:       
                                                  945:       //adresa zacatku tabulky znaku
9D00F120  0040FC64   LW V1, 64(A0)                946:       lw	    v1, _FONTDATAADDR_OFF(a0)	    //start tabulky znaku
                                                  947:       
                                                  948:       //test, zda ascii >= firstAscii
9D00F124  004615E4   LBU T7, 70(A0)               949:       lbu32   t7, _FIRSTASCII_OFF(a0)	
9D00F128  C9D001E5   SUBU T9, A1, T7              950:       _BAL_FLT	a1, t7, 14f		    //skok, ascii<first //pouziva t9
                                                  951:       
                                                  952:       //test fileid=0x1 - fixed size
9D00F134  00001724   LBU T9, 0(A0)                953:       lbu32   t9, _FILEID_OFF(a0)		    //load file_id	//0x1=fixed font, 0x2=var font
9D00F138      ED01   LI V0, 1                     954:       li16    v0, 1
9D00F13A  001DB459   BNE T9, V0, 0x9D00F179       955:       bne	    t9, v0, 9f			    //skok, neni fixed-size font
9D00F140      0C00   NOP                          956:       nop    
                                                  957:       
                                                  958:       //je fixed size, test zda je ascii ve fixed oblasti
9D00F142  00443444   LHU V0, 68(A0)               959:       lhu32   v0, _FONTITEMSIZE_OFF(a0)	    //load itemSize
9D00F146  004715C4   LBU T6, 71(A0)               960:       lbu32   t6, _FIRSTVAR_OFF(a0)
9D00F14A  C9D001C5   SUBU T9, A1, T6              961:       _BAL_FBE	a1, t6, 8f //fs_free_area    //skok, je free /meni t9	    
                                                  962:       
                                                  963:       //adresu vypocita, t7=firstAscii
9D00F156  29D001E5   SUBU A1, A1, T7              964:       subu    a1, t7			    //index ascii
9D00F15A  8B3C00A2   MULT V0, A1                  965:       mult    v0, a1			    //v0=fixed itemSize
9D00F15E      4659   MFLO T9                      966:       mflo    t9
9D00F160  19500323   ADDU V1, V1, T9              967:       addu    v1, t9			    //startData + offset = zacatek dat znaku  
                                                  968:       
                                                  969:       nop
9D00F164      CC18   B 0x9D00F197                 970:       b16	    11f				    //nasel_adresu_znaku
9D00F168      0C00   NOP                          971:       nop
                                                  972:       
                                                  973:   8:  //fs_free_area:
                                                  974:       //znak je ve var oblasti t6=firtsVar, t7=firstAscii, v0=fixed itemSize
                                                  975:       //firstVar-firstAscii x fixedSize = offset prvniho Var
9D00F16A  71D001EE   SUBU T6, T6, T7              976:       subu    t6, t7
9D00F16E  8B3C004E   MULT T6, V0                  977:       mult    t6, v0
9D00F172      4659   MFLO T9                      978:       mflo    t9
9D00F174  19500323   ADDU V1, V1, T9              979:       addu    v1, t9			    //v1=adresa prvniho free znaku
                                                  980:       
                                                  981:   9:    
                                                  982:       //vyhleda znak, je v free oblasti, v1=adresa oblasti
9D00F178      ED00   LI V0, 0                     983:       li16    v0, 0			    //v0-velikost predchoziho znaku
                                                  984:       
                                                  985:   10:    
                                                  986:       //dummy byte - pokud predchozi velikost byla licha, pripocita dummy byte
9D00F17A      6D20   ADDIU V0, V0, 1              987:       addiu   v0, 1
9D00F17C  000C0040   INS V0, ZERO, 0, 1           988:       ins	    v0, zero, 0, 1
                                                  989:       
9D00F180      05A6   ADDU V1, V1, V0              990:       addu    v1, v0			    //adresa + size predchoziho
                                                  991:       //move    t8, t9			    //zaloha ascii code predchoziho znaku, pro pripad, ze nenajde hledany
9D00F182  00001723   LBU T9, 0(V1)                992:       lbu	    t9, (v1)			    //load ascii code    
                                                  993:       
                                                  994:       //test konce
9D00F186  00149419   BEQ T9, ZERO, 0x9D00F1B3     995:       beqz    t9, 13f			    //skok, je na konci
9D00F18C      0C00   NOP                          996:       nop
                                                  997:       
                                                  998:       lhu	    v0, 2(v1)			    //aktualni item size
9D00F18E  FFF4B4B9   BNE T9, A1, 0x9D00F17B       999:       bne	    t9, a1, 10b			    //skok, toto je jiny znak
9D00F194      0C00   NOP                          1000:      nop    
                                                  1001:      
                                                  1002:  11: //nasel_adresu_znaku:   
                                                  1003:      //ok, nasel znak, v1=adresa znaku, v0=size
9D00F196  00011723   LBU T9, 1(V1)                1004:      lbu	    t9, 1(v1)			    //load width
9D00F19A  00043B24   SH T9, 4(A0)                 1005:      sh32    t9, _WIDTH_OFF(a0)		    //save width
                                                  1006:      
9D00F19E      0534   ADDU V0, V0, V1              1007:      addu    v0, v1			    //adresa + size = after
9D00F1A0  002CF844   SW V0, 44(A0)                1008:      sw32    v0, _SRCAFTER_OFF(a0)	    //save dataAfter
                                                  1009:      
9D00F1A4      6DB2   ADDIU V1, V1, 4              1010:      addiu   v1, 4			    //+4 item head
9D00F1A6  0028F864   SW V1, 40(A0)                1011:      sw32    v1, _SRCSTARTPOSITION_OFF(a0)   //save dataPosition
                                                  1012:      
9D00F1AA      ED01   LI V0, 1                     1013:      li16    v0, 0x1
9D00F1AC  00491844   SB V0, 73(A0)                1014:      sb32    v0, _EOF_OFF(a0)		    //eof=1
                                                  1015:  
                                                  1016:  12:    
                                                  1017:      //vraci v0=0-chyba, neni nastaven font (IMAGE_SRC v a0), 1=ok (i kdyz nenajde ascii code a vraci prvni/posledni znak)
9D00F1B0      45BF   JRC RA                       1018:      jrc	    ra
                                                  1019:      
                                                  1020:      
                                                  1021:  13:    
                                                  1022:      //nenasel ascii code znaku, vraci adresu posledniho znaku
9D00F1B2      05A7   SUBU V1, V1, V0              1023:      subu    v1, v0
                                                  1024:      nop
9D00F1B4      CFF0   B 0x9D00F197                 1025:      b16	    11b
9D00F1B8      0C00   NOP                          1026:      nop   
                                                  1027:      
                                                  1028:  14:
                                                  1029:      //ascii < first, neexistuje, vraci prvni (v1)
9D00F1BA      2931   LHU V0, 2(V1)                1030:      lhu	    v0, 2(v1)			    //aktualni item size
                                                  1031:      nop
9D00F1BC      CFEC   B 0x9D00F197                 1032:      b16	    11b
9D00F1C0      0C00   NOP                          1033:      nop
                                                  1034:  
                                                  1035:  .end fontCharParam
                                                  1036:      
                                                  1037:  //</editor-fold>     
                                                  1038:      
                                                  1039:  //<editor-fold defaultstate="collapsed" desc="RGB16">
                                                  1040:  .align 2
                                                  1041:  .global RGB16
                                                  1042:  .ent RGB16
                                                  1043:  RGB16:
                                                  1044:  //a0=R
                                                  1045:  //a1=G
                                                  1046:  //a2=B
                                                  1047:      
                                                  1048:      //b15      8 - 7      0  
                                                  1049:      //  RRRRRGGG - GGGBBBBB
                                                  1050:  
                                                  1051:      
                                                  1052:      //blue
9D00F1C4      0C46   MOVE V0, A2                  1053:      move    v0, a2		
                                                  1054:      
                                                  1055:      //green
9D00F1C6  282C0325   EXT T9, A1, 0, 6             1056:      ext	    t9, a1, 0, 6
9D00F1CA  514C0059   INS V0, T9, 5, 6             1057:      ins	    v0, t9, 5, 6
                                                  1058:      
                                                  1059:      //red
9D00F1CE  202C0324   EXT T9, A0, 0, 5             1060:      ext	    t9, a0, 0, 5
9D00F1D2  7ACC0059   INS V0, T9, 11, 5            1061:      ins	    v0, t9, 11, 5	    //R = b11...b15
                                                  1062:      
9D00F1D6      45BF   JRC RA                       1063:      jrc	    ra
                                                  1064:      
                                                  1065:      
                                                  1066:  .end RGB16   
                                                  1067:  
                                                  1068:  //</editor-fold>    
                                                  1069:      
                                                  1070:  //<editor-fold defaultstate="collapsed" desc="correctColor16">
                                                  1071:  .align 2
                                                  1072:  .global correctColor16
                                                  1073:  .ent correctColor16
                                                  1074:  correctColor16:
                                                  1075:  //a0=vstup, barva v normalnim formatu b15 RRRRRGGG - GGGBBBBB b0   
                                                  1076:  //v0 vraci upravenou barvu, pokud odesila barvu na port v 8-bit modu (napr. SPI, PMP) musi prohodit H a L byte (wsbh)
                                                  1077:      
                                                  1078:  #ifdef DISPLAY_BUS_8    
                                                  1079:      //pokud je komunikace 8-bit, musi prohodit H a L byte, 16-bit je ok 
                                                  1080:      wsbh    v0, a0
                                                  1081:  #else
                                                  1082:      //vraci original
9D00F1D8      0C44   MOVE V0, A0                  1083:      move    v0, a0
                                                  1084:  #endif     
                                                  1085:      
9D00F1DA      45BF   JRC RA                       1086:      jrc	    ra
                                                  1087:  
                                                  1088:  .end correctColor16   
                                                  1089:  
                                                  1090:  //</editor-fold>     
                                                  1091:      
                                                  1092:  
                                                  1093:  //<editor-fold defaultstate="collapsed" desc="drawLineQuick">
                                                  1094:      /*
                                                  1095:  .align 2
                                                  1096:  .global	drawLineQuick
                                                  1097:  .ent drawLineQuick
                                                  1098:  drawLineQuick:
                                                  1099:  //a0=LINE_SRC struct
                                                  1100:  //a1=
                                                  1101:  //a2=color
                                                  1102:  //a3=fn
                                                  1103:      
                                                  1104:      //a0=LINE_SRC
                                                  1105:      //a1=POINT_SRC struct
                                                  1106:      //a2=hw buffer
                                                  1107:      //a3=dc fn
                                                  1108:  
                                                  1109:      _PUSH_S07RA
                                                  1110:      
                                                  1111:      //a0 struct x1, y1, x2, y2, dispw, disph
                                                  1112:      lh	    s0, 0(a0)
                                                  1113:      lh	    s1, 2(a0)
                                                  1114:      lh	    s2, 4(a0)
                                                  1115:      lh	    s3, 6(a0)
                                                  1116:      lh	    s4, 8(a0)
                                                  1117:      lh	    s5, 10(a0)
                                                  1118:      move    s7, zero			//poradi bodu x (nebo y)	    
                                                  1119:      
                                                  1120:      //res, r1, r2
                                                  1121:      _ABS_DIFF t0, s0, s2		//meni t9, abs. hornota rozdilu r1-r2
                                                  1122:      _ABS_DIFF t1, s1, s3		//meni t9
                                                  1123:      
                                                  1124:      _BAL_FBE t1, t0, calcx		//skok deltaY > deltaX
                                                  1125:  
                                                  1126:  calcy:    
                                                  1127:      //deltaX > deltaY, pocita Y
                                                  1128:      _BAL_FLE s0, s2, 1f			//skok, x1 <= x2
                                                  1129:      
                                                  1130:      //prohodi x1/x2 a y1/y2
                                                  1131:      move    t9, s0
                                                  1132:      move    s0, s2
                                                  1133:      move    s2, t9
                                                  1134:      
                                                  1135:      move    t9, s1
                                                  1136:      move    s1, s3
                                                  1137:      move    s3, t9    
                                                  1138:     
                                                  1139:  1:    
                                                  1140:      //vypocet R y2-y1 / x2-x1 (pomer stran)
                                                  1141:      sub	    t8, s2, s0			//x2-x1
                                                  1142:      sub	    t9, s3, s1			//y2-y1
                                                  1143:      sll	    t9, 12			//nasobek * 4096
                                                  1144:      
                                                  1145:      div	    t9, t8
                                                  1146:      mflo    s6				//s6=R
                                                  1147:      nop
                                                  1148:      b16	    3f
                                                  1149:      nop
                                                  1150:      
                                                  1151:  2:  //loop s0 ... s2
                                                  1152:      addiu   s0, 1			//X++
                                                  1153:      addiu   s7, 1			//point ++
                                                  1154:  3:    
                                                  1155:      //vypocet Y pro akt. X (s0)
                                                  1156:      mult    s6, s7
                                                  1157:      mflo    a1				// r * point
                                                  1158:      
                                                  1159:      //vypocet Y se zaokrouhlenim
                                                  1160:      srl	    a1, 11
                                                  1161:      ext	    t9, a1, 0, 1
                                                  1162:      srl	    a1, 1
                                                  1163:      seh	    a1				//rozsireni znamenka   
                                                  1164:      beqz    t9, 5f			
                                                  1165:      nop
                                                  1166:      addi    a1, 1
                                                  1167:  5:    
                                                  1168:      
                                                  1169:      add     a1, s1			//Y += Y1
                                                  1170:      move    a0, s0			//x
                                                  1171:      //test, zda neni mimo display
                                                  1172:      bltz    a0, 4f			//x<0
                                                  1173:      nop
                                                  1174:      bltz    a1, 4f			//y<0
                                                  1175:      nop
                                                  1176:      _BAL_FBE a0, s4, 4f			//x>=w
                                                  1177:      _BAL_FBE a1, s5, 4f			//y>=h
                                                  1178:      
                                                  1179:      bal	    drawPointQuick		//nemeni a2/a3
                                                  1180:      nop
                                                  1181:      
                                                  1182:  4:    
                                                  1183:      bne	    s0, s2, 2b			//skok, akt. x neni posledni
                                                  1184:      nop
                                                  1185:      
                                                  1186:      //konec 
                                                  1187:      _POP_S07RA
                                                  1188:      jrc	    ra
                                                  1189:     
                                                  1190:  calcx:    
                                                  1191:      //deltaY > deltaX, pocita X
                                                  1192:      //deltaX > deltaY, pocita Y
                                                  1193:      _BAL_FLE s1, s3, 1f			//skok, y1 <= y2
                                                  1194:      
                                                  1195:      //prohodi y1/y2 a x1/x2
                                                  1196:      move    t9, s1
                                                  1197:      move    s1, s3
                                                  1198:      move    s3, t9   
                                                  1199:      
                                                  1200:      move    t9, s0
                                                  1201:      move    s0, s2
                                                  1202:      move    s2, t9
                                                  1203:  
                                                  1204:  1:        
                                                  1205:      //vypocet R x2-x1 / y2-y1
                                                  1206:      sub	    t8, s3, s1			//y2-y1
                                                  1207:      sub	    t9, s2, s0			//x2-x1
                                                  1208:      sll	    t9, 12			//nasobek
                                                  1209:      
                                                  1210:      div	    t9, t8
                                                  1211:      mflo    s6				//s6=R
                                                  1212:      nop
                                                  1213:      b16	    3f
                                                  1214:      nop 
                                                  1215:      
                                                  1216:  2:  //loop s1 ... s3
                                                  1217:      addiu   s1, 1			//Y++
                                                  1218:      addiu   s7, 1			//point ++
                                                  1219:  3:    
                                                  1220:      //vypocet X pro akt. Y (s1)
                                                  1221:      mult    s6, s7
                                                  1222:      mflo    a0				// r * y
                                                  1223:      
                                                  1224:      //vypocet X se zaokrouhlenim
                                                  1225:      srl	    a0, 11
                                                  1226:      ext	    t9, a0, 0, 1
                                                  1227:      srl	    a0, 1
                                                  1228:      seh	    a0				//rozsireni znamenka   
                                                  1229:      beqz    t9, 5f 
                                                  1230:      nop
                                                  1231:      addi    a0, 1
                                                  1232:  5:    
                                                  1233:      
                                                  1234:      add     a0, s0			//X += X1
                                                  1235:      move    a1, s1			//Y
                                                  1236:      //test, zda neni mimo display
                                                  1237:      bltz    a0, 4f			//x<0
                                                  1238:      nop
                                                  1239:      bltz    a1, 4f			//y<0
                                                  1240:      nop
                                                  1241:      _BAL_FBE a0, s4, 4f			//x>=w
                                                  1242:      _BAL_FBE a1, s5, 4f			//y>=h
                                                  1243:      
                                                  1244:      bal	    drawPointQuick		//nemeni a2/a3
                                                  1245:      nop
                                                  1246:      
                                                  1247:  4:    
                                                  1248:      bne	    s1, s3, 2b
                                                  1249:      nop
                                                  1250:      
                                                  1251:      //konec 
                                                  1252:      _POP_S07RA
                                                  1253:      jrc	    ra    
                                                  1254:  
                                                  1255:  .end drawLineQuick  
                                                  1256:      */
                                                  1257:      
                                                  1258:  //</editor-fold>
                                                  1259:   
                                                  1260:  //<editor-fold defaultstate="collapsed" desc="MACRO">
                                                  1261:      /*
                                                  1262:  .macro _WRITE_COMMAND com, dc_fn
                                                  1263:  //com = command
                                                  1264:  //dc_fn = adresa fce setDcPin	
                                                  1265:     
                                                  1266:  	
                                                  1267:      //DC=0
                                                  1268:      li	a0, 0x0			    
                                                  1269:      jal	\dc_fn
                                                  1270:      nop
                                                  1271:  	
                                                  1272:      //odeslat hword command >> hw buffer
                                                  1273:      sh	\com, (SPI2BUF)
                                                  1274:      //pauza na odeslani
                                                  1275:      nop
                                                  1276:      nop
                                                  1277:      nop
                                                  1278:      nop
                                                  1279:  	
                                                  1280:      //DC=1
                                                  1281:      li	a0, 0x1			    
                                                  1282:      jal	\dc_fn
                                                  1283:      nop	
                                                  1284:  .endm  
                                                  1285:      */
                                                  1286:  //</editor-fold>
                                                  1287:  //<editor-fold defaultstate="collapsed" desc="drawPointQuick">
                                                  1288:      /*
                                                  1289:  .align 2    
                                                  1290:  .global drawPointQuick    
                                                  1291:  .ent drawPointQuick
                                                  1292:  drawPointQuick:
                                                  1293:  //a0 = x
                                                  1294:  //a1 = y
                                                  1295:  //a2 = color
                                                  1296:  //a3 = dc fn
                                                  1297:      
                                                  1298:  //a0 = point struct
                                                  1299:  //a2 = buffer
                                                  1300:  //a3 = dc_fn    
                                                  1301:      
                                                  1302:      //nesmi menit a2 a a3
                                                  1303:      
                                                  1304:      _PUSH   ra
                                                  1305:      addiu   sp, -4
                                                  1306:      
                                                  1307:      move    t0, a0
                                                  1308:      move    t1, a1
                                                  1309:      
                                                  1310:      //column (x)
                                                  1311:      li	    t2, 0x2A		    //write column
                                                  1312:      _WRITE_COMMAND t2, a3
                                                  1313:      sh	    t0, (SPI2BUF)	    //start_x
                                                  1314:      sh	    t0, (SPI2BUF)	    //end_x
                                                  1315:      
                                                  1316:      //page (y)
                                                  1317:      li	    t2, 0x2B		    //write page
                                                  1318:      _WRITE_COMMAND t2, a3    
                                                  1319:      sh	    t1, (SPI2BUF)	    //start_y
                                                  1320:      sh	    t1, (SPI2BUF)	    //end_y
                                                  1321:  
                                                  1322:      li	    t2, 0x2C		    //write data
                                                  1323:      _WRITE_COMMAND t2, a3    
                                                  1324:      sh	    a2, (SPI2BUF)	    //color
                                                  1325:      
                                                  1326:      addiu   sp, 4
                                                  1327:      _POP    ra
                                                  1328:      jrc	    ra
                                                  1329:      
                                                  1330:  .end drawPointQuick 
                                                  1331:      */
                                                  1332:      
                                                  1333:  //</editor-fold>
                                                  1334:   
                                                  1335:  //<editor-fold defaultstate="collapsed" desc="MACRO">
                                                  1336:  .macro _ABS_DIFF result, reg1, reg2 
                                                  1337:  //meni t9
                                                  1338:  //v result vraci abs. hodnotu rozdilu reg1-reg2    
                                                  1339:      
                                                  1340:      sub	    \result, \reg1, \reg2
                                                  1341:      
                                                  1342:      bgez    \result, 1001f
                                                  1343:      nop
                                                  1344:      
                                                  1345:      addiu   t9, zero, -1
                                                  1346:      mult    \result, t9
                                                  1347:      mflo    \result
                                                  1348:      
                                                  1349:  1001:    
                                                  1350:      
                                                  1351:  .endm
                                                  1352:  //</editor-fold>    
                                                  1353:  //<editor-fold defaultstate="collapsed" desc="drawLineQuick">
                                                  1354:  .align 2
                                                  1355:  .global	drawLineQuick
                                                  1356:  .ent drawLineQuick
                                                  1357:  drawLineQuick:
                                                  1358:  //a0=LINE_SRC
                                                  1359:  //a1=hw buffer
                                                  1360:  //a2=dc fn
                                                  1361:  //a3=
                                                  1362:      
                                                  1363:      //v sp vytvori misto pro POINT struct (short x, short y, short color)
                                                  1364:      //sp[0] ra (PUSH s0-s7 + ra)
                                                  1365:      //sp -= 8
                                                  1366:      //sp[0] x
                                                  1367:      //sp[2] y
                                                  1368:      //sp[4] color
                                                  1369:  
9D00F1DC      4FEF   ADDIU SP, SP, -36            1370:      _PUSH_S07RA
9D00F1E2      4FB0   ADDIU SP, SP, -8             1371:      addiu   sp, -8	    //misto pro POINT struct
9D00F1E4  00083724   LHU T9, 8(A0)                1372:      lhu	    t9, 8(a0)	    //load LINE_SRC.color
9D00F1E8  00043B3D   SH T9, 4(SP)                 1373:      sh	    t9, 4(sp)	    //save POINT.color (0(sp)=x, 2(sp)=y, 4[sp]=color)
                                                  1374:      
                                                  1375:      //a0 struct x1, y1, x2, y2, dispw, disph
9D00F1EC  00003E04   LH S0, 0(A0)                 1376:      lh	    s0, 0(a0)		//x1
9D00F1F0  00023E24   LH S1, 2(A0)                 1377:      lh	    s1, 2(a0)		//y1
9D00F1F4  00043E44   LH S2, 4(A0)                 1378:      lh	    s2, 4(a0)		//x2
9D00F1F8  00063E64   LH S3, 6(A0)                 1379:      lh	    s3, 6(a0)		//y2
9D00F1FC  000A3E84   LH S4, 10(A0)                1380:      lh	    s4, 10(a0)		//w    
9D00F200  000C3EA4   LH S5, 12(A0)                1381:      lh	    s5, 12(a0)		//h
9D00F204      0EE0   MOVE S7, ZERO                1382:      move    s7, zero			//poradi bodu x (nebo y)	    
                                                  1383:      
                                                  1384:      //res, r1, r2
9D00F206  C1900250   SUB T8, S0, S2               1385:      _ABS_DIFF t8, s0, s2		//meni t9, abs. hornota rozdilu r1-r2
9D00F21C  79900271   SUB T7, S1, S3               1386:      _ABS_DIFF t7, s1, s3		//meni t9
                                                  1387:      
9D00F232  C9D0030F   SUBU T9, T7, T8              1388:      _BAL_FBE t7, t8, calcx2		//skok deltaY > deltaX
                                                  1389:  
                                                  1390:  calcy2:    
                                                  1391:      //deltaX > deltaY, pocita Y
9D00F23E  C9D00250   SUBU T9, S0, S2              1392:      _BAL_FLE s0, s2, 1f			//skok, x1 <= x2
                                                  1393:      
                                                  1394:      //prohodi x1/x2 a y1/y2
9D00F24A      0F30   MOVE T9, S0                  1395:      move    t9, s0
9D00F24C      0E12   MOVE S0, S2                  1396:      move    s0, s2
9D00F24E      0E59   MOVE S2, T9                  1397:      move    s2, t9
                                                  1398:      
9D00F250      0F31   MOVE T9, S1                  1399:      move    t9, s1
9D00F252      0E33   MOVE S1, S3                  1400:      move    s1, s3
9D00F254      0E79   MOVE S3, T9                  1401:      move    s3, t9    
                                                  1402:     
                                                  1403:  1:    
                                                  1404:      //vypocet R y2-y1 / x2-x1 (pomer stran)
9D00F256  C1900212   SUB T8, S2, S0               1405:      sub	    t8, s2, s0			//x2-x1
9D00F25A  C9900233   SUB T9, S3, S1               1406:      sub	    t9, s3, s1			//y2-y1
9D00F25E  60000339   SLL T9, T9, 12               1407:      sll	    t9, 12			//nasobek * 4096
                                                  1408:      
9D00F262  703C0018   TEQ T8, ZERO                 1409:      div	    t9, t8
9D00F27C      4656   MFLO S6                      1410:      mflo    s6				//s6=R
                                                  1411:      nop
9D00F27E      CC04   B 0x9D00F289                 1412:      b16	    3f
9D00F282      0C00   NOP                          1413:      nop
                                                  1414:      
                                                  1415:  2:  //loop s0 ... s2
9D00F284      6C00   ADDIU S0, S0, 1              1416:      addiu   s0, 1			//X++
9D00F286      4EE2   ADDIU S7, S7, 1              1417:      addiu   s7, 1			//point ++
                                                  1418:  3:    
                                                  1419:      //vypocet Y pro akt. X (s0)
9D00F288  8B3C02F6   MULT S6, S7                  1420:      mult    s6, s7
9D00F28C      4649   MFLO T1                      1421:      mflo    t1				// r * point
                                                  1422:      
                                                  1423:      //vypocet Y se zaokrouhlenim
9D00F28E  58400129   SRL T1, T1, 11               1424:      srl	    t1, 11
9D00F292  002C0329   EXT T9, T1, 0, 1             1425:      ext	    t9, t1, 0, 1
9D00F296  08400129   SRL T1, T1, 1                1426:      srl	    t1, 1
                                                  1427:      seh	    t1				//rozsireni znamenka   
9D00F29A  00059419   BEQ T9, ZERO, 0x9D00F2A9     1428:      beqz    t9, 5f			
9D00F2A2      0C00   NOP                          1429:      nop
9D00F2A4  00011129   ADDI T1, T1, 1               1430:      addi    t1, 1
                                                  1431:  5:    
                                                  1432:      
                                                  1433:      add     t1, s1			//Y += Y1
                                                  1434:      //move    a0, s0			//x
                                                  1435:      //test, zda neni mimo display
9D00F2A8  00244010   BLTZ S0, 0x9D00F2F5          1436:      bltz    s0, 4f			//x<0
                                                  1437:      nop
9D00F2B0  00204009   BLTZ T1, 0x9D00F2F5          1438:      bltz    t1, 4f			//y<0
9D00F2B6      0C00   NOP                          1439:      nop
9D00F2B8  C9D00290   SUBU T9, S0, S4              1440:      _BAL_FBE s0, s4, 4f			//x>=w
9D00F2C4  C9D002A9   SUBU T9, T1, S5              1441:      _BAL_FBE t1, s5, 4f			//y>=h
                                                  1442:      
                                                  1443:      //param
9D00F2D0  00003A1D   SH S0, 0(SP)                 1444:      sh	    s0, 0(sp)			//POINT.x
9D00F2D4  0002393D   SH T1, 2(SP)                 1445:      sh	    t1, 2(sp)			//POINT.y
9D00F2D8      0C9D   MOVE A0, SP                  1446:      move    a0, sp			//a0=&POINT struct
9D00F2DA      4FB8   ADDIU SP, SP, -4             1447:      _PUSH   a1				//hw buffer
9D00F2DE      4FB8   ADDIU SP, SP, -4             1448:      _PUSH   a2				//dc fn
                                                  1449:      //a0=&POINT, a1=hw buffer, a2=dc fn
9D00F2E2  00754060   BGEZAL ZERO, 0x9D00F3D1      1450:      bal	    drawPointQuick		//muze menit vse, mimo s0-s7
9D00F2EA      0C00   NOP                          1451:      nop
9D00F2EC      48C0   LW A2, 0(SP)                 1452:      _POP    a2
9D00F2F0      48A0   LW A1, 0(SP)                 1453:      _POP    a1
                                                  1454:      
                                                  1455:  4:    
9D00F2F4  FFC6B650   BNE S0, S2, 0x9D00F285       1456:      bne	    s0, s2, 2b			//skok, akt. x neni posledni
9D00F2FA      0C00   NOP                          1457:      nop
                                                  1458:      
                                                  1459:      //konec 
9D00F2FC      4C05   ADDIU SP, SP, 8              1460:      addiu   sp, 8	    //misto pro POINT struct
9D00F2FE  5000231D   LWM S0-S7, RA, 0(SP)         1461:      _POP_S07RA
9D00F304      45BF   JRC RA                       1462:      jrc	    ra
                                                  1463:     
                                                  1464:  calcx2:    
                                                  1465:      //deltaY > deltaX, pocita X
                                                  1466:      //deltaX > deltaY, pocita Y
9D00F306  C9D00271   SUBU T9, S1, S3              1467:      _BAL_FLE s1, s3, 1f			//skok, y1 <= y2
                                                  1468:      
                                                  1469:      //prohodi y1/y2 a x1/x2
9D00F312      0F31   MOVE T9, S1                  1470:      move    t9, s1
9D00F314      0E33   MOVE S1, S3                  1471:      move    s1, s3
9D00F316      0E79   MOVE S3, T9                  1472:      move    s3, t9   
                                                  1473:      
9D00F318      0F30   MOVE T9, S0                  1474:      move    t9, s0
9D00F31A      0E12   MOVE S0, S2                  1475:      move    s0, s2
9D00F31C      0E59   MOVE S2, T9                  1476:      move    s2, t9
                                                  1477:  
                                                  1478:  1:        
                                                  1479:      //vypocet R x2-x1 / y2-y1
9D00F31E  C1900233   SUB T8, S3, S1               1480:      sub	    t8, s3, s1			//y2-y1
9D00F322  C9900212   SUB T9, S2, S0               1481:      sub	    t9, s2, s0			//x2-x1
9D00F326  60000339   SLL T9, T9, 12               1482:      sll	    t9, 12			//nasobek
                                                  1483:      
9D00F32A  703C0018   TEQ T8, ZERO                 1484:      div	    t9, t8
9D00F344      4656   MFLO S6                      1485:      mflo    s6				//s6=R
                                                  1486:      nop
9D00F346      CC04   B 0x9D00F351                 1487:      b16	    3f
9D00F34A      0C00   NOP                          1488:      nop 
                                                  1489:      
                                                  1490:  2:  //loop s1 ... s3
9D00F34C      6C90   ADDIU S1, S1, 1              1491:      addiu   s1, 1			//Y++
9D00F34E      4EE2   ADDIU S7, S7, 1              1492:      addiu   s7, 1			//point ++
                                                  1493:  3:    
                                                  1494:      //vypocet X pro akt. Y (s1)
9D00F350  8B3C02F6   MULT S6, S7                  1495:      mult    s6, s7
9D00F354      4648   MFLO T0                      1496:      mflo    t0				// r * y
                                                  1497:      
                                                  1498:      //vypocet X se zaokrouhlenim
9D00F356  58400108   SRL T0, T0, 11               1499:      srl	    t0, 11
9D00F35A  002C0328   EXT T9, T0, 0, 1             1500:      ext	    t9, t0, 0, 1
9D00F35E  08400108   SRL T0, T0, 1                1501:      srl	    t0, 1
                                                  1502:      seh	    t0				//rozsireni znamenka   
9D00F362  00059419   BEQ T9, ZERO, 0x9D00F371     1503:      beqz    t9, 5f 
9D00F36A      0C00   NOP                          1504:      nop
9D00F36C  00011108   ADDI T0, T0, 1               1505:      addi    t0, 1
                                                  1506:  5:    
                                                  1507:      
9D00F370  41100208   ADD T0, T0, S0               1508:      add     t0, s0			//X += X1
                                                  1509:      //move    a1, s1			//Y
                                                  1510:      //test, zda neni mimo display
9D00F374  00234008   BLTZ T0, 0x9D00F3BF          1511:      bltz    t0, 4f			//x<0
                                                  1512:      nop
9D00F37A  00204011   BLTZ S1, 0x9D00F3BF          1513:      bltz    s1, 4f			//y<0
9D00F380      0C00   NOP                          1514:      nop
9D00F382  C9D00288   SUBU T9, T0, S4              1515:      _BAL_FBE t0, s4, 4f			//x>=w
9D00F38E  C9D002B1   SUBU T9, S1, S5              1516:      _BAL_FBE s1, s5, 4f			//y>=h
                                                  1517:      
                                                  1518:      //param
9D00F39A  0000391D   SH T0, 0(SP)                 1519:      sh	    t0, 0(sp)			//POINT.x
9D00F39E  00023A3D   SH S1, 2(SP)                 1520:      sh	    s1, 2(sp)			//POINT.y
9D00F3A2      0C9D   MOVE A0, SP                  1521:      move    a0, sp			//a0=&POINT struct
9D00F3A4      4FB8   ADDIU SP, SP, -4             1522:      _PUSH   a1				//hw buffer
9D00F3A8      4FB8   ADDIU SP, SP, -4             1523:      _PUSH   a2				//dc fn
                                                  1524:      //a0=&POINT, a1=hw buffer, a2=dc fn
9D00F3AC  00104060   BGEZAL ZERO, 0x9D00F3D1      1525:      bal	    drawPointQuick		//muze menit vse, mimo s0-s7
9D00F3B4      0C00   NOP                          1526:      nop
9D00F3B6      48C0   LW A2, 0(SP)                 1527:      _POP    a2
9D00F3BA      48A0   LW A1, 0(SP)                 1528:      _POP    a1
                                                  1529:      
                                                  1530:  4:    
9D00F3BE  FFC5B671   BNE S1, S3, 0x9D00F34D       1531:      bne	    s1, s3, 2b
9D00F3C4      0C00   NOP                          1532:      nop
                                                  1533:      
                                                  1534:      //konec 
9D00F3C6      4C05   ADDIU SP, SP, 8              1535:      addiu   sp, 8	    //misto pro POINT struct
9D00F3C8  5000231D   LWM S0-S7, RA, 0(SP)         1536:      _POP_S07RA
9D00F3CE      45BF   JRC RA                       1537:      jrc	    ra    
                                                  1538:  
                                                  1539:  .end drawLineQuick   
                                                  1540:      
                                                  1541:  //</editor-fold>    
                                                  1542:      
                                                  1543:  //<editor-fold defaultstate="collapsed" desc="MACRO">
                                                  1544:  .macro _WRITE_COMMAND2 com, dc_fn, hw
                                                  1545:  //com = command
                                                  1546:  //dc_fn = adresa fce setDcPin	
                                                  1547:  //hw = hw buffer    
                                                  1548:  	
                                                  1549:      //DC=0
                                                  1550:      li16    a0, 0x0			    
                                                  1551:      jal	    \dc_fn
                                                  1552:      nop
                                                  1553:  	
                                                  1554:      //odeslat hword command >> hw buffer
                                                  1555:      sh	    \com, (\hw)
                                                  1556:      //pauza na odeslani
                                                  1557:      nop
                                                  1558:      nop
                                                  1559:      nop
                                                  1560:      nop
                                                  1561:  	
                                                  1562:      //DC=1
                                                  1563:      li16    a0, 0x1			    
                                                  1564:      jal	    \dc_fn
                                                  1565:      nop	
                                                  1566:  .endm  
                                                  1567:  //</editor-fold>    
                                                  1568:  //<editor-fold defaultstate="collapsed" desc="drawPointQuick">
                                                  1569:  .align 2    
                                                  1570:  .global drawPointQuick    
                                                  1571:  .ent drawPointQuick
                                                  1572:  drawPointQuick:
                                                  1573:  //a0 = point struct (short x, short y, short color)
                                                  1574:  //a1 = hw buffer (SPIxBUF)
                                                  1575:  //a2 = dc_fn (adresa fce, ktera nastavi DC pin)   
                                                  1576:      
                                                  1577:      //volajici fce musi nastavit SPI 16-bit mode
                                                  1578:      //protoze vola fci c/c++, zachova pouze s0-s7
                                                  1579:      
9D00F3D0      4FF7   ADDIU SP, SP, -20            1580:      _PUSH_S03RA
9D00F3D6      4FB8   ADDIU SP, SP, -4             1581:      addiu   sp, -4		    //protoze vola c/c++ fci s jednim arg.
                                                  1582:  
                                                  1583:      //zaloha a0-a2, protoze vola c/c++ fci, ktera by je mohla zmenit
9D00F3D8      0E04   MOVE S0, A0                  1584:      move    s0, a0
9D00F3DA      0E25   MOVE S1, A1                  1585:      move    s1, a1
9D00F3DC      0E46   MOVE S2, A2                  1586:      move    s2, a2
                                                  1587:      
                                                  1588:      //column (x)
9D00F3DE  002A3260   ADDIU S3, ZERO, 42           1589:      li	    s3, 0x2A		    //write column
9D00F3E2      EE00   LI A0, 0                     1590:      _WRITE_COMMAND2 s3, s2, s1	    //command, dc fn, hw buffer, meni a0
9D00F402  00003730   LHU T9, 0(S0)                1591:      lhu	    t9, 0(s0)		    //load x
9D00F406  00003B31   SH T9, 0(S1)                 1592:      sh	    t9, (s1)		    //start_x >> hw buffer
9D00F40A  00003B31   SH T9, 0(S1)                 1593:      sh	    t9, (s1)		    //end_x >> hw buffer
                                                  1594:      
                                                  1595:      //page (y)
9D00F40E  002B3260   ADDIU S3, ZERO, 43           1596:      li	    s3, 0x2B		    //write page
9D00F412      EE00   LI A0, 0                     1597:      _WRITE_COMMAND2 s3, s2, s1	    //command, dc fn, hw buffer, meni a0
9D00F432  00023730   LHU T9, 2(S0)                1598:      lhu	    t9, 2(s0)		    //load y
9D00F436  00003B31   SH T9, 0(S1)                 1599:      sh	    t9, (s1)		    //start_y >> hw buffer
9D00F43A  00003B31   SH T9, 0(S1)                 1600:      sh	    t9, (s1)		    //end_y >> hw buffer
                                                  1601:  
9D00F43E  002C3260   ADDIU S3, ZERO, 44           1602:      li	    s3, 0x2C		    //write data
9D00F442      EE00   LI A0, 0                     1603:      _WRITE_COMMAND2 s3, s2, s1	    //command, dc fn, hw buffer, meni a0
9D00F462  00043730   LHU T9, 4(S0)                1604:      lhu	    t9, 4(s0)		    //load color
9D00F466  00003B31   SH T9, 0(S1)                 1605:      sh	    t9, (s1)		    //color >> hw buffer
                                                  1606:      
9D00F46A      4FA8   ADDIU SP, SP, 4              1607:      addiu   sp, 4		    //protoze vola c/c++ fci s jednim arg.
9D00F46C  5000229D   LWM S0-S3, RA, 0(SP)         1608:      _POP_S03RA    
9D00F472      45BF   JRC RA                       1609:      jrc	    ra
                                                  1610:      
                                                  1611:  .end drawPointQuick 
                                                  1612:      
                                                  1613:  //</editor-fold>    
---  /build/bamboo/xml-data/build-dir/XC32-CYIMG-BLD/xc32-XC32-release-1_44/pic32-libs/libpic32/stubs/pic32_software_reset.S
9D013BA4  0000477C   DI ZERO
9D013BA8  00001800   EHB
9D013BAC  41A3AA99   LUI V1, 0xAA99
9D013BB0  41A2BF80   LUI V0, 0xBF80
9D013BB4  30636655   ADDIU V1, V1, 26197
9D013BB8  F8023670   SW ZERO, 13936(V0)
9D013BBC  F8623670   SW V1, 13936(V0)
9D013BC0  41A35566   LUI V1, 0x5566
9D013BC4  506399AA   ORI V1, V1, -26198
9D013BC8  F8623670   SW V1, 13936(V0)
9D013BCC  41A2BF80   LUI V0, 0xBF80
9D013BD0      ED81   LI V1, 1
9D013BD2  F86226F8   SW V1, 9976(V0)
9D013BD6  41A2BF80   LUI V0, 0xBF80
9D013BDA  FC4226F0   LW V0, 9968(V0)
9D013BDE  D6809DD6   J 0x9D013BAC
9D013BE2      0C00   NOP
