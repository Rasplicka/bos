Priklady pouziti system timer (timer1)
--------------------------------------

Definice ovlivnujici chovani system timeru:
#define     TIMER1_INTERVAL         10              //def.h, definuje interval [ms] interruptu
                                                    //od timer1 a tim minimalni casovy usek v OS
                                                    //std. nastaveni pro radu MM=10, MZ=1

OS vyuziva timer1, ktery tim padem nemohou pouzivat aplikace.
Misto toho ale OS poskytuje funkce pro generovani casovych useku. Nejmensi casovy
usek je nastaven v TIMER1_INTERVAL v souboru def.h.. Pro radu MM je nastaveno 
na 10, tzn. 10ms, pro radu MZ 1ms. Takze kazdych 10ms (1ms) dochazi k interruptu 
od timeru1 a OS muze obsluhovat casove udalosti.

funkce pauseEvent(ms)
---------------------
Pozastavi provadeni aktualniho procesu na stanovenou dobu. Mezitim bezi ostatni
procesy. OS zajisti pauzu minimalne na pozadovanou dobu, ale muze trvat o neco dele.

void test()
{
    //blikani LED
    while(1)
    {
        //Zapne LED na 100ms
        testLedSet(1);
        pauseEvents(100);

        //Vypne LED na 500ms
        testLedClear(1);
        pauseEvents(500);
    }
}

Generovani casoveho intervalu  
-----------------------------
OS muze pravidelne generovat udalost, tedy volat zadanou fci, v urcenem 
intervalu [ms]. Nejprve je nutne registrovat prijemce udalosti pomoci fce
systemTimerRegInterval(void* fn, uint ms)

void app_start()
{
    //registrace udalosti. Prvni param. je adresa fce, druhy doba intervalu v ms
    systemTimerRegInterval(&testSystemTimer, 1000);

    while(1)
    {
        doEvents();
    }

}

void testSystemTimer(uint i)
{
    //tuto fci vola pravidelne OS, kazdych 1000 ms
    //param i obsahuje hodnotu intervalu, v tomto pripade i=1000

    //invertuje stav LED
    testLedInv(1); 
}

Pokud jiz tento casovy interval nebude aplikace pouzivat, musi registraci zrusit
volanim fce unregEvent(void* fn), kde fn je adresa fce, ktera se pouzila pri
registraci udalosti


    //pokracovani predchoziho prikladu
    //ukonci volani fce testSystemTimer
    unregEvent(&testSystemTimer);


Aplikace muze zaregistrovat vice casovych intervalu. Nasledujici priklad registruje
dva. Prvni bezi stale, druhy probehne pouze 5x.

int counter=0;

void app_start()
{
    //prvni registrace udalosti, interval 1000 ms
    systemTimerRegInterval(&test1, 1000);

    //druha registrace udalosti, interval 500 ms
    systemTimerRegInterval(&test2, 500);

    while(1)
    {
        doEvents();
    }
}

void test1(uint i)
{
    //tuto fci vola pravidelne OS, kazdych 1000 ms

    //invertuje stav LED1 
    testLedInv(1); 
}

void test2(uint i)
{
    //tuto fci vola pravidelne OS pouze 5x, kazdych 500 ms

    //invertuje stav LED2
    testLedInv(2); 

    counter++;

    if(counter==5)
    {
        //zrusi registraci teto udalosti
        unregEvent(&test2);
    }
}

Chcete-li mit jistotu, ze registrace probehla bez chyby - napr. ze tabulka
registraci neni plna, muzete pouzit tento zapis

if(systemTimerRegInterval(&test1, 1000) == NULL)
{
    //nastala chyba

}
else
{
    //registrace pribehla v poradku

}

Vyuziti fce getTimeMs() pro mereni doby
---------------------------------------

Navic OS poskytuje informaci o case, volanim fce getTimeMs() ktera vraci pocet ms
od zapnuti systemu. 
OS ji pravidelne aktualizuje (v interruptu timer1). Protoze obsahuje promenou 
typu uint a cita pocet ms, dochazi k jejimu preteceni jednou za 49 dnu. 
Chcete-li tento udaj pouzivat k mereni casoveho useku, pouzijte fci compareTimeMs,
ktera respektuje moznost preteceni (ale mereny usek musi byt kratsi nez 49 dnu)

void app_start()
{
    //zaznamenat aktualni cas
    uint before=getTimeMs();

    //budeme merit, jak dlouho trva fce go()
    go();

    //do delay se vlozi doba [ms], ktera uplynula
    uint delay=compareTimeMs(before);
}

Behem IDLE modu timer1 normalne pokracuje v cinnosti, proto fce getTimeMs() 
vraci platnou hodnoty.
Ve SLEEP modu je timer1 pozastaven a po probuzeni fce getTimeMs() vraci tomu
odpovidajici udaj. V dobe spanku necita.

Chce-li aplikace ziskat informace o realnem case, musi pouzit fce modulu RTC.

